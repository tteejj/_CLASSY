####\components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Enhanced data display components with sorting, filtering, and pagination

using namespace System.Text
using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Simple Table Classes

class TableColumn {
    [string]$Key
    [string]$Header
    [int]$Width
    [string]$Alignment = "Left"
    
    TableColumn([string]$key, [string]$header, [int]$width) {
        $this.Key = $key
        $this.Header = $header
        $this.Width = $width
    }
}

class Table : Component {
    [System.Collections.Generic.List[TableColumn]]$Columns
    [object[]]$Data = @()
    [int]$SelectedIndex = 0
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    
    Table([string]$name) : base($name) {
        $this.Columns = [System.Collections.Generic.List[TableColumn]]::new()
    }
    
    [void] SetColumns([TableColumn[]]$columns) {
        $this.Columns.Clear()
        foreach ($col in $columns) {
            $this.Columns.Add($col)
        }
    }
    
    [void] SetData([object[]]$data) {
        $this.Data = $data ?? @()
        if ($this.SelectedIndex -ge $this.Data.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.Data.Count - 1)
        }
    }
    
    [void] SelectNext() {
        if ($this.SelectedIndex -lt ($this.Data.Count - 1)) {
            $this.SelectedIndex++
        }
    }
    
    [void] SelectPrevious() {
        if ($this.SelectedIndex -gt 0) {
            $this.SelectedIndex--
        }
    }
    
    [object] GetSelectedItem() {
        if ($this.Data.Count -gt 0 -and $this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Data.Count) {
            return $this.Data[$this.SelectedIndex]
        }
        return $null
    }
    
    [string] _RenderContent() {
        $content = [System.Text.StringBuilder]::new()
        
        # Header
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            $headerLine = ""
            foreach ($col in $this.Columns) {
                $headerText = $col.Header.PadRight($col.Width).Substring(0, [Math]::Min($col.Header.Length, $col.Width))
                $headerLine += $headerText + " "
            }
            [void]$content.AppendLine($headerLine.TrimEnd())
            [void]$content.AppendLine("-" * $headerLine.TrimEnd().Length)
        }
        
        # Data rows
        for ($i = 0; $i -lt $this.Data.Count; $i++) {
            $row = $this.Data[$i]
            $rowLine = ""
            $isSelected = ($i -eq $this.SelectedIndex)
            
            foreach ($col in $this.Columns) {
                $cellValue = ""
                if ($row -is [hashtable] -and $row.ContainsKey($col.Key)) {
                    $cellValue = $row[$col.Key]?.ToString() ?? ""
                } elseif ($row.PSObject.Properties[$col.Key]) {
                    $cellValue = $row.($col.Key)?.ToString() ?? ""
                }
                
                $cellText = $cellValue.PadRight($col.Width).Substring(0, [Math]::Min($cellValue.Length, $col.Width))
                $rowLine += $cellText + " "
            }
            
            $finalLine = $rowLine.TrimEnd()
            if ($isSelected) {
                $finalLine = "> $finalLine"
            } else {
                $finalLine = "  $finalLine"
            }
            [void]$content.AppendLine($finalLine)
        }
        
        if ($this.Data.Count -eq 0) {
            [void]$content.AppendLine("  No data to display")
        }
        
        return $content.ToString()
    }
}

#endregion

#region Advanced Data Table Class

class DataTableComponent : UIElement {
    # ... (class content is unchanged) ...
    [hashtable[]] $Data = @()
    [hashtable[]] $Columns = @()
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 80
    [int] $Height = 20
    [string] $Title = "Data Table"
    [bool] $ShowBorder = $true
    [bool] $IsFocusable = $true
    [int] $SelectedRow = 0
    [int] $ScrollOffset = 0
    [string] $SortColumn
    [string] $SortDirection = "Ascending"
    [string] $FilterText = ""
    [string] $FilterColumn
    [int] $PageSize = 0  # 0 = auto-calculate
    [int] $CurrentPage = 0
    [bool] $ShowHeader = $true
    [bool] $ShowFooter = $true
    [bool] $ShowRowNumbers = $false
    [bool] $AllowSort = $true
    [bool] $AllowFilter = $true
    [bool] $AllowSelection = $true
    [bool] $MultiSelect = $false
    [int[]] $SelectedRows = @()
    [hashtable[]] $FilteredData = @()
    [hashtable[]] $ProcessedData = @()
    [bool] $FilterMode = $false
    hidden [int] $_lastRenderedWidth = 0
    hidden [int] $_lastRenderedHeight = 0
    
    # Event handlers
    [scriptblock] $OnRowSelect
    [scriptblock] $OnSelectionChange
    
    DataTableComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    DataTableComponent([string]$name, [hashtable[]]$data, [hashtable[]]$columns) : base($name) {
        $this.IsFocusable = $true
        $this.Data = $data
        $this.Columns = $columns
        $this.ProcessData()
    }
    
    [void] ProcessData() {
        Invoke-WithErrorHandling -Component "$($this.Name).ProcessData" -Context "Processing table data" -ScriptBlock {
            # Filter data
            if ([string]::IsNullOrWhiteSpace($this.FilterText)) {
                $this.FilteredData = $this.Data
            } else {
                if ($this.FilterColumn) {
                    # Filter specific column
                    $this.FilteredData = @($this.Data | Where-Object {
                        $value = $_."$($this.FilterColumn)"
                        $value -and $value.ToString() -like "*$($this.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $this.FilteredData = @($this.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $this.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($this.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($this.SortColumn -and $this.AllowSort) {
                $this.ProcessedData = $this.FilteredData | Sort-Object -Property $this.SortColumn -Descending:($this.SortDirection -eq "Descending")
            } else {
                $this.ProcessedData = $this.FilteredData
            }
            
            # Reset selection if needed
            if ($this.SelectedRow -ge $this.ProcessedData.Count) {
                $this.SelectedRow = [Math]::Max(0, $this.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($this.PageSize -eq 0) {
                $headerLines = $this.ShowHeader ? 3 : 0
                $footerLines = $this.ShowFooter ? 2 : 0
                $filterLines = $this.AllowFilter ? 2 : 0
                $borderAdjust = $this.ShowBorder ? 2 : 0
                $calculatedPageSize = $this.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                $this.PageSize = [Math]::Max(1, $calculatedPageSize)
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($this.ProcessedData.Count / [Math]::Max(1, $this.PageSize))
            if ($this.CurrentPage -ge $totalPages) {
                $this.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
    }
    
    [hashtable] GetContentBounds() {
        $borderOffset = $this.ShowBorder ? 1 : 0
        return @{
            X = $this.X + $borderOffset
            Y = $this.Y + $borderOffset
            Width = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
    
    hidden [string] _RenderContent() {
        $renderedContent = [StringBuilder]::new()
        
        # Force ProcessData if dimensions changed
        if ($this._lastRenderedWidth -ne $this.Width -or $this._lastRenderedHeight -ne $this.Height) {
            $this.ProcessData()
            $this._lastRenderedWidth = $this.Width
            $this._lastRenderedHeight = $this.Height
        }
        
        # Calculate content area based on border settings
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        $contentHeight = $this.Height

        if ($this.ShowBorder) {
            $borderColor = ($this.IsFocusable -and $this.IsFocused) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
            
            [void]$renderedContent.Append($this.MoveCursor($this.X, $this.Y))
            [void]$renderedContent.Append($this.SetColor($borderColor))
            [void]$renderedContent.Append($this.RenderBorder($this.Title))
            
            # Adjust content area for border
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
        }
        
        $currentY = $contentY
        
        # Filter bar
        if ($this.AllowFilter) {
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::White))
            [void]$renderedContent.Append("Filter: ")
            
            $filterDisplayText = $this.FilterText ? $this.FilterText : "Type to filter..."
            $filterColor = $this.FilterText ? [ConsoleColor]::Yellow : [ConsoleColor]::DarkGray
            [void]$renderedContent.Append($this.SetColor($filterColor))
            [void]$renderedContent.Append($filterDisplayText)
            
            $currentY += 2
        }
        
        # Calculate column widths
        $totalDefinedWidth = ($this.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
        $flexColumns = @($this.Columns | Where-Object { -not $_.Width })
        $columnSeparators = $this.Columns.Count -gt 1 ? $this.Columns.Count - 1 : 0
        $rowNumberWidth = $this.ShowRowNumbers ? 5 : 0
        $remainingWidth = $contentWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
        
        $flexWidth = ($flexColumns.Count -gt 0) ? [Math]::Floor($remainingWidth / $flexColumns.Count) : 0
        
        # Assign calculated widths
        foreach ($col in $this.Columns) {
            $col.CalculatedWidth = $col.Width ?? [Math]::Max(5, $flexWidth)
        }
        
        # Header
        if ($this.ShowHeader) {
            $headerX = $contentX
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append("#".PadRight(4))
                $headerX += 5
            }
            
            foreach ($col in $this.Columns) {
                $headerText = $col.Header ?? $col.Name
                $columnWidth = $col.CalculatedWidth
                
                if ($this.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $this.SortColumn) {
                    $sortIndicator = ($this.SortDirection -eq "Ascending") ? "▲" : "▼"
                    $headerText = "$headerText $sortIndicator"
                }
                
                if ($headerText.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $headerText = $headerText.Substring(0, $maxLength) + "..."
                }
                
                $alignedText = switch ($col.Align) {
                    "Right" { $headerText.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $headerText.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $headerText + " " * $rightPad
                    }
                    default { $headerText.PadRight($columnWidth) }
                }
                
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append($alignedText)
                
                $headerX += $columnWidth + 1
            }
            
            $currentY++
            
            [void]$renderedContent.Append($this.MoveCursor($contentX, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append("─" * $contentWidth)
            $currentY++
        }
        
        # Data rows
        $dataToRender = ($this.ProcessedData.Count -eq 0 -and $this.Data.Count -gt 0) ? $this.Data : $this.ProcessedData
        
        $startIdx = $this.CurrentPage * $this.PageSize
        $endIdx = [Math]::Min($startIdx + $this.PageSize - 1, $dataToRender.Count - 1)
        
        for ($i = $startIdx; $i -le $endIdx; $i++) {
            $row = $dataToRender[$i]
            $rowX = $contentX
            
            $isSelected = $this.MultiSelect ? ($this.SelectedRows -contains $i) : ($i -eq $this.SelectedRow)
            
            $rowBg = $isSelected ? [ConsoleColor]::Cyan : [ConsoleColor]::Black
            $rowFg = $isSelected ? [ConsoleColor]::Black : [ConsoleColor]::White
            
            if ($isSelected) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(" " * $contentWidth)
            }
            
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(($i + 1).ToString().PadRight(4))
                $rowX += 5
            }
            
            foreach ($col in $this.Columns) {
                $value = $row."$($col.Name)"
                $columnWidth = $col.CalculatedWidth
                
                $displayValue = if ($col.Format -and $value) { & $col.Format $value } else { "$($value)" }
                
                if ($displayValue.Length -gt $columnWidth) {
                    $maxLength = [Math]::Max(0, $columnWidth - 3)
                    $displayValue = ($maxLength -le 0) ? "..." : ($displayValue.Substring(0, $maxLength) + "...")
                }
                
                $alignedValue = switch ($col.Align) {
                    "Right" { $displayValue.PadLeft($columnWidth) }
                    "Center" {
                        $padding = $columnWidth - $displayValue.Length
                        $leftPad = [Math]::Floor($padding / 2)
                        $rightPad = $padding - $leftPad
                        " " * $leftPad + $displayValue + " " * $rightPad
                    }
                    default { $displayValue.PadRight($columnWidth) }
                }
                
                $cellFg = if ($col.Color -and -not $isSelected) {
                    Get-ThemeColor (& $col.Color $value $row)
                } else {
                    $rowFg
                }
                
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor($cellFg))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append($alignedValue)
                
                $rowX += $columnWidth + 1
            }
            
            $currentY++
        }
        
        # Empty state
        if ($dataToRender.Count -eq 0) {
            $emptyMessage = $this.FilterText ? "No results match the filter" : "No data to display"
            $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
            $msgY = $contentY + [Math]::Floor($contentHeight / 2)
            [void]$renderedContent.Append($this.MoveCursor($msgX, $msgY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($emptyMessage)
        }
        
        # Footer
        if ($this.ShowFooter) {
            $footerY = $contentY + $contentHeight - 1
            
            $statusText = "$($dataToRender.Count) rows"
            if ($this.FilterText) { $statusText += " (filtered from $($this.Data.Count))" }
            if ($this.MultiSelect) { $statusText += " | $($this.SelectedRows.Count) selected" }
            
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $footerY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($statusText)
            
            if ($dataToRender.Count -gt $this.PageSize) {
                $totalPages = [Math]::Ceiling($dataToRender.Count / [Math]::Max(1, $this.PageSize))
                $pageText = "Page $($this.CurrentPage + 1)/$totalPages"
                [void]$renderedContent.Append($this.MoveCursor($contentX + $contentWidth - $pageText.Length - 1, $footerY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Blue))
                [void]$renderedContent.Append($pageText)
            }
        }
        
        [void]$renderedContent.Append($this.ResetColor())
        return $renderedContent.ToString()
    }
    
    [bool] HandleInput([ConsoleKeyInfo]$key) {
        # Filter mode
        if ($key.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($key.Key) {
                ([ConsoleKey]::F) {
                    $this.FilterMode = -not $this.FilterMode
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::S) {
                    if ($this.AllowSort) {
                        $sortableCols = @($this.Columns | Where-Object { $_.Sortable -ne $false })
                        if ($sortableCols.Count -gt 0) {
                            $currentIdx = [array]::IndexOf($sortableCols.Name, $this.SortColumn)
                            $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                            $this.SortColumn = $sortableCols[$nextIdx].Name
                            $this.ProcessData()
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
            }
        }
        
        # Filter text input
        if ($this.FilterMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.FilterMode = $false
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $this.FilterMode = $false
                    $this.ProcessData()
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.FilterText.Length -gt 0) {
                        $this.FilterText = $this.FilterText.Substring(0, $this.FilterText.Length - 1)
                        $this.ProcessData()
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $this.FilterText += $key.KeyChar
                        $this.ProcessData()
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            return $false
        }
        
        # Normal navigation
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedRow -gt 0) {
                    $this.SelectedRow--
                    if ($this.SelectedRow -lt ($this.CurrentPage * $this.PageSize)) {
                        $this.CurrentPage--
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedRow -lt ($this.ProcessedData.Count - 1)) {
                    $this.SelectedRow++
                    if ($this.SelectedRow -ge (($this.CurrentPage + 1) * $this.PageSize)) {
                        $this.CurrentPage++
                    }
                    Request-TuiRefresh
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this.OnRowSelect -and $this.ProcessedData.Count -gt 0) {
                    $selectedData = $this.MultiSelect ? @($this.SelectedRows | ForEach-Object { $this.ProcessedData[$_] }) : $this.ProcessedData[$this.SelectedRow]
                    & $this.OnRowSelect $selectedData $this.SelectedRow
                }
                return $true
            }
        }
        
        return $false
    }
    
    # Helper methods for ANSI escape sequences
    hidden [string] MoveCursor([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{ Black=30;DarkRed=31;DarkGreen=32;DarkYellow=33;DarkBlue=34;DarkMagenta=35;DarkCyan=36;Gray=37;DarkGray=90;Red=91;Green=92;Yellow=93;Blue=94;Magenta=95;Cyan=96;White=97 }
        return "`e[$($colorMap[$color.ToString()])m"
    }
    
    hidden [string] SetBackgroundColor([ConsoleColor]$color) {
        $colorMap = @{ Black=40;DarkRed=41;DarkGreen=42;DarkYellow=43;DarkBlue=44;DarkMagenta=45;DarkCyan=46;Gray=47;DarkGray=100;Red=101;Green=102;Yellow=103;Blue=104;Magenta=105;Cyan=106;White=107 }
        return "`e[$($colorMap[$color.ToString()])m"
    }
    
    hidden [string] ResetColor() { return "`e[0m" }
    
    hidden [string] RenderBorder([string]$title) {
        $borderBuilder = [StringBuilder]::new()
        
        [void]$borderBuilder.Append("┌")
        
        if (-not [string]::IsNullOrWhiteSpace($title)) {
            $titleText = " $title "
            $horizontalSpace = $this.Width - 2
            if ($titleText.Length -gt $horizontalSpace) {
                $titleText = $titleText.Substring(0, $horizontalSpace)
            }
            
            $paddingBefore = [Math]::Floor(($horizontalSpace - $titleText.Length) / 2)
            $paddingAfter = $horizontalSpace - $titleText.Length - $paddingBefore
            
            [void]$borderBuilder.Append("─" * $paddingBefore)
            [void]$borderBuilder.Append($titleText)
            [void]$borderBuilder.Append("─" * $paddingAfter)
        } else {
            [void]$borderBuilder.Append("─" * ($this.Width - 2))
        }
        
        [void]$borderBuilder.Append("┐")
        
        for ($row = 1; $row -lt $this.Height - 1; $row++) {
            [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $row))
            [void]$borderBuilder.Append("│")
            [void]$borderBuilder.Append($this.MoveCursor($this.X + $this.Width - 1, $this.Y + $row))
            [void]$borderBuilder.Append("│")
        }
        
        [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $this.Height - 1))
        [void]$borderBuilder.Append("└")
        [void]$borderBuilder.Append("─" * ($this.Width - 2))
        [void]$borderBuilder.Append("┘")
        
        return $borderBuilder.ToString()
    }
    
    # Public methods
    [void] RefreshData() {
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetData([hashtable[]]$data) {
        $this.Data = $data
        $this.ProcessData()
        Request-TuiRefresh
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this.ProcessData()
        Request-TuiRefresh
    }
}
#endregion

#region Factory Functions for Backward Compatibility

function New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $name = $Props.Name ?? "DataTable_$([Guid]::NewGuid().ToString('N').Substring(0,8))"
    $data = $Props.Data ?? @()
    $columns = $Props.Columns ?? @()
    
    $table = [DataTableComponent]::new($name, $data, $columns)
    
    $table.X = $Props.X ?? $table.X
    $table.Y = $Props.Y ?? $table.Y
    $table.Width = $Props.Width ?? $table.Width
    $table.Height = $Props.Height ?? $table.Height
    $table.Title = $Props.Title ?? $table.Title
    $table.ShowBorder = $Props.ShowBorder ?? $table.ShowBorder
    $table.ShowHeader = $Props.ShowHeader ?? $table.ShowHeader
    $table.ShowFooter = $Props.ShowFooter ?? $table.ShowFooter
    $table.ShowRowNumbers = $Props.ShowRowNumbers ?? $table.ShowRowNumbers
    $table.AllowSort = $Props.AllowSort ?? $table.AllowSort
    $table.AllowFilter = $Props.AllowFilter ?? $table.AllowFilter
    $table.AllowSelection = $Props.AllowSelection ?? $table.AllowSelection
    $table.MultiSelect = $Props.MultiSelect ?? $table.MultiSelect
    $table.Visible = $Props.Visible ?? $table.Visible
    $table.OnRowSelect = $Props.OnRowSelect ?? $table.OnRowSelect
    $table.OnSelectionChange = $Props.OnSelectionChange ?? $table.OnSelectionChange
    
    return $table
}
#endregion

Export-ModuleMember -Function 'New-TuiDataTable'



####\components\advanced-input-components.psm1
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Value = $Props.Value ?? (Get-Date)
        Mode = $Props.Mode ?? "Date" # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = $Props.Value ?? (Get-Date)
        ViewDate = $Props.Value ?? (Get-Date)
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) { continue }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { Get-ThemeColor "Background" } elseif ($isToday) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                            $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(-1) } # Previous month
                        else { $date = $date.AddDays(-1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Previous day
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $self.ViewDate = $viewDate.AddMonths(1) } # Next month
                        else { $date = $date.AddDays(1); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } } # Next day
                    }
                    ([ConsoleKey]::UpArrow) { $date = $date.AddDays(-7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(7); if ($date.Month -ne $viewDate.Month) { $self.ViewDate = $date } }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) { $date = Get-Date; $self.ViewDate = $date }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock { & $self.OnSelect -Date $date } -AdditionalData @{ Component = $self.Name; SelectedDate = $date }
                        }
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $date } -AdditionalData @{ Component = $self.Name; NewValue = $date }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 3
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Type to search..."
        MaxDisplayItems = $Props.MaxDisplayItems ?? 5
        AllowCustomValue = $Props.AllowCustomValue ?? $false
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        $displayText = $selected ? $selected.Display : $self.Value.ToString()
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = $self.IsOpen ? "▲" : "▼"
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = ($self.SelectedIndex -ge $self.MaxDisplayItems) ? ($self.SelectedIndex - $self.MaxDisplayItems + 1) : 0
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                        $bg = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                if ($matchIndex -gt 0) { Write-BufferString -X ($self.X + 2) -Y $y -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg }
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y -Text $text.Substring($matchIndex, $self.SearchText.Length) -ForegroundColor (Get-ThemeColor "Warning")
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) { Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y -Text $text.Substring($afterMatch) -ForegroundColor $fg }
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = ($i -eq $scrollPos) ? "█" : "│"
                            $color = ($i -eq $scrollPos) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                $this.FilteredOptions = if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.Options
                } else {
                    @($this.Options | Where-Object { $_.Display -like "*$($this.SearchText)*" })
                }
                
                if ($this.AllowCustomValue -and $this.SearchText -and -not ($this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText })) {
                    $this.FilteredOptions = @(@{ Display = $this.SearchText; Value = $this.SearchText; IsCustom = $true }) + $this.FilteredOptions
                }
                
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        $self.SearchText = ""
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                    return $false
                }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) { $self.IsOpen = $false; $self.SearchText = ""; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $selected.Value -Option $selected } -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) { if ($self.SelectedIndex -gt 0) { $self.SelectedIndex--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::DownArrow) { if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) { $self.SelectedIndex++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Options = $Props.Options ?? @()
        SelectedValues = $Props.SelectedValues ?? @()
        Title = $Props.Title ?? "Select items"
        AllowSelectAll = $Props.AllowSelectAll ?? $true
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor -Title " $($self.Title) "
                
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = $allSelected ? "[X]" : "[ ]"
                    $fg = ($self.SelectedIndex -eq -1) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" -ForegroundColor $fg
                    $currentY += 2
                }
                
                $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = $isChecked ? "[X]" : "[ ]"
                    $fg = $isHighlighted ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) { $text = $text.Substring(0, $self.Width - 7) + "..." }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) { $self.SelectedIndex = -1 } 
                        elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) { $self.ScrollOffset = $self.SelectedIndex }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4 - ($self.AllowSelectAll ? 2 : 0)
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) { $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1 }
                        }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            $self.SelectedValues = ($self.SelectedValues.Count -eq $self.Options.Count) ? @() : @($self.Options.Value)
                        } elseif ($self.SelectedIndex -ge 0) {
                            $optionValue = $self.Options[$self.SelectedIndex].Value
                            if ($self.SelectedValues -contains $optionValue) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $optionValue })
                            } else {
                                $self.SelectedValues += $optionValue
                            }
                        }
                        
                        if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -SelectedValues $self.SelectedValues } }
                        Request-TuiRefresh; return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) { Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock { & $self.OnSubmit -SelectedValues $self.SelectedValues } }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Value = $Props.Value ?? 0
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        DecimalPlaces = $Props.DecimalPlaces ?? 0
        IsFocusable = $true
        TextValue = ($Props.Value ?? 0).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Border")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) { $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..." }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) { Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent") }
                }
                
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" -ForegroundColor $borderColor
                
                if ($self.Value -le $self.Min) { Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" -ForegroundColor (Get-ThemeColor "Warning") }
                if ($self.Value -ge $self.Max) { Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" -ForegroundColor (Get-ThemeColor "Warning") }
            } catch { Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                $newValue = ($this.DecimalPlaces -eq 0) ? [Math]::Floor($newValue) : [Math]::Round($newValue, $this.DecimalPlaces)
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) { Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock { & $this.OnChange -NewValue $newValue } }
                return $true
            } catch {
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::DownArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step); $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)"); $self.CursorPosition = $self.TextValue.Length; if ($self.OnChange) { & $self.OnChange -NewValue $self.Value }; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::LeftArrow) { if ($self.CursorPosition -gt 0) { $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::RightArrow) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.CursorPosition++; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Home) { $self.CursorPosition = 0; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::End) { $self.CursorPosition = $self.TextValue.Length; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Backspace) { if ($self.CursorPosition -gt 0) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1); $self.CursorPosition--; Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Delete) { if ($self.CursorPosition -lt $self.TextValue.Length) { $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1); Request-TuiRefresh }; return $true }
                    ([ConsoleKey]::Enter) { & $self.ValidateAndUpdate -self $self; Request-TuiRefresh; return $true }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch { Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

function New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 1
        Value = $Props.Value ?? 50
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        ShowValue = $Props.ShowValue ?? $true
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("─" * $trackWidth) -ForegroundColor (Get-ThemeColor "Subtle")
                if ($thumbPos -gt 0) { Write-BufferString -X ($self.X + 1) -Y $self.Y -Text ("═" * $thumbPos) -ForegroundColor $fg }
                
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch { Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ } }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) { $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step) }
                    ([ConsoleKey]::RightArrow) { $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step) }
                    ([ConsoleKey]::Home) { $self.Value = $self.Min }
                    ([ConsoleKey]::End) { $self.Value = $self.Max }
                    ([ConsoleKey]::PageDown) { $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep) }
                    ([ConsoleKey]::PageUp) { $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep) }
                    default { $handled = $false }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Value } }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch { Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ } }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function 'New-TuiCalendarPicker', 'New-TuiSearchableDropdown', 'New-TuiMultiSelect', 'New-TuiNumberInput', 'New-TuiSlider'


####\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Implements navigation menu functionality with keyboard shortcuts

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key))   { throw [ArgumentException]::new("Navigation key cannot be null or empty") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [ArgumentException]::new("Navigation label cannot be null or empty") }
        if ($null -eq $action)                    { throw [ArgumentNullException]::new("action", "Navigation action cannot be null") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)" -Component "NavigationItem"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)" -Component "NavigationItem"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_" -Component "NavigationItem"
            throw
        }
    }
    
    [string] FormatDisplay([bool]$showDescription = $false) {
        $display = [System.Text.StringBuilder]::new()
        
        [void]$display.Append($this.SetColor($this.KeyColor)).Append("[$($this.Key)]").Append($this.ResetColor()).Append(" ")
        
        if ($this.Enabled) {
            [void]$display.Append($this.SetColor($this.LabelColor)).Append($this.Label)
        }
        else {
            [void]$display.Append($this.SetColor([ConsoleColor]::DarkGray)).Append($this.Label).Append(" (Disabled)")
        }
        [void]$display.Append($this.ResetColor())
        
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            [void]$display.Append(" - ").Append($this.SetColor([ConsoleColor]::Gray)).Append($this.Description).Append($this.ResetColor())
        }
        
        return $display.ToString()
    }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{ Black=30;DarkRed=31;DarkGreen=32;DarkYellow=33;DarkBlue=34;DarkMagenta=35;DarkCyan=36;Gray=37;DarkGray=90;Red=91;Green=92;Yellow=93;Blue=94;Magenta=95;Cyan=96;White=97 }
        return "`e[$($colorMap[$color.ToString()])m"
    }
    
    hidden [string] ResetColor() { return "`e[0m" }
}

# NavigationMenu - Component for displaying and handling navigation options
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Vertical"
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    [int] $SelectedIndex = 0
    
    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
    }
    
    NavigationMenu([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) { throw [ArgumentNullException]::new("services") }
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
    }
    
    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [ArgumentNullException]::new("item") }
        if ($this.Items.Exists({$_.Key -eq $item.Key})) { throw [InvalidOperationException]::new("Item with key '$($item.Key)' already exists") }
        $this.Items.Add($item)
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.GetItem($key)
        if ($item) { [void]$this.Items.Remove($item) }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items.Find({$_.Key -eq $key.ToUpper()})
    }

    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        if ($item -and $item.Visible) {
            Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock { $item.Execute() }
        }
    }

    [void] AddSeparator() {
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
    }

    # AI: FIX - Corrected the syntax within the switch statement blocks.
    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", { $this.Services.Navigation.PushScreen("NewTaskScreen") }))
                $this.AddItem([NavigationItem]::new("P", "Projects", { $this.Services.Navigation.PushScreen("ProjectListScreen") }))
                $this.AddItem([NavigationItem]::new("S", "Settings", { $this.Services.Navigation.PushScreen("SettingsScreen") }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("Q", "Quit", { $this.Services.AppState.RequestExit() }))
            }
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", { $this.Services.Navigation.PushScreen("NewTaskScreen") }))
                $this.AddItem([NavigationItem]::new("E", "Edit", { }))
                $this.AddItem([NavigationItem]::new("D", "Delete", { }))
                $this.AddItem([NavigationItem]::new("F", "Filter", { $this.Services.Navigation.PushScreen("FilterScreen") }))
                $this.AddSeparator()
                $this.AddItem([NavigationItem]::new("B", "Back", { $this.Services.Navigation.PopScreen() }))
            }
            default {
                $this.AddItem([NavigationItem]::new("B", "Back", { $this.Services.Navigation.PopScreen() }))
                $this.AddItem([NavigationItem]::new("H", "Home", { $this.Services.Navigation.NavigateToRoot() }))
            }
        }
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "NavigationMenu" -Context "Render:$($this.Name)" -ScriptBlock {
            $menuBuilder = [System.Text.StringBuilder]::new()
            $visibleItems = $this.Items | Where-Object { $_.Visible }
            if ($visibleItems.Count -eq 0) { return "" }
            
            if ($this.Orientation -eq "Horizontal") { $this.RenderHorizontal($menuBuilder, $visibleItems) }
            else { $this.RenderVertical($menuBuilder, $visibleItems) }
            
            return $menuBuilder.ToString()
        }
    }
    
    hidden [void] RenderHorizontal([System.Text.StringBuilder]$builder, [object[]]$items) {
        $isFirst = $true
        foreach ($item in $items) {
            if (-not $isFirst) {
                [void]$builder.Append($this.SetColor($this.SeparatorColor)).Append($this.Separator).Append($this.ResetColor())
            }
            [void]$builder.Append($item.FormatDisplay($this.ShowDescriptions))
            $isFirst = $false
        }
    }
    
    hidden [void] RenderVertical([System.Text.StringBuilder]$builder, [object[]]$items) {
        for ($i = 0; $i -lt $items.Count; $i++) {
            $item = $items[$i]
            if ($i -eq $this.SelectedIndex -and $item.Key -ne "-") {
                [void]$builder.Append($this.SetColor([ConsoleColor]::Black)).Append($this.SetBackgroundColor([ConsoleColor]::White))
                [void]$builder.Append(" > ").Append($item.FormatDisplay($this.ShowDescriptions)).Append(" ").Append($this.ResetColor())
            } else {
                [void]$builder.Append("   ").Append($item.FormatDisplay($this.ShowDescriptions))
            }
            [void]$builder.AppendLine()
        }
    }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{ Black=30;DarkRed=31;DarkGreen=32;DarkYellow=33;DarkBlue=34;DarkMagenta=35;DarkCyan=36;Gray=37;DarkGray=90;Red=91;Green=92;Yellow=93;Blue=94;Magenta=95;Cyan=96;White=97 }
        return "`e[$($colorMap[$color.ToString()])m"
    }
    
    hidden [string] SetBackgroundColor([ConsoleColor]$color) {
        $colorMap = @{ Black=40;DarkRed=41;DarkGreen=42;DarkYellow=43;DarkBlue=44;DarkMagenta=45;DarkCyan=46;Gray=47;White=107 }
        return "`e[$($colorMap[$color.ToString()])m"
    }
    
    hidden [string] ResetColor() { return "`e[0m" }
}


####\components\tui-components.psm1
# TUI Component Library
# Stateful component factories following the canonical architecture

#region Basic Components

function New-TuiLabel {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Label"
        IsFocusable = $false
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 10
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Text = $Props.Text ?? ""
        ForegroundColor = $Props.ForegroundColor
        Name = $Props.Name
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                $fg = $self.ForegroundColor ?? (Get-ThemeColor "Primary")
                Write-BufferString -X $self.X -Y $self.Y -Text $self.Text -ForegroundColor $fg
            } catch { Write-Log -Level Error -Message "Label Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = { param($self, $Key) return $false }
    }
}

function New-TuiButton {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Button"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 10
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Text = $Props.Text ?? "Button"
        Name = $Props.Name
        IsPressed = $false
        OnClick = $Props.OnClick
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                $bgColor = $self.IsPressed ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                $fgColor = $self.IsPressed ? (Get-ThemeColor "Background") : $borderColor
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor -BackgroundColor $bgColor
                $textX = $self.X + [Math]::Floor(($self.Width - $self.Text.Length) / 2)
                Write-BufferString -X $textX -Y ($self.Y + 1) -Text $self.Text -ForegroundColor $fgColor -BackgroundColor $bgColor
            } catch { Write-Log -Level Error -Message "Button Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    if ($self.OnClick) { Invoke-WithErrorHandling -Component "$($self.Name).OnClick" -ScriptBlock { & $self.OnClick } }
                    Request-TuiRefresh
                    return $true
                }
            } catch { Write-Log -Level Error -Message "Button HandleInput error for '$($self.Name)': $_" }
            return $false
        }
    }
}

function New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "TextBox"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? ""
        MaxLength = $Props.MaxLength ?? 100
        Name = $Props.Name
        CursorPosition = $Props.CursorPosition ?? 0
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = $self.Text ?? ""
                if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) { $displayText = $self.Placeholder ?? "" }
                
                $maxDisplayLength = $self.Width - 4
                if ($displayText.Length -gt $maxDisplayLength) { $displayText = $displayText.Substring(0, $maxDisplayLength) }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayText.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
                }
            } catch { Write-Log -Level Error -Message "TextBox Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $text = $self.Text ?? ""
                $cursorPos = $self.CursorPosition ?? 0
                $oldText = $text
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) { if ($cursorPos -gt 0) { $text = $text.Remove($cursorPos - 1, 1); $cursorPos-- } }
                    ([ConsoleKey]::Delete) { if ($cursorPos -lt $text.Length) { $text = $text.Remove($cursorPos, 1) } }
                    ([ConsoleKey]::LeftArrow) { if ($cursorPos -gt 0) { $cursorPos-- } }
                    ([ConsoleKey]::RightArrow) { if ($cursorPos -lt $text.Length) { $cursorPos++ } }
                    ([ConsoleKey]::Home) { $cursorPos = 0 }
                    ([ConsoleKey]::End) { $cursorPos = $text.Length }
                    ([ConsoleKey]::V) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                $clipboardText = Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                if ($clipboardText) {
                                    $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                    $remainingSpace = $self.MaxLength - $text.Length
                                    if ($remainingSpace -gt 0) {
                                        $toInsert = $clipboardText.Length -gt $remainingSpace ? $clipboardText.Substring(0, $remainingSpace) : $clipboardText
                                        $text = $text.Insert($cursorPos, $toInsert)
                                        $cursorPos += $toInsert.Length
                                    }
                                }
                            } catch { Write-Log -Level Warning -Message "TextBox clipboard paste error for '$($self.Name)': $_" }
                        } else {
                            if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) { $text = $text.Insert($cursorPos, $Key.KeyChar); $cursorPos++ } 
                            else { return $false }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) { $text = $text.Insert($cursorPos, $Key.KeyChar); $cursorPos++ } 
                        else { return $false }
                    }
                }
                
                if ($text -ne $oldText -or $cursorPos -ne $self.CursorPosition) {
                    $self.Text = $text
                    $self.CursorPosition = $cursorPos
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $text } }
                    Request-TuiRefresh
                }
                return $true
            } catch { Write-Log -Level Error -Message "TextBox HandleInput error for '$($self.Name)': $_"; return $false }
        }
    }
}

function New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "CheckBox"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Text = $Props.Text ?? "Checkbox"
        Checked = $Props.Checked ?? $false
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                $fg = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                $checkbox = $self.Checked ? "[X]" : "[ ]"
                Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
            } catch { Write-Log -Level Error -Message "CheckBox Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    $self.Checked = -not $self.Checked
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Checked } }
                    Request-TuiRefresh
                    return $true
                }
            } catch { Write-Log -Level Error -Message "CheckBox HandleInput error for '$($self.Name)': $_" }
            return $false
        }
    }
}

function New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Dropdown"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 10
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Select..."
        Name = $Props.Name
        IsOpen = $false
        SelectedIndex = 0
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = $self.Placeholder
                if ($self.Value -and $self.Options) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) { $displayText = $selected.Display }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                $indicator = $self.IsOpen ? "▲" : "▼"
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
                
                if ($self.IsOpen -and $self.Options.Count -gt 0) {
                    $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                    Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $displayCount = [Math]::Min($self.Options.Count, 6)
                    for ($i = 0; $i -lt $displayCount; $i++) {
                        $option = $self.Options[$i]
                        $y = $self.Y + 4 + $i
                        $fg = ($i -eq $self.SelectedIndex) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Primary")
                        $bg = ($i -eq $self.SelectedIndex) ? (Get-ThemeColor "Secondary") : (Get-ThemeColor "Background")
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) { $text = $text.Substring(0, $self.Width - 7) + "..." }
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                }
            } catch { Write-Log -Level Error -Message "Dropdown Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        Request-TuiRefresh
                        return $true
                    }
                } else {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) { if ($self.SelectedIndex -gt 0) { $self.SelectedIndex--; Request-TuiRefresh }; return $true }
                        ([ConsoleKey]::DownArrow) { if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { $self.SelectedIndex++; Request-TuiRefresh }; return $true }
                        ([ConsoleKey]::Enter) {
                            if ($self.Options.Count -gt 0) {
                                $selected = $self.Options[$self.SelectedIndex]
                                $self.Value = $selected.Value
                                if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $selected.Value } }
                            }
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Escape) { $self.IsOpen = $false; Request-TuiRefresh; return $true }
                    }
                }
            } catch { Write-Log -Level Error -Message "Dropdown HandleInput error for '$($self.Name)': $_" }
            return $false
        }
    }
}

function New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "ProgressBar"
        IsFocusable = $false
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Value = $Props.Value ?? 0
        Max = $Props.Max ?? 100
        ShowPercent = $Props.ShowPercent ?? $false
        Name = $Props.Name
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
                $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
                $empty = ($self.Width - 2) - $filled
                
                $bar = "█" * $filled + "░" * $empty
                Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
                
                if ($self.ShowPercent) {
                    $percentText = "$([Math]::Round($percent))%"
                    $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch { Write-Log -Level Error -Message "ProgressBar Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = { param($self, $Key) return $false }
    }
}

function New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "TextArea"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 6
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? "Enter text..."
        WrapText = $Props.WrapText ?? $true
        Name = $Props.Name
        Lines = ($Props.Text ?? "") -split "`n"
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $innerWidth = $self.Width - 4
                $innerHeight = $self.Height - 2
                $displayLines = if ($self.WrapText) {
                    $self.Lines | ForEach-Object { Get-WordWrappedLines -Text $_ -MaxWidth $innerWidth }
                } else {
                    $self.Lines
                }
                
                if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                    Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                    return
                }
                
                $startLine = $self.ScrollOffset
                $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
                
                for ($i = $startLine; $i -le $endLine; $i++) {
                    $y = $self.Y + 1 + ($i - $startLine)
                    $line = $displayLines[$i]
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $line
                }
                
                if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                    $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                    $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                    Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" -BackgroundColor (Get-ThemeColor "Accent")
                }
                
                if ($displayLines.Count -gt $innerHeight) {
                    $scrollbarHeight = $innerHeight
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = ($i -eq $scrollPosition) ? "█" : "│"
                        $color = ($i -eq $scrollPosition) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch { Write-Log -Level Error -Message "TextArea Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $lines = $self.Lines
                $cursorY = $self.CursorY
                $cursorX = $self.CursorX
                $innerHeight = $self.Height - 2
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { if ($cursorY -gt 0) { $cursorY--; $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length); if ($cursorY -lt $self.ScrollOffset) { $self.ScrollOffset = $cursorY } } }
                    ([ConsoleKey]::DownArrow) { if ($cursorY -lt $lines.Count - 1) { $cursorY++; $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length); if ($cursorY -ge $self.ScrollOffset + $innerHeight) { $self.ScrollOffset = $cursorY - $innerHeight + 1 } } }
                    ([ConsoleKey]::LeftArrow) { if ($cursorX -gt 0) { $cursorX-- } elseif ($cursorY -gt 0) { $cursorY--; $cursorX = $lines[$cursorY].Length } }
                    ([ConsoleKey]::RightArrow) { if ($cursorX -lt $lines[$cursorY].Length) { $cursorX++ } elseif ($cursorY -lt $lines.Count - 1) { $cursorY++; $cursorX = 0 } }
                    ([ConsoleKey]::Home) { $cursorX = 0 }
                    ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                    ([ConsoleKey]::Enter) {
                        $currentLine = $lines[$cursorY]
                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                        $afterCursor = $currentLine.Substring($cursorX)
                        $lines[$cursorY] = $beforeCursor
                        $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                        $cursorY++; $cursorX = 0
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { $self.ScrollOffset = $cursorY - $innerHeight + 1 }
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($cursorX -gt 0) { $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1); $cursorX-- } 
                        elseif ($cursorY -gt 0) {
                            $prevLineLength = $lines[$cursorY - 1].Length; $lines[$cursorY - 1] += $lines[$cursorY]
                            $lines = @($lines | Where-Object { $_ -ne $lines[$cursorY] }); $cursorY--; $cursorX = $prevLineLength
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($cursorX -lt $lines[$cursorY].Length) { $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) } 
                        elseif ($cursorY -lt $lines.Count - 1) {
                            $lines[$cursorY] += $lines[$cursorY + 1]; $lines = @($lines | Where-Object { $_ -ne $lines[$cursorY + 1] })
                        }
                    }
                    ([ConsoleKey]::V) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                $clipboardText = Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                if ($clipboardText) {
                                    $clipboardLines = $clipboardText -split '[\r\n]+'
                                    if ($clipboardLines.Count -eq 1) {
                                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0]); $cursorX += $clipboardLines[0].Length
                                    } else {
                                        $currentLine = $lines[$cursorY]; $beforeCursor = $currentLine.Substring(0, $cursorX); $afterCursor = $currentLine.Substring($cursorX)
                                        $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                        $insertLines = $clipboardLines[1..($clipboardLines.Count - 2)] + ($clipboardLines[-1] + $afterCursor)
                                        $newLines = @($lines[0..$cursorY]) + $insertLines + @($lines[($cursorY + 1)..($lines.Count - 1)])
                                        $lines = $newLines; $cursorY += $clipboardLines.Count - 1; $cursorX = $clipboardLines[-1].Length
                                    }
                                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { $self.ScrollOffset = $cursorY - $innerHeight + 1 }
                                }
                            } catch { Write-Log -Level Warning -Message "TextArea clipboard paste error for '$($self.Name)': $_" }
                        } else {
                            if (-not [char]::IsControl($Key.KeyChar)) { $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar); $cursorX++ } 
                            else { return $false }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) { $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar); $cursorX++ } 
                        else { return $false }
                    }
                }
                
                $self.Lines = $lines; $self.CursorX = $cursorX; $self.CursorY = $cursorY; $self.Text = $lines -join "`n"
                if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $self.Text } }
                Request-TuiRefresh
                return $true
            } catch { Write-Log -Level Error -Message "TextArea HandleInput error for '$($self.Name)': $_"; return $false }
        }
    }
    
    return $component
}

#endregion

#region DateTime Components

function New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "DatePicker"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Value = $Props.Value ?? (Get-Date)
        Format = $Props.Format ?? "yyyy-MM-dd"
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                $dateStr = $self.Value.ToString($self.Format)
                
                $maxLength = $self.Width - 6
                if ($dateStr.Length -gt $maxLength) { $dateStr = $dateStr.Substring(0, $maxLength) }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
                if ($self.IsFocused -and $self.Width -ge 6) { Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "📅" -ForegroundColor $borderColor }
            } catch { Write-Log -Level Error -Message "DatePicker Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $date = $self.Value
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                    ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                    ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                    ([ConsoleKey]::Home)      { $date = Get-Date }
                    ([ConsoleKey]::T) { if ($Key.Modifiers -band [ConsoleModifiers]::Control) { $date = Get-Date } else { $handled = $false } }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Value = $date
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewValue $date } }
                    Request-TuiRefresh
                }
                return $handled
            } catch { Write-Log -Level Error -Message "DatePicker HandleInput error for '$($self.Name)': $_"; return $false }
        }
    }
}

function New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "TimePicker"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 15
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Hour = $Props.Hour ?? 0
        Minute = $Props.Minute ?? 0
        Format24H = $Props.Format24H ?? $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $timeStr = if ($self.Format24H) { 
                    "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
                } else {
                    $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                    $ampm = ($self.Hour -lt 12) ? "AM" : "PM"
                    "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
                }
                
                $maxLength = $self.Width - 6
                if ($timeStr.Length -gt $maxLength) { $timeStr = $timeStr.Substring(0, $maxLength) }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
                if ($self.IsFocused -and $self.Width -ge 6) { Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "⏰" -ForegroundColor $borderColor }
            } catch { Write-Log -Level Error -Message "TimePicker Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true; $hour = $self.Hour; $minute = $self.Minute
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { $minute = ($minute + 15) % 60; if ($minute -eq 0) { $hour = ($hour + 1) % 24 } }
                    ([ConsoleKey]::DownArrow) { $minute = ($minute - 15 + 60) % 60; if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } }
                    ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                    ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                    default { $handled = $false }
                }
                if ($handled) {
                    $self.Hour = $hour; $self.Minute = $minute
                    if ($self.OnChange) { Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock { & $self.OnChange -NewHour $hour -NewMinute $minute } }
                    Request-TuiRefresh
                }
                return $handled
            } catch { Write-Log -Level Error -Message "TimePicker HandleInput error for '$($self.Name)': $_"; return $false }
        }
    }
}

#endregion

#region Data Display Components

function New-TuiTable {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Table"
        IsFocusable = $true
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 60
        Height = $Props.Height ?? 15
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        Columns = $Props.Columns ?? @()
        Rows = $Props.Rows ?? @()
        Name = $Props.Name
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        OnRowSelect = $Props.OnRowSelect
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
                
                $borderColor = $self.IsFocused ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Secondary")
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $totalWidth = $self.Width - 4; $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count); $headerY = $self.Y + 1; $currentX = $self.X + 2
                
                foreach ($col in $self.Columns) {
                    $header = $col.Header
                    if ($col.Name -eq $self.SortColumn) { $header += $self.SortAscending ? " ▲" : " ▼" }
                    if ($header.Length -gt $colWidth - 1) { $header = $header.Substring(0, $colWidth - 4) + "..." }
                    Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header"); $currentX += $colWidth
                }
                
                Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("─" * ($self.Width - 2)) -ForegroundColor $borderColor
                
                $visibleRows = $self.Height - 5; $startIdx = $self.ScrollOffset; $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.Rows[$i]; $rowY = ($headerY + 2) + ($i - $startIdx); $currentX = $self.X + 2
                    $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                    $bgColor = $isSelected ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Background")
                    $fgColor = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                    
                    if ($isSelected) { Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor }
                    
                    foreach ($col in $self.Columns) {
                        $value = $row.($col.Name) ?? ""; $text = $value.ToString()
                        if ($text.Length -gt $colWidth - 1) { $text = $text.Substring(0, $colWidth - 4) + "..." }
                        Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor; $currentX += $colWidth
                    }
                }
                
                if ($self.Rows.Count -gt $visibleRows) {
                    $scrollbarHeight = $visibleRows; $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = ($i -eq $scrollPosition) ? "█" : "│"
                        $color = ($i -eq $scrollPosition) ? (Get-ThemeColor "Accent") : (Get-ThemeColor "Subtle")
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch { Write-Log -Level Error -Message "Table Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.Rows.Count -eq 0) { return $false }
                $visibleRows = $self.Height - 5; $handled = $true
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { if ($self.SelectedRow -gt 0) { $self.SelectedRow--; if ($self.SelectedRow -lt $self.ScrollOffset) { $self.ScrollOffset = $self.SelectedRow }; Request-TuiRefresh } }
                    ([ConsoleKey]::DownArrow) { if ($self.SelectedRow -lt $self.Rows.Count - 1) { $self.SelectedRow++; if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 }; Request-TuiRefresh } }
                    ([ConsoleKey]::PageUp) { $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows); $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows); Request-TuiRefresh }
                    ([ConsoleKey]::PageDown) { $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows); $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows); $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows); Request-TuiRefresh }
                    ([ConsoleKey]::Home) { $self.SelectedRow = 0; $self.ScrollOffset = 0; Request-TuiRefresh }
                    ([ConsoleKey]::End) { $self.SelectedRow = $self.Rows.Count - 1; $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows); Request-TuiRefresh }
                    ([ConsoleKey]::Enter) { if ($self.OnRowSelect) { Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -ScriptBlock { & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow } } }
                    default {
                        if ($Key.KeyChar -match '\d') {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $colName = $self.Columns[$colIndex].Name
                                if ($self.SortColumn -eq $colName) { $self.SortAscending = -not $self.SortAscending } 
                                else { $self.SortColumn = $colName; $self.SortAscending = $true }
                                $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                                Request-TuiRefresh
                            }
                        } else { $handled = $false }
                    }
                }
            } catch { Write-Log -Level Error -Message "Table HandleInput error for '$($self.Name)': $_" }
            return $handled
        }
    }
}

function New-TuiChart {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Chart"
        IsFocusable = $false
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 10
        Visible = $Props.Visible ?? $true
        ZIndex = $Props.ZIndex ?? 0
        ChartType = $Props.ChartType ?? "Bar"
        Data = $Props.Data ?? @()
        ShowValues = $Props.ShowValues ?? $true
        Name = $Props.Name
        
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
                
                switch ($self.ChartType) {
    		   # "Bar" {
                                            "Bar" {
                        $maxValue = ($self.Data.Value | Measure-Object -Maximum).Maximum ?? 1
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        $chartHeight = $self.Height - 2
                        $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                        
                        for ($i = 0; $i -lt $self.Data.Count; $i++) {
                            $item = $self.Data[$i]
                            $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                            $barX = $self.X + 2 + ($i * $barWidth)
                            
                            for ($y = 0; $y -lt $barHeight; $y++) { 
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 2 - $y) -Text ("█" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                            }
                            if ($item.Label -and $barWidth -gt 3) { 
                                $label = $item.Label
                                if ($label.Length -gt $barWidth - 1) { $label = $label.Substring(0, $barWidth - 2) }
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                            }
                            if ($self.ShowValues -and $barHeight -gt 0) { 
                                $valueText = $item.Value.ToString()
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                            }
                        }
                    }
                    "Sparkline" {
                        $width = $self.Width - 2; $height = $self.Height - 1; $maxValue = ($self.Data | Measure-Object -Maximum).Maximum ?? 1
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        $sparkChars = " ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█"
                        $sparkline = ""
                        foreach ($value in $self.Data) { $normalized = $value / $maxValue; $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1)); $sparkline += $sparkChars[$charIndex] }
                        if ($sparkline.Length -gt $width) { $sparkline = $sparkline.Substring($sparkline.Length - $width) } else { $sparkline = $sparkline.PadLeft($width) }
                        Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                    }
                }
            } catch { Write-Log -Level Error -Message "Chart Render error for '$($self.Name)': $_" }
        }
        
        HandleInput = { param($self, $Key) return $false }
    }
}

#endregion

Export-ModuleMember -Function 'New-TuiLabel', 'New-TuiButton', 'New-TuiTextBox', 'New-TuiCheckBox', 'New-TuiDropdown', 'New-TuiProgressBar', 'New-TuiTextArea', 'New-TuiDatePicker', 'New-TuiTimePicker', 'New-TuiTable', 'New-TuiChart'


####\components\ui-classes.psm1
# ==============================================================================
# PMC Terminal v5 - Base UI Class Hierarchy
# Provides the foundational classes for all UI components.
# ==============================================================================

using namespace System.Text
using namespace System.Management.Automation

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# --- Base UI Element (with integrated safe rendering) ---
class UIElement {
    [string]$Name
    [bool]$Visible = $true
    [bool]$Enabled = $true
    
    UIElement([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [ArgumentException]::new("UIElement name cannot be null or empty.")
        }
        $this.Name = $name
    }

    [string] Render() {
        return Invoke-WithErrorHandling -Component $this.Name -Context "Render" -ScriptBlock {
            if (-not $this.Visible) { return "" }
            return $this._RenderContent()
        } -AdditionalData @{ ComponentType = $this.GetType().Name }
    }

    hidden [string] _RenderContent() {
        throw [NotImplementedException]::new("Component '$($this.Name)' of type '$($this.GetType().Name)' must implement the _RenderContent() method.")
    }
    
    [string] ToString() {
        return "$($this.GetType().Name): $($this.Name)"
    }
}

# --- Base Component (can contain children) ---
class Component : UIElement {
    [object]$Parent
    [System.Collections.Generic.List[UIElement]]$Children

    Component([string]$name) : base($name) {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }

    [void] AddChild([UIElement]$child) {
        if (-not $child) { throw [ArgumentNullException]::new("child") }
        if ($child -eq $this) { throw [InvalidOperationException]::new("A component cannot be its own child.") }
        
        $child.Parent = $this
        $this.Children.Add($child)
    }
}

# --- Base Panel (rectangular area) ---
class Panel : Component {
    [int]$X
    [int]$Y
    [int]$Width
    [int]$Height
    [string]$Title = ""
    [bool]$ShowBorder = $true

    Panel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name) {
        if ($width -le 0 -or $height -le 0) { throw [ArgumentOutOfRangeException]::new("Panel dimensions must be positive.") }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
    }

    [hashtable] GetContentArea() {
        $borderOffset = $this.ShowBorder ? 1 : 0
        return @{
            X      = $this.X + $borderOffset
            Y      = $this.Y + $borderOffset
            Width  = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
}

# --- Base Screen (top-level container) ---
class Screen : UIElement {
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[Panel]]$Panels
    hidden [System.Collections.Generic.Dictionary[string, string]]$EventSubscriptions

    Screen([string]$name, [hashtable]$services) : base($name) {
        if (-not $services) { throw [ArgumentNullException]::new("services") }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[Panel]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }
    [void] HandleInput([System.ConsoleKeyInfo]$key) { }

    [void] Cleanup() {
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -SubscriberId $kvp.Value
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event '$($kvp.Key)' for screen '$($this.Name)'."
            }
        }
        $this.EventSubscriptions.Clear()
        $this.Panels.Clear()
        Write-Log -Level Debug -Message "Cleaned up screen: $($this.Name)"
    }
    
    [void] AddPanel([Panel]$panel) {
        if (-not $panel) { throw [ArgumentNullException]::new("panel") }
        $this.Panels.Add($panel)
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [ArgumentException]::new("Event name cannot be null or empty.") }
        if (-not $action) { throw [ArgumentNullException]::new("action") }
        
        $subscriptionId = Subscribe-Event -EventName $eventName -Action $action
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
}


####\layout\panels-class.psm1
# Panel Classes Module for PMC Terminal v5
# Implements specialized panel types for the TUI layout system

using namespace System.Management.Automation
using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# BorderPanel - Panel with customizable border rendering
class BorderPanel : Panel {
    # ... (class content is unchanged) ...
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [string] $BorderStyle = "Single" # Single, Double, Rounded
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    
    hidden static [hashtable] $BorderChars = @{
        Single  = @{ TopLeft='┌'; TopRight='┐'; BottomLeft='└'; BottomRight='┘'; Horizontal='─'; Vertical='│' }
        Double  = @{ TopLeft='╔'; TopRight='╗'; BottomLeft='╚'; BottomRight='╝'; Horizontal='═'; Vertical='║' }
        Rounded = @{ TopLeft='╭'; TopRight='╮'; BottomLeft='╰'; BottomRight='╯'; Horizontal='─'; Vertical='│' }
    }
    
    BorderPanel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name, $x, $y, $width, $height) {}
    
    hidden [string] _RenderContent() {
        if ($this.ShowBorder) {
            return $this.RenderBorder()
        }
        return ""
    }
    
    hidden [string] RenderBorder() {
        $borderBuilder = [System.Text.StringBuilder]::new()
        $chars = [BorderPanel]::BorderChars[$this.BorderStyle] ?? [BorderPanel]::BorderChars["Single"]
        
        [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y)).Append($this.SetColor($this.BorderColor)).Append($chars.TopLeft)
        
        $horizontalSpace = $this.Width - 2
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $titleText = " $($this.Title) "
            if ($titleText.Length -gt $horizontalSpace) { $titleText = $titleText.Substring(0, $horizontalSpace) }
            
            $paddingBefore = [Math]::Floor(($horizontalSpace - $titleText.Length) / 2)
            $paddingAfter = $horizontalSpace - $titleText.Length - $paddingBefore
            
            [void]$borderBuilder.Append($chars.Horizontal * $paddingBefore).Append($this.SetColor($this.TitleColor)).Append($titleText)
            [void]$borderBuilder.Append($this.SetColor($this.BorderColor)).Append($chars.Horizontal * $paddingAfter)
        } else {
            [void]$borderBuilder.Append($chars.Horizontal * $horizontalSpace)
        }
        
        [void]$borderBuilder.Append($chars.TopRight)
        
        for ($row = 1; $row -lt $this.Height - 1; $row++) {
            [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $row)).Append($chars.Vertical)
            [void]$borderBuilder.Append($this.MoveCursor($this.X + $this.Width - 1, $this.Y + $row)).Append($chars.Vertical)
        }
        
        [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $this.Height - 1))
        [void]$borderBuilder.Append($chars.BottomLeft).Append($chars.Horizontal * $horizontalSpace).Append($chars.BottomRight)
        [void]$borderBuilder.Append($this.ResetColor())
        
        return $borderBuilder.ToString()
    }
    
    hidden [string] MoveCursor([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{ Black=30;DarkRed=31;DarkGreen=32;DarkYellow=33;DarkBlue=34;DarkMagenta=35;DarkCyan=36;Gray=37;DarkGray=90;Red=91;Green=92;Yellow=93;Blue=94;Magenta=95;Cyan=96;White=97 }
        return "`e[$($colorMap[$color.ToString()])m"
    }
    
    hidden [string] ResetColor() { return "`e[0m" }
}

class ContentPanel : Panel {
    # ... (class content is unchanged) ...
    [string[]] $Content = @()
    [int] $ScrollOffset = 0
    [ConsoleColor] $TextColor = [ConsoleColor]::White
    [bool] $WordWrap = $true
    
    ContentPanel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name, $x, $y, $width, $height) {}
    
    [void] SetContent([string[]]$content) {
        $this.Content = $content ?? @()
        $this.ScrollOffset = 0
    }
    
    [void] AppendContent([string]$line) {
        if ($null -ne $line) { $this.Content += $line }
    }
    
    [void] ClearContent() {
        $this.Content = @()
        $this.ScrollOffset = 0
    }
    
    [void] ScrollUp([int]$lines = 1) { $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset - $lines) }
    
    [void] ScrollDown([int]$lines = 1) {
        $maxOffset = [Math]::Max(0, $this.Content.Count - $this.GetContentArea().Height)
        $this.ScrollOffset = [Math]::Min($maxOffset, $this.ScrollOffset + $lines)
    }
    
    hidden [string] _RenderContent() {
        $contentBuilder = [System.Text.StringBuilder]::new()
        $contentArea = $this.GetContentArea()
        
        $processedLines = $this.WordWrap ? ($this.Content | ForEach-Object { $this.WrapText($_, $contentArea.Width) }) : $this.Content
        $visibleLinesCount = [Math]::Min($contentArea.Height, $processedLines.Count - $this.ScrollOffset)
        
        for ($i = 0; $i -lt $visibleLinesCount; $i++) {
            $lineIndex = $this.ScrollOffset + $i
            if ($lineIndex -lt $processedLines.Count) {
                $line = $processedLines[$lineIndex]
                if ($line.Length -gt $contentArea.Width) { $line = $line.Substring(0, $contentArea.Width) }
                [void]$contentBuilder.Append($this.MoveCursor($contentArea.X, $contentArea.Y + $i))
                [void]$contentBuilder.Append($this.SetColor($this.TextColor))
                [void]$contentBuilder.Append($line.PadRight($contentArea.Width))
            }
        }
        
        [void]$contentBuilder.Append($this.ResetColor())
        return $contentBuilder.ToString()
    }
    
    hidden [string[]] WrapText([string]$text, [int]$maxWidth) {
        if ([string]::IsNullOrEmpty($text) -or $maxWidth -le 0) { return @("") }
        $lines = [System.Collections.Generic.List[string]]::new()
        $words = $text -split '\s+'
        $currentLine = [System.Text.StringBuilder]::new()
        foreach ($word in $words) {
            if ($currentLine.Length -eq 0) {
                [void]$currentLine.Append($word)
            } elseif (($currentLine.Length + 1 + $word.Length) -le $maxWidth) {
                [void]$currentLine.Append(' ').Append($word)
            } else {
                $lines.Add($currentLine.ToString()); $currentLine.Clear(); [void]$currentLine.Append($word)
            }
        }
        if ($currentLine.Length -gt 0) { $lines.Add($currentLine.ToString()) }
        return $lines.ToArray()
    }

    hidden [string] MoveCursor([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{ Black=30;DarkRed=31;DarkGreen=32;DarkYellow=33;DarkBlue=34;DarkMagenta=35;DarkCyan=36;Gray=37;DarkGray=90;Red=91;Green=92;Yellow=93;Blue=94;Magenta=95;Cyan=96;White=97 }
        return "`e[$($colorMap[$color.ToString()])m"
    }
    hidden [string] ResetColor() { return "`e[0m" }
}
# AI: FIX - Removed '-Class' parameter. No functions are exported, so the entire statement can be removed.


####\modules\data-manager.psm1

# Data Manager Module
# Unified data persistence and CRUD operations with event integration

using module ..\modules\models.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Module-level state variables
$script:Data = @{
    Projects = [System.Collections.Generic.List[PmcProject]]::new()
    Tasks = [System.Collections.Generic.List[PmcTask]]::new()
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    time_entries = @() # underscore format for action compatibility
    timers = @()       # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system, loads data, and returns a service instance.
    #>
    [CmdletBinding()]
    param()
    
    return Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "DataManager initialization" -ScriptBlock {
        $dataDirectory = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDirectory)) {
            New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
            Write-Log -Level Info -Message "Created data directory: $dataDirectory"
        }
        
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
            Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
        }
        
        Load-UnifiedData
        Initialize-DataEventHandlers
        
        Write-Log -Level Info -Message "DataManager initialized successfully"
        return [DataManager]::new()
    }
}

function Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads application data from disk into strongly-typed objects.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading unified data from disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $loadedData = Get-Content -Path $script:DataPath -Raw | ConvertFrom-Json -AsHashtable
                
                if ($loadedData -is [hashtable]) {
                    if ($loadedData.Tasks) {
                        $script:Data.Tasks.Clear()
                        foreach ($taskData in $loadedData.Tasks) {
                            if ($taskData -is [hashtable]) { $script:Data.Tasks.Add([PmcTask]::FromLegacyFormat($taskData)) }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Tasks.Count) tasks as PmcTask objects"
                    }
                    
                    if ($loadedData.Projects -is [hashtable]) {
                        $script:Data.Projects.Clear()
                        foreach ($projectKey in $loadedData.Projects.Keys) {
                            $projectData = $loadedData.Projects[$projectKey]
                            if ($projectData -is [hashtable]) { $script:Data.Projects.Add([PmcProject]::FromLegacyFormat($projectData)) }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Projects.Count) projects as PmcProject objects"
                    }
                    
                    foreach ($key in 'TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers') {
                        if ($loadedData.ContainsKey($key)) { $script:Data[$key] = $loadedData[$key] }
                    }
                    
                    $global:Data = $script:Data
                    Write-Log -Level Info -Message "Data loaded successfully from disk"
                } else {
                    Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    $global:Data = $script:Data
                }
            } catch {
                Write-Log -Level Error -Message "Failed to parse data file: $_"
                $global:Data = $script:Data
            }
        } else {
            Write-Log -Level Info -Message "No existing data file found, using defaults"
            $global:Data = $script:Data
        }
        
        $script:LastSaveTime = Get-Date
    }
}

function Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves application data to disk with backup rotation.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
            Copy-Item -Path $script:DataPath -Destination (Join-Path $script:BackupPath $backupName) -Force
            
            $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | Sort-Object LastWriteTime -Descending
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
            }
        }
        
        $dataToSave = @{
            Tasks = @($script:Data.Tasks | ForEach-Object { $_.ToLegacyFormat() })
            Projects = @{}
            TimeEntries = $script:Data.TimeEntries
            ActiveTimers = $script:Data.ActiveTimers
            TodoTemplates = $script:Data.TodoTemplates
            Settings = $script:Data.Settings
            time_entries = $script:Data.time_entries
            timers = $script:Data.timers
        }
        
        foreach ($project in $script:Data.Projects) { $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat() }
        
        $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
        $script:LastSaveTime = Get-Date; $script:DataModified = $false
        Write-Log -Level Debug -Message "Data saved successfully"
    }
}

#region Task Management Functions

function Add-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [ValidateNotNullOrEmpty()] [string]$Title,
        [string]$Description = "",
        [ValidateSet("low", "medium", "high")] [string]$Priority = "medium",
        [string]$Category = "General",
        [string]$DueDate = ""
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task" -ScriptBlock {
        if ([string]::IsNullOrWhiteSpace($Title)) { throw [StateMutationException]::new("Task title cannot be empty", @{ Title = $Title }) }
        
        $taskPriority = [TaskPriority]::$Priority
        $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $Category)
        
        if ($DueDate -and $DueDate -ne "N/A") {
            try { $newTask.DueDate = [datetime]::Parse($DueDate) } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
        }
        
        $script:Data.Tasks.Add($newTask); $script:DataModified = $true
        Write-Log -Level Info -Message "Created task '$($newTask.Title)' with ID $($newTask.Id)"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Created"; TaskId = $newTask.Id; Task = $newTask }
        return $newTask
    }
}

function Update-PmcTask {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [PmcTask]$Task,
        [string]$Title, [string]$Description, [ValidateSet("low", "medium", "high")] [string]$Priority,
        [string]$Category, [string]$DueDate, [bool]$Completed, [ValidateRange(0, 100)] [int]$Progress
    )
    
    return Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating task" -ScriptBlock {
        $managedTask = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if (-not $managedTask) { throw [StateMutationException]::new("Task not found in data store", @{ TaskId = $Task.Id }) }
        
        $updatedFields = @()
        if ($PSBoundParameters.ContainsKey('Title')) { $managedTask.Title = $Title.Trim(); $updatedFields += "Title" }
        if ($PSBoundParameters.ContainsKey('Description')) { $managedTask.Description = $Description; $updatedFields += "Description" }
        if ($PSBoundParameters.ContainsKey('Priority')) { $managedTask.Priority = [TaskPriority]::$Priority; $updatedFields += "Priority" }
        if ($PSBoundParameters.ContainsKey('Category')) { $managedTask.ProjectKey = $Category; $managedTask.Category = $Category; $updatedFields += "Category" }
        if ($PSBoundParameters.ContainsKey('DueDate')) {
            try { $managedTask.DueDate = ($DueDate -and $DueDate -ne "N/A") ? [datetime]::Parse($DueDate) : $null } catch { Write-Log -Level Warning -Message "Invalid due date format: $DueDate" }
            $updatedFields += "DueDate"
        }
        if ($PSBoundParameters.ContainsKey('Progress')) { $managedTask.UpdateProgress($Progress); $updatedFields += "Progress" }
        if ($PSBoundParameters.ContainsKey('Completed')) {
            if ($Completed) { $managedTask.Complete() } else { $managedTask.Status = [TaskStatus]::Pending; $managedTask.Completed = $false; $managedTask.Progress = 0 }
            $updatedFields += "Completed"
        }
        
        $managedTask.UpdatedAt = [datetime]::Now; $script:DataModified = $true
        Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
        
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        
        Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Updated"; TaskId = $managedTask.Id; Task = $managedTask; UpdatedFields = $updatedFields }
        return $managedTask
    }
}

function Remove-PmcTask {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcTask]$Task)
    
    return Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task" -ScriptBlock {
        $taskToRemove = $script:Data.Tasks.Find({$_.Id -eq $Task.Id})
        if ($taskToRemove) {
            $script:Data.Tasks.Remove($taskToRemove) | Out-Null; $script:DataModified = $true
            Write-Log -Level Info -Message "Deleted task $($Task.Id)"
            if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Deleted"; TaskId = $Task.Id; Task = $Task }
            return $true
        }
        Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"; return $false
    }
}

function Get-PmcTasks {
    [CmdletBinding()]
    param([bool]$Completed, [ValidateSet("low", "medium", "high")] [string]$Priority, [string]$Category)
    
    return Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks" -ScriptBlock {
        $tasks = $script:Data.Tasks
        if ($PSBoundParameters.ContainsKey('Completed')) { $tasks = $tasks | Where-Object { $_.Completed -eq $Completed } }
        if ($Priority) { $priorityEnum = [TaskPriority]::$Priority; $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum } }
        if ($Category) { $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category } }
        return @($tasks)
    }
}

#endregion

#region Project Management Functions

function Get-PmcProjects { [CmdletBinding()] param() return @($script:Data.Projects) }
function Get-PmcProject { [CmdletBinding()] param([Parameter(Mandatory)] [string]$Key) return $script:Data.Projects.Find({$_.Key -eq $Key}) }

function Add-PmcProject {
    [CmdletBinding()]
    param([Parameter(Mandatory)] [PmcProject]$Project)
    
    return Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding project" -ScriptBlock {
        if ($script:Data.Projects.Exists({$_.Key -eq $Project.Key})) { throw [StateMutationException]::new("Project with key '$($Project.Key)' already exists", @{ ProjectKey = $Project.Key }) }
        
        $script:Data.Projects.Add($Project); $script:DataModified = $true
        Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
        if ($script:Data.Settings.AutoSave) { Save-UnifiedData }
        Publish-Event -EventName "Projects.Changed" -Data @{ Action = "Created"; ProjectKey = $Project.Key; Project = $Project }
        return $Project
    }
}

#endregion

#region DataManager Class Definition

class DataManager {
    hidden [hashtable] $DataStore
    hidden [string] $DataFilePath
    hidden [bool] $AutoSaveEnabled = $true
    
    DataManager() {
        $this.DataStore = $script:Data
        $global:Data = $script:Data
        $this.DataFilePath = $script:DataPath
        $this.AutoSaveEnabled = $this.DataStore.Settings.AutoSave
    }

    [void] LoadData() { Load-UnifiedData }
    [void] SaveData() { Save-UnifiedData }
    [PmcTask] AddTask([string]$Title, [string]$Description, [TaskPriority]$Priority, [string]$ProjectKey) { return Add-PmcTask -Title $Title -Description $Description -Priority $Priority.ToString() -Category $ProjectKey }
    [PmcTask[]] GetTasks() { return @($this.DataStore.Tasks) }
    [PmcProject[]] GetProjects() { return @($this.DataStore.Projects) }
}

#endregion

#region Private Helper Functions

function Initialize-DataEventHandlers {
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
        $null = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
            Publish-Event -EventName "Tasks.Changed" -Data @{ Action = "Refreshed"; Tasks = @($script:Data.Tasks) }
        }
        Write-Log -Level Debug -Message "Data event handlers initialized"
    }
}

#endregion

Export-ModuleMember -Function 'Initialize-DataManager', 'Add-PmcTask', 'Update-PmcTask', 'Remove-PmcTask', 'Get-PmcTasks', 'Get-PmcProjects', 'Get-PmcProject', 'Add-PmcProject', 'Save-UnifiedData', 'Load-UnifiedData'



####\modules\dialog-system.psm1
# Dialog System Module
# Uses engine's word wrap helper and respects the framework

$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

#region --- Public API & Factory Functions ---

function Show-TuiDialog {
    <# .SYNOPSIS Internal function to display a dialog component. #>
    param([hashtable]$DialogComponent)
    Invoke-WithErrorHandling -Component "DialogSystem.ShowDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.DialogStack.Push($script:DialogState.CurrentDialog)
        }
        $script:DialogState.CurrentDialog = $DialogComponent
        Request-TuiRefresh
    } -Context "Showing dialog: $($DialogComponent.Title)"
}

function Close-TuiDialog {
    <# .SYNOPSIS Closes the current dialog and restores the previous one, if any. #>
    Invoke-WithErrorHandling -Component "DialogSystem.CloseDialog" -ScriptBlock {
        $script:DialogState.CurrentDialog = ($script:DialogState.DialogStack.Count -gt 0) ? $script:DialogState.DialogStack.Pop() : $null
        Request-TuiRefresh
    } -Context "Closing current dialog"
}

function Show-ConfirmDialog {
    <# .SYNOPSIS Displays a standard Yes/No confirmation dialog. #>
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowConfirmDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("Yes", "No")
            Width         = [Math]::Min(80, [Math]::Max(50, $Message.Length + 10))
            Height        = 10
            OnButtonClick = {
                param($Button, $Index)
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog
                    if ($Index -eq 0) { & $OnConfirm } else { & $OnCancel }
                }
            }
            OnCancel      = { Invoke-WithErrorHandling -Component "ConfirmDialog.OnCancel" -ScriptBlock { Close-TuiDialog; & $OnCancel } }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context "Creating confirm dialog: $Title"
}

function Show-AlertDialog {
    <# .SYNOPSIS Displays a simple alert with an OK button. #>
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowAlertDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("OK")
            Width         = [Math]::Min(80, [Math]::Max(40, $Message.Length + 10))
            Height        = 10
            OnButtonClick = { Invoke-WithErrorHandling -Component "AlertDialog.OnButtonClick" -ScriptBlock { Close-TuiDialog } }
            OnCancel      = { Invoke-WithErrorHandling -Component "AlertDialog.OnCancel" -ScriptBlock { Close-TuiDialog } }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context "Creating alert dialog: $Title"
}

function Show-InputDialog {
    <# .SYNOPSIS Displays a dialog to get text input from the user. #>
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowInputDialog" -ScriptBlock {
        $inputScreen = @{
            Name = "InputDialog"
            State = @{ InputValue = $DefaultValue; FocusedIndex = 0 }
            _focusedIndex = 0
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
                    $dialogWidth = [Math]::Min(70, [Math]::Max(50, $Prompt.Length + 10))
                    $dialogHeight = 10
                    $dialogX = [Math]::Floor(($global:TuiState.BufferWidth - $dialogWidth) / 2)
                    $dialogY = [Math]::Floor(($global:TuiState.BufferHeight - $dialogHeight) / 2)
                    
                    Write-BufferBox -X $dialogX -Y $dialogY -Width $dialogWidth -Height $dialogHeight -Title " $Title " -BorderColor (Get-ThemeColor "Accent")
                    
                    $promptX = $dialogX + 2; $promptY = $dialogY + 2
                    Write-BufferString -X $promptX -Y $promptY -Text $Prompt
                    
                    $inputY = $promptY + 2; $inputWidth = $dialogWidth - 4
                    $isFocused = ($self._focusedIndex -eq 0)
                    $borderColor = $isFocused ? (Get-ThemeColor "Warning") : (Get-ThemeColor "Primary")
                    
                    Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 -BorderColor $borderColor
                    
                    $displayText = $self.State.InputValue
                    if ($displayText.Length -gt ($inputWidth - 3)) { $displayText = $displayText.Substring(0, $inputWidth - 3) }
                    Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText
                    
                    if ($isFocused) {
                        $cursorPos = [Math]::Min($self.State.InputValue.Length, $inputWidth - 3)
                        Write-BufferString -X ($promptX + 1 + $cursorPos) -Y ($inputY + 1) -Text "_" -ForegroundColor (Get-ThemeColor "Warning")
                    }
                    
                    $buttonY = $dialogY + $dialogHeight - 2; $buttonSpacing = 15; $buttonsWidth = $buttonSpacing * 2
                    $buttonX = $dialogX + [Math]::Floor(($dialogWidth - $buttonsWidth) / 2)
                    
                    $okFocused = ($self._focusedIndex -eq 1)
                    $okText = $okFocused ? "[ OK ]" : "  OK  "
                    $okColor = $okFocused ? (Get-ThemeColor "Warning") : (Get-ThemeColor "Primary")
                    Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
                    
                    $cancelFocused = ($self._focusedIndex -eq 2)
                    $cancelText = $cancelFocused ? "[ Cancel ]" : "  Cancel  "
                    $cancelColor = $cancelFocused ? (Get-ThemeColor "Warning") : (Get-ThemeColor "Primary")
                    Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -ScriptBlock {
                    if ($Key.Key -eq [ConsoleKey]::Tab) {
                        $direction = $Key.Modifiers -band [ConsoleModifiers]::Shift ? -1 : 1
                        $self._focusedIndex = ($self._focusedIndex + $direction + 3) % 3
                        Request-TuiRefresh; return $true
                    }
                    if ($Key.Key -eq [ConsoleKey]::Escape) { Close-TuiDialog; Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock { & $OnCancel }; return $true }
                    
                    switch ($self._focusedIndex) {
                        0 { # TextBox
                            switch ($Key.Key) {
                                ([ConsoleKey]::Enter) { Close-TuiDialog; Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock { & $OnSubmit -Value $self.State.InputValue }; return $true }
                                ([ConsoleKey]::Backspace) { if ($self.State.InputValue.Length -gt 0) { $self.State.InputValue = $self.State.InputValue.Substring(0, $self.State.InputValue.Length - 1); Request-TuiRefresh }; return $true }
                                default { if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) { $self.State.InputValue += $Key.KeyChar; Request-TuiRefresh; return $true } }
                            }
                        }
                        1 { # OK Button
                            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) { Close-TuiDialog; Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock { & $OnSubmit -Value $self.State.InputValue }; return $true }
                        }
                        2 { # Cancel Button
                            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) { Close-TuiDialog; Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock { & $OnCancel }; return $true }
                        }
                    }
                    return $false
                }
            }
        }
        $script:DialogState.CurrentDialog = $inputScreen
        Request-TuiRefresh
    } -Context "Creating input dialog: $Title"
}

#endregion

#region --- Engine Integration & Initialization ---

function Initialize-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem.Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler { param($EventData) Invoke-WithErrorHandling -Component "DialogSystem.ConfirmEventHandler" -ScriptBlock { Show-ConfirmDialog @$EventData.Data } }
        Subscribe-Event -EventName "Alert.Show" -Handler { param($EventData) Invoke-WithErrorHandling -Component "DialogSystem.AlertEventHandler" -ScriptBlock { Show-AlertDialog @$EventData.Data } }
        Subscribe-Event -EventName "Input.Request" -Handler { param($EventData) Invoke-WithErrorHandling -Component "DialogSystem.InputEventHandler" -ScriptBlock { Show-InputDialog @$EventData.Data } }
        Write-Verbose "Dialog System initialized and event handlers registered."
    } -Context "Initializing Dialog System"
}

function Render-Dialogs {
    Invoke-WithErrorHandling -Component "DialogSystem.RenderDialogs" -ScriptBlock {
        if ($script:DialogState.CurrentDialog -and $script:DialogState.CurrentDialog.Render) {
            & $script:DialogState.CurrentDialog.Render -self $script:DialogState.CurrentDialog
        }
    } -Context "Rendering current dialog"
}

function Handle-DialogInput {
    param($Key)
    return Invoke-WithErrorHandling -Component "DialogSystem.HandleDialogInput" -ScriptBlock {
        if ($script:DialogState.CurrentDialog -and $script:DialogState.CurrentDialog.HandleInput) {
            return & $script:DialogState.CurrentDialog.HandleInput -self $script:DialogState.CurrentDialog -Key $Key
        }
        return $false
    } -Context "Handling dialog input"
}

function Update-DialogSystem {
    Invoke-WithErrorHandling -Component "DialogSystem.UpdateDialogSystem" -ScriptBlock {
        # Placeholder for periodic updates
    } -Context "Updating dialog system"
}

function New-TuiDialog {
    param([hashtable]$Props = @{})
    
    return @{
        Type = "Dialog"
        Title = $Props.Title ?? "Dialog"
        Message = $Props.Message ?? ""
        Buttons = $Props.Buttons ?? @("OK")
        SelectedButton = 0
        Width = $Props.Width ?? 50
        Height = $Props.Height ?? 10
        X = 0; Y = 0
        OnButtonClick = $Props.OnButtonClick ?? {}
        OnCancel = $Props.OnCancel ?? {}
        
        Render = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                $self.X = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                $self.Y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -Title $self.Title -BorderColor (Get-ThemeColor "Accent")
                
                $messageY = $self.Y + 2; $messageX = $self.X + 2; $maxWidth = $self.Width - 4
                $wrappedLines = Get-WordWrappedLines -Text $self.Message -MaxWidth $maxWidth
                
                foreach ($line in $wrappedLines) {
                    if ($messageY -ge ($self.Y + $self.Height - 3)) { break }
                    Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor (Get-ThemeColor "Primary")
                    $messageY++
                }
                
                $buttonY = $self.Y + $self.Height - 3
                $totalButtonWidth = ($self.Buttons.Count * 12) + (($self.Buttons.Count - 1) * 2)
                $buttonX = $self.X + [Math]::Floor(($self.Width - $totalButtonWidth) / 2)
                
                for ($i = 0; $i -lt $self.Buttons.Count; $i++) {
                    $button = $self.Buttons[$i]
                    $isSelected = ($i -eq $self.SelectedButton)
                    $buttonText = $isSelected ? "[ $($button) ]" : "  $($button)  "
                    $color = $isSelected ? (Get-ThemeColor "Warning") : (Get-ThemeColor "Primary")
                    Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
                    $buttonX += 14
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) { $self.SelectedButton = [Math]::Max(0, $self.SelectedButton - 1); Request-TuiRefresh; return $true }
                    ([ConsoleKey]::RightArrow) { $self.SelectedButton = [Math]::Min($self.Buttons.Count - 1, $self.SelectedButton + 1); Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Tab) { $self.SelectedButton = ($self.SelectedButton + 1) % $self.Buttons.Count; Request-TuiRefresh; return $true }
                    ([ConsoleKey]::Enter) { & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton; return $true }
                    ([ConsoleKey]::Spacebar) { & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton; return $true }
                    ([ConsoleKey]::Escape) { & $self.OnCancel; return $true }
                }
                return $false
            }
        }
    }
}

function Show-ProgressDialog {
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowProgressDialog" -ScriptBlock {
        $dialog = @{
            Type = "ProgressDialog"; Title = $Title; Message = $Message; PercentComplete = $PercentComplete
            Width = 60; Height = 8; ShowCancel = $ShowCancel; IsCancelled = $false
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2); $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Message
                    
                    $barY = $y + 4; $barWidth = $self.Width - 4; $filledWidth = [Math]::Floor($barWidth * ($self.PercentComplete / 100))
                    Write-BufferString -X ($x + 2) -Y $barY -Text ("─" * $barWidth) -ForegroundColor (Get-ThemeColor "Border")
                    if ($filledWidth -gt 0) { Write-BufferString -X ($x + 2) -Y $barY -Text ("█" * $filledWidth) -ForegroundColor (Get-ThemeColor "Success") }
                    
                    $percentText = "$($self.PercentComplete)%"; $percentX = $x + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $percentX -Y $barY -Text $percentText
                    
                    if ($self.ShowCancel) {
                        $buttonY = $y + $self.Height - 2; $buttonText = $self.IsCancelled ? "[ Cancelling... ]" : "[ Cancel ]"
                        $buttonX = $x + [Math]::Floor(($self.Width - $buttonText.Length) / 2)
                        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor (Get-ThemeColor "Warning")
                    }
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    if ($self.ShowCancel -and -not $self.IsCancelled -and $Key.Key -in @([ConsoleKey]::Escape, [ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                        $self.IsCancelled = $true; Request-TuiRefresh; return $true
                    }
                    return $false
                }
            }
            
            UpdateProgress = {
                param($self, [int]$PercentComplete, [string]$Message = $null)
                Invoke-WithErrorHandling -Component "$($self.Type).UpdateProgress" -ScriptBlock {
                    $self.PercentComplete = [Math]::Min(100, [Math]::Max(0, $PercentComplete))
                    if ($Message) { $self.Message = $Message }
                    Request-TuiRefresh
                }
            }
        }
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
        return $dialog
    } -Context "Creating progress dialog: $Title"
}

function Show-ListDialog {
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [array]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowListDialog" -ScriptBlock {
        $dialog = @{
            Type = "ListDialog"; Title = $Title; Prompt = $Prompt; Items = $Items; SelectedIndex = 0; SelectedItems = @()
            Width = 60; Height = [Math]::Min(20, $Items.Count + 8); AllowMultiple = $AllowMultiple
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2); $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Prompt
                    
                    $listY = $y + 4; $listHeight = $self.Height - 7; $listWidth = $self.Width - 4
                    $startIndex = [Math]::Max(0, $self.SelectedIndex - [Math]::Floor($listHeight / 2))
                    $endIndex = [Math]::Min($self.Items.Count - 1, $startIndex + $listHeight - 1)
                    
                    for ($i = $startIndex; $i -le $endIndex; $i++) {
                        $itemY = $listY + ($i - $startIndex); $item = $self.Items[$i]
                        $isSelected = ($i -eq $self.SelectedIndex); $isChecked = $self.SelectedItems -contains $i
                        $prefix = $self.AllowMultiple ? ($isChecked ? "[X] " : "[ ] ") : ""
                        $itemText = "$prefix$item"
                        if ($itemText.Length -gt $listWidth - 2) { $itemText = $itemText.Substring(0, $listWidth - 5) + "..." }
                        
                        $bgColor = $isSelected ? (Get-ThemeColor "Selection") : $null
                        $fgColor = $isSelected ? (Get-ThemeColor "Background") : (Get-ThemeColor "Primary")
                        Write-BufferString -X ($x + 2) -Y $itemY -Text $itemText -ForegroundColor $fgColor -BackgroundColor $bgColor
                    }
                    
                    if ($self.Items.Count -gt $listHeight) {
                        $scrollbarX = $x + $self.Width - 2; $scrollbarHeight = $listHeight
                        $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $self.Items.Count))
                        $thumbPos = [Math]::Floor($scrollbarHeight * $self.SelectedIndex / $self.Items.Count)
                        for ($i = 0; $i -lt $scrollbarHeight; $i++) { $char = ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) ? "█" : "│"; Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char -ForegroundColor (Get-ThemeColor "Border") }
                    }
                    
                    if ($self.AllowMultiple) {
                        $buttonY = $y + $self.Height - 2; $okText = "[ OK ]"; $cancelText = "[ Cancel ]"; $buttonSpacing = 15; $totalWidth = 30; $startX = $x + [Math]::Floor(($self.Width - $totalWidth) / 2)
                        Write-BufferString -X $startX -Y $buttonY -Text $okText -ForegroundColor (Get-ThemeColor "Success")
                        Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor (Get-ThemeColor "Primary")
                    }
                }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) { $self.SelectedIndex = [Math]::Max(0, $self.SelectedIndex - 1); Request-TuiRefresh; return $true }
                        ([ConsoleKey]::DownArrow) { $self.SelectedIndex = [Math]::Min($self.Items.Count - 1, $self.SelectedIndex + 1); Request-TuiRefresh; return $true }
                        ([ConsoleKey]::Spacebar) { if ($self.AllowMultiple) { if ($self.SelectedItems -contains $self.SelectedIndex) { $self.SelectedItems = $self.SelectedItems | Where-Object { $_ -ne $self.SelectedIndex } } else { $self.SelectedItems += $self.SelectedIndex }; Request-TuiRefresh; return $true } }
                        ([ConsoleKey]::Enter) {
                            Close-TuiDialog
                            if ($self.AllowMultiple) { $selectedValues = $self.SelectedItems | ForEach-Object { $self.Items[$_] }; & $OnSelect -Selected $selectedValues } 
                            else { & $OnSelect -Selected $self.Items[$self.SelectedIndex] }
                            return $true
                        }
                        ([ConsoleKey]::Escape) { Close-TuiDialog; & $OnCancel; return $true }
                    }
                    return $false
                }
            }
        }
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
    } -Context "Creating list dialog: $Title"
}

#endregion

Export-ModuleMember -Function 'Initialize-DialogSystem', 'Show-TuiDialog', 'Close-TuiDialog', 'Show-ConfirmDialog', 'Show-AlertDialog', 'Show-InputDialog', 'Show-ProgressDialog', 'Show-ListDialog', 'Render-Dialogs', 'Handle-DialogInput', 'Update-DialogSystem', 'New-TuiDialog'



####\modules\event-system.psm1
# Event System Module
# Provides pub/sub event functionality for decoupled communication

$script:EventHandlers = @{}
$script:EventHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxEventHistory = 100

function Initialize-EventSystem {
    <# .SYNOPSIS Initializes the event system for the application #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -Context "Initializing event system" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = [System.Collections.Generic.List[object]]::new()
        Write-Verbose "Event system initialized"
    }
}

function Publish-Event {
    <#
    .SYNOPSIS Publishes an event to all registered handlers
    .PARAMETER EventName The name of the event to publish
    .PARAMETER Data Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter()] [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -Context "Publishing event '$EventName'" -ScriptBlock {
        $eventRecord = @{ EventName = $EventName; Data = $Data; Timestamp = Get-Date }
        
        $script:EventHistory.Add($eventRecord)
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) { $script:EventHistory.RemoveAt(0) }
        
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try {
                    $eventData = @{ EventName = $EventName; Data = $Data; Timestamp = $eventRecord.Timestamp }
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (ID: $($handler.HandlerId)): $_"
                }
            }
        }
        Write-Verbose "Published event: $EventName"
    } -AdditionalData @{ EventName = $EventName; EventData = $Data }
}

function Subscribe-Event {
    <#
    .SYNOPSIS Subscribes to an event with a handler
    .PARAMETER EventName The name of the event to subscribe to
    .PARAMETER Handler The script block to execute
    .PARAMETER HandlerId Optional unique identifier for the handler
    .PARAMETER Source Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory)] [string]$EventName,
        [Parameter(Mandatory)] [scriptblock]$Handler,
        [Parameter()] [string]$HandlerId = [Guid]::NewGuid().ToString(),
        [Parameter()] [string]$Source
    )
    return Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -Context "Subscribing to event '$EventName'" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers[$EventName] = @() }
        
        $handlerInfo = @{ HandlerId = $HandlerId; ScriptBlock = $Handler; SubscribedAt = Get-Date; Source = $Source }
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        return $HandlerId
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source }
}

function Unsubscribe-Event {
    <#
    .SYNOPSIS Unsubscribes from an event
    .PARAMETER EventName The name of the event (optional if HandlerId is provided)
    .PARAMETER HandlerId The unique identifier of the handler to remove
    #>
    param(
        [Parameter()] [string]$EventName,
        [Parameter(Mandatory)] [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -Context "Unsubscribing from event '$EventName' (Handler: $HandlerId)" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($script:EventHandlers[$EventName].Count -eq 0) { $script:EventHandlers.Remove($EventName) }
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    $script:EventHandlers[$eventKey] = if ($newHandlers.Count -eq 0) { $script:EventHandlers.Remove($eventKey) } else { $newHandlers }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"; break
                }
            }
            if (-not $found) { Write-Warning "Handler ID not found: $HandlerId" }
        }
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId }
}

function Get-EventHandlers {
    <# .SYNOPSIS Gets all registered event handlers #>
    param([Parameter()] [string]$EventName)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -Context "Getting event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { return $script:EventHandlers[$EventName] ?? @() }
        else { return $script:EventHandlers }
    }
}

function Clear-EventHandlers {
    <# .SYNOPSIS Clears all event handlers for a specific event or all events #>
    param([Parameter()] [string]$EventName)
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -Context "Clearing event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) { if ($script:EventHandlers.ContainsKey($EventName)) { $script:EventHandlers.Remove($EventName); Write-Verbose "Cleared handlers for event: $EventName" } } 
        else { $script:EventHandlers = @{}; Write-Verbose "Cleared all event handlers" }
    }
}

function Get-EventHistory {
    <# .SYNOPSIS Gets the event history #>
    param([Parameter()] [string]$EventName, [Parameter()] [int]$Last = 0)
    return Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -Context "Getting event history for '$EventName'" -ScriptBlock {
        $history = $script:EventHistory
        if ($EventName) { $history = $history | Where-Object { $_.EventName -eq $EventName } }
        if ($Last -gt 0) { $history = $history | Select-Object -Last $Last }
        return $history
    }
}

function Remove-ComponentEventHandlers {
    <# .SYNOPSIS Removes all event handlers associated with a specific component #>
    param([Parameter(Mandatory)] [string]$ComponentId)
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -Context "Removing event handlers for component '$ComponentId'" -ScriptBlock {
        $removedCount = 0
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $initialCount = $script:EventHandlers[$eventName].Count
            $script:EventHandlers[$eventName] = @($script:EventHandlers[$eventName] | Where-Object { $_.Source -ne $ComponentId })
            $removedCount += $initialCount - $script:EventHandlers[$eventName].Count
            if ($script:EventHandlers[$eventName].Count -eq 0) { $script:EventHandlers.Remove($eventName) }
        }
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    }
}

Export-ModuleMember -Function 'Initialize-EventSystem', 'Publish-Event', 'Subscribe-Event', 'Unsubscribe-Event', 'Get-EventHandlers', 'Clear-EventHandlers', 'Get-EventHistory', 'Remove-ComponentEventHandlers'


####\modules\exceptions.psm1

# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

try {
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException) {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
    }
} catch {
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

function _Identify-HeliosComponent {
    param([System.Management.Automation.ErrorRecord]$ErrorRecord)
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName ?? (Get-PSCallStack | Where-Object ScriptName | Select-Object -First 1).ScriptName
        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        $componentMap = @{
            'tui-engine' = 'TUI Engine'; 'navigation' = 'Navigation Service'; 'keybindings' = 'Keybinding Service'
            'task-service' = 'Task Service'; 'helios-components' = 'Helios UI Components'; 'helios-panels' = 'Helios UI Panels'
            'dashboard-screen' = 'Dashboard Screen'; 'task-screen' = 'Task Screen'; 'exceptions' = 'Exception Module'
            'logger' = 'Logger Module'; 'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") { return $componentMap[$pattern] }
        }
        return "Unknown ($fileName)"
    } catch { return "Component Identification Failed" }
}

function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp = Get-Date -Format "o"; Summary = $ErrorRecord.Exception.Message; Type = $ErrorRecord.Exception.GetType().FullName
            Category = $ErrorRecord.CategoryInfo.Category.ToString(); TargetObject = $ErrorRecord.TargetObject
            ScriptName = $ErrorRecord.InvocationInfo.ScriptName; LineNumber = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line = $ErrorRecord.InvocationInfo.Line; PositionMessage = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace = $ErrorRecord.Exception.StackTrace; InnerExceptions = @(); AdditionalContext = $AdditionalContext
            SystemContext = @{
                ProcessId = $PID; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{ Message = $innerEx.Message; Type = $innerEx.GetType().FullName; StackTrace = $innerEx.StackTrace }
            $innerEx = $innerEx.InnerException
        }
        return $errorInfo
    } catch {
        return [PSCustomObject]@{ Timestamp = Get-Date -Format "o"; Summary = "CRITICAL: Error analysis failed."; OriginalError = $ErrorRecord.Exception.Message; AnalysisError = $_.Exception.Message; Type = "ErrorAnalysisFailure" }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)] [string]$Component,
        [Parameter(Mandatory)] [string]$Context,
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [hashtable]$AdditionalData = @{}
    )

    if (-not $ScriptBlock) { throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null." }
    $Component = [string]::IsNullOrWhiteSpace($Component) ? "Unknown Component" : $Component
    $Context = [string]::IsNullOrWhiteSpace($Context) ? "Unknown Operation" : $Context

    try {
        return (& $ScriptBlock)
    }
    catch {
        $originalErrorRecord = $_
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = ($Component -ne "Unknown Component") ? $Component : $identifiedComponent

        $errorContext = @{ Operation = $Context }
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) { $script:ErrorHistory.RemoveAt(0) }

        $contextHashtable = @{
            Operation = $Context; Timestamp = $detailedError.Timestamp; LineNumber = $detailedError.LineNumber
            ScriptName = $detailedError.ScriptName ?? "Unknown"
        }
        
        foreach ($key in $AdditionalData.Keys) {
            $value = $AdditionalData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) { $contextHashtable[$key] = $value }
        }
        
        $heliosException = New-Object Helios.HeliosException($originalErrorRecord.Exception.Message, $finalComponent, $contextHashtable, $originalErrorRecord.Exception)
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param([int]$Count = 25)
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) { return $script:ErrorHistory }
    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}

Export-ModuleMember -Function 'Invoke-WithErrorHandling', 'Get-ErrorHistory'


####\modules\logger.psm1

# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------
$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------
function ConvertTo-SerializableObject {
    param([object]$Object)
    if ($null -eq $Object) { return $null }
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'
    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)
        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) { [void]$visited.Add($InputObject) }
        switch ($InputObject.GetType().Name) {
            'Hashtable' { $r = @{}; foreach ($k in $InputObject.Keys) { try { $r[$k] = Convert-Internal $InputObject[$k] ($Depth+1) } catch { $r[$k] = "<Err>" } }; return $r }
            'PSCustomObject' { $r = @{}; foreach ($p in $InputObject.PSObject.Properties) { try { if ($p.MemberType -ne 'ScriptMethod') { $r[$p.Name] = Convert-Internal $p.Value ($Depth+1) } } catch { $r[$p.Name] = "<Err>" } }; return $r }
            'Object[]' { $r = @(); for ($i=0; $i -lt [Math]::Min($InputObject.Count,10); $i++) { try { $r += Convert-Internal $InputObject[$i] ($Depth+1) } catch { $r += "<Err>" } }; if($InputObject.Count -gt 10) { $r += "<...>" }; return $r }
            default { try { if ($InputObject -is [ValueType] -or $InputObject -is [string] -or $InputObject -is [datetime]) { return $InputObject } else { return $InputObject.ToString() } } catch { return "<Err>" } }
        }
    }
    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------
function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )
    if ([string]::IsNullOrWhiteSpace($LogDirectory) -or [string]::IsNullOrWhiteSpace($LogFileName)) { Write-Warning "Invalid logger parameters."; return }
    try {
        if (-not (Test-Path $LogDirectory)) { New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null }
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        Write-Log -Level Info -Message "Logger initialized" -Data @{ LogPath = $script:LogPath; PowerShellVersion = $PSVersionTable.PSVersion.ToString(); OS = $PSVersionTable.OS; PID = $PID } -Force
    } catch { Write-Warning "Failed to initialize logger: $_"; $script:LogInitialized = $false }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")] [string]$Level = "Info",
        [Parameter(Mandatory)] [string]$Message,
        [object]$Data,
        [switch]$Force
    )
    if (-not $script:LogInitialized -and -not $Force) { return }
    $levelPriority = @{ Debug=0; Trace=0; Verbose=1; Info=2; Warning=3; Error=4; Fatal=5 }
    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    try {
        $caller = (Get-PSCallStack)[1]
        $logContext = @{
            Timestamp = (Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"); Level = $Level; ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
            CallDepth = $script:CallDepth; Message = $Message; Caller = @{ Command = $caller.Command; Location = $caller.Location; ScriptName = $caller.ScriptName; LineNumber = $caller.ScriptLineNumber }
        }
        if ($PSBoundParameters.ContainsKey('Data')) { $logContext.UserData = if ($Data -is [Exception]) { @{ Type="Exception"; Message=$Data.Message; StackTrace=$Data.StackTrace; InnerException=$Data.InnerException.Message } } else { ConvertTo-SerializableObject -Object $Data } }
        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) { "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)" } else { $caller.Command }
        $logEntry = "$($logContext.Timestamp) [$($Level.PadRight(7))] $indent [$callerInfo] $Message"
        if ($PSBoundParameters.ContainsKey('Data')) { $logEntry += if ($Data -is [Exception]) { "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)" } else { try { "`n${indent}  Data: $(ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue)" } catch { "`n${indent}  Data: $($Data.ToString())" } } }
        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) { $script:LogQueue.RemoveRange(0, 1000) }
        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) { Move-Item $script:LogPath ($script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log") -Force }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch { Write-Host "LOG WRITE FAILED: $logEntry`nError: $_" -ForegroundColor Yellow }
        }
        if ($Level -in @('Error', 'Fatal', 'Warning')) { Write-Host $logEntry -ForegroundColor ($Level -in @('Error', 'Fatal') ? 'Red' : 'Yellow') }
    } catch { try { $errorEntry = "$(Get-Date -Format 'o') [LOGGER ERROR] Failed to log: $_"; if ($script:LogPath) { Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8 }; Write-Host $errorEntry -ForegroundColor Red } catch { Write-Host "CRITICAL: Logger failed: $_" -ForegroundColor Red } }
}

function Trace-FunctionEntry { [CmdletBinding()] param([string]$FunctionName, [object]$Parameters); if (-not $script:TraceAllCalls) { return }; $script:CallDepth++; Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{ Parameters=$Parameters; Action="FunctionEntry" } }
function Trace-FunctionExit { [CmdletBinding()] param([string]$FunctionName, [object]$ReturnValue, [switch]$WithError); if (-not $script:TraceAllCalls) { return }; Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{ ReturnValue=$ReturnValue; Action=($WithError ? "FunctionExitWithError" : "FunctionExit"); HasError=$WithError.IsPresent }; $script:CallDepth = [Math]::Max(0, $script:CallDepth - 1) }
function Trace-Step { [CmdletBinding()] param([string]$StepName, [object]$StepData, [string]$Module); $caller = (Get-PSCallStack)[1]; $moduleInfo = $Module ?? ($caller.ScriptName ? [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) : "Unknown"); Write-Log -Level Debug -Message "STEP: $StepName" -Data @{ StepData=$StepData; Module=$moduleInfo; Action="Step" } }
function Trace-StateChange { [CmdletBinding()] param([string]$StateType, [object]$OldValue, [object]$NewValue, [string]$PropertyPath); Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{ StateType=$StateType; PropertyPath=$PropertyPath; OldValue=$OldValue; NewValue=$NewValue; Action="StateChange" } }
function Trace-ComponentLifecycle { [CmdletBinding()] param([string]$ComponentType, [string]$ComponentId, [ValidateSet('Create','Initialize','Render','Update','Destroy')] [string]$Phase, [object]$ComponentData); Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{ ComponentType=$ComponentType; ComponentId=$ComponentId; Phase=$Phase; ComponentData=$ComponentData; Action="ComponentLifecycle" } }
function Trace-ServiceCall { [CmdletBinding()] param([string]$ServiceName, [string]$MethodName, [object]$Parameters, [object]$Result, [switch]$IsError); Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{ ServiceName=$ServiceName; MethodName=$MethodName; Parameters=$Parameters; Result=$Result; Action=($IsError ? "ServiceCallError" : "ServiceCall"); IsError=$IsError.IsPresent } }

function Get-LogEntries {
    [CmdletBinding()]
    param([int]$Count = 100, [string]$Level, [string]$Module, [string]$Action)
    try {
        $entries = $script:LogQueue.ToArray()
        if ($Level) { $entries = $entries | Where-Object { $_.Level -eq $Level } }
        if ($Module) { $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") } }
        if ($Action) { $entries = $entries | Where-Object { $_.UserData.Action -eq $Action } }
        return $entries | Select-Object -Last $Count
    } catch { Write-Warning "Error getting log entries: $_"; return @() }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)
    try {
        $callStack = Get-PSCallStack; $trace = @()
        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { $call = $callStack[$i]; $trace += @{ Level=$i-1; Command=$call.Command; Location=$call.Location; ScriptName=$call.ScriptName; LineNumber=$call.ScriptLineNumber } }
        return $trace
    } catch { Write-Warning "Error getting call trace: $_"; return @() }
}

function Clear-LogQueue { try { $script:LogQueue.Clear(); Write-Log -Level Info -Message "In-memory log queue cleared" } catch { Write-Warning "Error clearing log queue: $_" } }
function Set-LogLevel { [CmdletBinding()] param([Parameter(Mandatory)] [ValidateSet("Debug","Verbose","Info","Warning","Error","Fatal","Trace")] [string]$Level); try { $oldLevel = $script:LogLevel; $script:LogLevel = $Level; Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force } catch { Write-Warning "Error setting log level to '$Level': $_" } }
function Enable-CallTracing { $script:TraceAllCalls = $true; Write-Log -Level Info -Message "Call tracing enabled" -Force }
function Disable-CallTracing { $script:TraceAllCalls = $false; Write-Log -Level Info -Message "Call tracing disabled" -Force }
function Get-LogPath { return $script:LogPath }

function Get-LogStatistics {
    [CmdletBinding()]
    param()
    try {
        $stats = [PSCustomObject]@{ TotalEntries=$script:LogQueue.Count; LogPath=$script:LogPath; LogLevel=$script:LogLevel; CallTracingEnabled=$script:TraceAllCalls; LogFileSize=($script:LogPath -and (Test-Path $script:LogPath) ? (Get-Item $script:LogPath).Length : 0); EntriesByLevel=@{}; EntriesByModule=@{}; EntriesByAction=@{} }
        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level; if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level]=0 }; $stats.EntriesByLevel[$level]++
            if ($entry.Caller.ScriptName) { $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName); if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module]=0 }; $stats.EntriesByModule[$module]++ }
            if ($entry.UserData.Action) { $action = $entry.UserData.Action; if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action]=0 }; $stats.EntriesByAction[$action]++ }
        }
        return $stats
    } catch { Write-Warning "Error getting log statistics: $_"; return [PSCustomObject]@{} }
}

Export-ModuleMember -Function 'Initialize-Logger', 'Write-Log', 'Trace-FunctionEntry', 'Trace-FunctionExit', 'Trace-Step', 'Trace-StateChange', 'Trace-ComponentLifecycle', 'Trace-ServiceCall', 'Get-LogEntries', 'Get-CallTrace', 'Clear-LogQueue', 'Set-LogLevel', 'Enable-CallTracing', 'Disable-CallTracing', 'Get-LogPath', 'Get-LogStatistics'



####\modules\models.psm1
# ==============================================================================
# PMC Terminal v5 - Core Data Models
# Defines all core business entity classes with built-in validation.
# ==============================================================================

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Enums

enum TaskStatus { Pending; InProgress; Completed; Cancelled }
enum TaskPriority { Low; Medium; High }
enum BillingType { Billable; NonBillable }

#endregion

#region Base Validation Class
class ValidationBase {
    static [void] ValidateNotEmpty([string]$value, [string]$parameterName) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("Parameter '$($parameterName)' cannot be null or empty.")
        }
    }
}
#endregion

#region Core Model Classes

class PmcTask : ValidationBase {
    [string]$Id = [Guid]::NewGuid().ToString()
    [string]$Title
    [string]$Description
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [string]$ProjectKey = "General"
    [string]$Category
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now
    [Nullable[datetime]]$DueDate
    [string[]]$Tags = @()
    [int]$Progress = 0
    [bool]$Completed = $false

    PmcTask() {}
    PmcTask([string]$title) { [ValidationBase]::ValidateNotEmpty($title, "Title"); $this.Title = $title }
    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title; $this.Description = $description; $this.Priority = $priority
        $this.ProjectKey = $projectKey; $this.Category = $projectKey
    }

    [void] Complete() {
        $this.Status = [TaskStatus]::Completed; $this.Completed = $true
        $this.Progress = 100; $this.UpdatedAt = [datetime]::Now
    }

    [void] UpdateProgress([int]$newProgress) {
        if ($newProgress -lt 0 -or $newProgress -gt 100) { throw "Progress must be between 0 and 100." }
        $this.Progress = $newProgress
        $this.Status = $newProgress -eq 100 ? [TaskStatus]::Completed : $newProgress -gt 0 ? [TaskStatus]::InProgress : [TaskStatus]::Pending
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() { return $this.DueDate ? $this.DueDate.Value.ToString("yyyy-MM-dd") : "N/A" }

    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id; title = $this.Title; description = $this.Description
            completed = $this.Completed; priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey; due_date = $this.DueDate ? $this.GetDueDateString() : $null
            created_at = $this.CreatedAt.ToString("o"); updated_at = $this.UpdatedAt.ToString("o")
        }
    }

    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        $task.Id = $legacyData.id ?? $task.Id
        $task.Title = $legacyData.title
        $task.Description = $legacyData.description
        if ($legacyData.priority) { try { $task.Priority = [TaskPriority]::$($legacyData.priority) } catch {} }
        $task.ProjectKey = $legacyData.project ?? $legacyData.Category ?? "General"
        $task.Category = $task.ProjectKey
        if ($legacyData.created_at) { try { $task.CreatedAt = [datetime]::Parse($legacyData.created_at) } catch {} }
        if ($legacyData.updated_at) { try { $task.UpdatedAt = [datetime]::Parse($legacyData.updated_at) } catch {} }
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") { try { $task.DueDate = [datetime]::Parse($legacyData.due_date) } catch {} }
        if ($legacyData.completed -is [bool] -and $legacyData.completed) { $task.Complete() }
        return $task
    }
}

class PmcProject : ValidationBase {
    [string]$Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper()
    [string]$Name
    [string]$Client
    [BillingType]$BillingType = [BillingType]::NonBillable
    [double]$Rate = 0.0
    [double]$Budget = 0.0
    [bool]$Active = $true
    [datetime]$CreatedAt = [datetime]::Now
    [datetime]$UpdatedAt = [datetime]::Now

    PmcProject() {}
    PmcProject([string]$key, [string]$name) {
        [ValidationBase]::ValidateNotEmpty($key, "Key"); [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key; $this.Name = $name
    }

    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key; Name = $this.Name; Client = $this.Client
            BillingType = $this.BillingType.ToString(); Rate = $this.Rate; Budget = $this.Budget
            Active = $this.Active; CreatedAt = $this.CreatedAt.ToString("o")
        }
    }

    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        $project.Key = $legacyData.Key ?? $project.Key
        $project.Name = $legacyData.Name
        $project.Client = $legacyData.Client
        if ($legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($legacyData.Active -is [bool]) { $project.Active = $legacyData.Active }
        if ($legacyData.BillingType) { try { $project.BillingType = [BillingType]::$($legacyData.BillingType) } catch {} }
        if ($legacyData.CreatedAt) { try { $project.CreatedAt = [datetime]::Parse($legacyData.CreatedAt) } catch {} }
        $project.UpdatedAt = $project.CreatedAt
        return $project
    }
}

#endregion

# AI: Export everything including enums for PowerShell 7+
Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\modules\theme-manager.psm1
# FILE: modules/theme-manager.psm1
# PURPOSE: Provides theming and color management for the TUI.
#

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{ Name="Modern"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::White; Primary=[ConsoleColor]::White; Secondary=[ConsoleColor]::Gray; Accent=[ConsoleColor]::Cyan; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Cyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::DarkGray } }
    Dark   = @{ Name="Dark"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Gray; Primary=[ConsoleColor]::Gray; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::DarkCyan; Success=[ConsoleColor]::DarkGreen; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::DarkRed; Info=[ConsoleColor]::DarkBlue; Header=[ConsoleColor]::DarkCyan; Border=[ConsoleColor]::DarkGray; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::Cyan; Subtle=[ConsoleColor]::DarkGray; Keyword=[ConsoleColor]::DarkBlue; String=[ConsoleColor]::DarkGreen; Number=[ConsoleColor]::DarkMagenta; Comment=[ConsoleColor]::DarkGray } }
    Light  = @{ Name="Light"; Colors=@{ Background=[ConsoleColor]::White; Foreground=[ConsoleColor]::Black; Primary=[ConsoleColor]::Black; Secondary=[ConsoleColor]::DarkGray; Accent=[ConsoleColor]::Blue; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::DarkYellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Blue; Header=[ConsoleColor]::Blue; Border=[ConsoleColor]::Gray; Selection=[ConsoleColor]::Cyan; Highlight=[ConsoleColor]::Yellow; Subtle=[ConsoleColor]::Gray; Keyword=[ConsoleColor]::Blue; String=[ConsoleColor]::Green; Number=[ConsoleColor]::Magenta; Comment=[ConsoleColor]::Gray } }
    Retro  = @{ Name="Retro"; Colors=@{ Background=[ConsoleColor]::Black; Foreground=[ConsoleColor]::Green; Primary=[ConsoleColor]::Green; Secondary=[ConsoleColor]::DarkGreen; Accent=[ConsoleColor]::Yellow; Success=[ConsoleColor]::Green; Warning=[ConsoleColor]::Yellow; Error=[ConsoleColor]::Red; Info=[ConsoleColor]::Cyan; Header=[ConsoleColor]::Yellow; Border=[ConsoleColor]::DarkGreen; Selection=[ConsoleColor]::Yellow; Highlight=[ConsoleColor]::White; Subtle=[ConsoleColor]::DarkGreen; Keyword=[ConsoleColor]::Yellow; String=[ConsoleColor]::Cyan; Number=[ConsoleColor]::White; Comment=[ConsoleColor]::DarkGreen } }
}

function Initialize-ThemeManager {
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -Context "Initializing theme service" -ScriptBlock {
        Set-TuiTheme -ThemeName "Modern"
        Write-Log -Level Info -Message "Theme manager initialized."
    }
}

function Set-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName)
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -Context "Setting active TUI theme" -AdditionalData @{ ThemeName = $ThemeName } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            if ($Host.UI.RawUI) {
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            Write-Log -Level Debug -Message "Theme set to: $ThemeName"
            Publish-Event -EventName "Theme.Changed" -Data @{ ThemeName = $ThemeName; Theme = $script:CurrentTheme }
        } else {
            Write-Log -Level Warning -Message "Theme not found: $ThemeName"
        }
    }
}

function Get-ThemeColor {
    param([Parameter(Mandatory)] [string]$ColorName, [ConsoleColor]$Default = [ConsoleColor]::Gray)
    try {
        return $script:CurrentTheme.Colors[$ColorName] ?? $Default
    } catch {
        Write-Log -Level Warning -Message "Error in Get-ThemeColor for '$ColorName'. Returning default. Error: $_"
        return $Default
    }
}

function Get-TuiTheme {
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -Context "Retrieving current theme" -ScriptBlock {
        return $script:CurrentTheme
    }
}

function Get-AvailableThemes {
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -Context "Retrieving available themes" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    }
}

function New-TuiTheme {
    param([Parameter(Mandatory)] [string]$Name, [string]$BaseTheme = "Modern", [hashtable]$Colors = @{})
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -Context "Creating new theme" -AdditionalData @{ ThemeName = $Name } -ScriptBlock {
        $newTheme = @{ Name = $Name; Colors = @{} }
        if ($script:Themes.ContainsKey($BaseTheme)) { $newTheme.Colors = $script:Themes[$BaseTheme].Colors.Clone() }
        foreach ($colorKey in $Colors.Keys) { $newTheme.Colors[$colorKey] = $Colors[$colorKey] }
        $script:Themes[$Name] = $newTheme
        Write-Log -Level Info -Message "Created new theme: $Name"
        return $newTheme
    }
}

function Export-TuiTheme {
    param([Parameter(Mandatory)] [string]$ThemeName, [Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -Context "Exporting theme to JSON" -AdditionalData @{ ThemeName = $ThemeName; FilePath = $Path } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            $exportTheme = @{ Name = $theme.Name; Colors = @{} }
            foreach ($colorKey in $theme.Colors.Keys) { $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString() }
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            Write-Log -Level Info -Message "Exported theme '$ThemeName' to: $Path"
        } else {
            Write-Log -Level Warning -Message "Cannot export theme. Theme not found: $ThemeName"
        }
    }
}

function Import-TuiTheme {
    param([Parameter(Mandatory)] [string]$Path)
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -Context "Importing theme from JSON" -AdditionalData @{ FilePath = $Path } -ScriptBlock {
        if (Test-Path $Path) {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $theme = @{ Name = $importedTheme.Name; Colors = @{} }
            foreach ($colorKey in $importedTheme.Colors.Keys) {
                $theme.Colors[$colorKey] = [System.Enum]::Parse([System.ConsoleColor], $importedTheme.Colors[$colorKey], $true)
            }
            $script:Themes[$theme.Name] = $theme
            Write-Log -Level Info -Message "Imported theme: $($theme.Name)"
            return $theme
        } else {
            Write-Log -Level Warning -Message "Cannot import theme. File not found: $Path"
            return $null
        }
    }
}

Export-ModuleMember -Function 'Initialize-ThemeManager', 'Set-TuiTheme', 'Get-ThemeColor', 'Get-TuiTheme', 'Get-AvailableThemes', 'New-TuiTheme', 'Export-TuiTheme', 'Import-TuiTheme'


####\modules\tui-engine-v2.psm1
# TUI Engine v5.0 - PowerShell 7+ Edition
# Implements a modern, reliable TUI rendering and input loop.

#region Core TUI State
$script:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    ScreenStack     = [System.Collections.Stack]::new()
    CurrentScreen   = $null
    IsDirty         = $true
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    FocusedComponent = $null
    InputQueue      = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]::new()
    InputRunspace   = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    CancellationTokenSource = $null
    EventHandlers   = @{}
}
#endregion

#region Engine Lifecycle & Main Loop

function Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )
    Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $script:TuiState.BufferWidth = $Width
        $script:TuiState.BufferHeight = $Height
        $script:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $script:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $script:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $script:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        try { Initialize-LayoutEngines; Write-Log -Level Debug -Message "Layout engines initialized" } catch { Write-Log -Level Error -Message "Layout engines init failed" -Data $_ }
        try { Initialize-ComponentSystem; Write-Log -Level Debug -Message "Component system initialized" } catch { Write-Log -Level Error -Message "Component system init failed" -Data $_ }
        
        $script:TuiState.EventHandlers = @{}
        [Console]::TreatControlCAsInput = $false
        
        Initialize-InputThread
        
        Publish-Event -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        $global:TuiState = $script:TuiState
        Write-Log -Level Info -Message "TUI Engine initialized successfully"
    }
    catch {
        Write-Host "FATAL: TUI Engine initialization failed. See error details below." -ForegroundColor Red
        $_.Exception | Format-List * -Force
        throw "TUI Engine initialization failed."
    }
}

function Initialize-InputThread {
    $script:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $script:TuiState.CancellationTokenSource.Token

    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $script:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    if ($InputQueue.Count -lt 100) { $InputQueue.Enqueue([Console]::ReadKey($true)) }
                } else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] { return }
        catch { Write-Warning "Input thread error: $_" }
    }) | Out-Null
    
    $script:TuiState.InputRunspace = $runspace
    $script:TuiState.InputPowerShell = $ps
    $script:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    $processedAny = $false
    $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
    while ($script:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
        $processedAny = $true
        try {
            Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key" -ScriptBlock { Process-SingleKeyInput -keyInfo $keyInfo }
        } catch {
            Write-Log -Level Error -Message "Error processing key input: $($_.Exception.Message)" -Data $_
            Request-TuiRefresh
        }
    }
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
        Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
        return
    }
    
    if (Handle-DialogInput -Key $keyInfo) { return }
    
    $focusedComponent = Get-FocusedComponent
    if ($focusedComponent -and $focusedComponent.HandleInput) {
        try { if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) { return } } catch { Write-Warning "Component input handler error: $_" }
    }
    
    $currentScreen = $script:TuiState.CurrentScreen
    if ($currentScreen -and $currentScreen.HandleInput) {
        try {
            $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
            switch ($result) {
                "Back" { Pop-Screen }
                "Quit" { Stop-TuiEngine }
            }
        } catch { Write-Warning "Screen input handler error: $_" }
    }
}

function Start-TuiLoop {
    param([hashtable]$InitialScreen)
    try {
        if (-not $script:TuiState.BufferWidth) { Initialize-TuiEngine }
        if ($InitialScreen) { Push-Screen -Screen $InitialScreen }
        if (-not $script:TuiState.CurrentScreen) { throw "No screen available. Push a screen before calling Start-TuiLoop." }

        $script:TuiState.Running = $true
        $frameTime = [System.Diagnostics.Stopwatch]::new()
        $targetFrameTime = 1000.0 / $script:TuiState.RenderStats.TargetFPS
        
        while ($script:TuiState.Running) {
            try {
                $frameTime.Restart()
                $hadInput = Process-TuiInput
                try { Update-DialogSystem } catch {}
                if ($script:TuiState.IsDirty -or $hadInput) { Render-Frame; $script:TuiState.IsDirty = $false }
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) { Start-Sleep -Milliseconds ([Math]::Max(1, $targetFrameTime - $elapsed)) }
            }
            catch [Helios.HeliosException] {
                Write-Log -Level Error -Message "A TUI Exception occurred: $($_.Exception.Message)" -Data $_.Exception.Context
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($_.Exception.Message)"
                $script:TuiState.IsDirty = $true
            }
            catch {
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($_.Exception.Message)" -Data $_
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                $script:TuiState.Running = $false
            }
        }
    }
    finally { Cleanup-TuiEngine }
}

function Render-Frame {
    try {
        Clear-BackBuffer -BackgroundColor (Get-ThemeColor "Background")
        
        $renderQueue = [System.Collections.Generic.List[object]]::new()
        $collectComponents = {
            param($component)
            if (-not $component -or $component.Visible -eq $false) { return }
            $renderQueue.Add($component)
            if ($component.PSObject.Properties.Name -contains 'Children' -and $component.Children.Count -gt 0) {
                if ($component.PSObject.Properties.Name -contains 'CalculateLayout') {
                    try { & $component.CalculateLayout -self $component } catch { Write-Log -Level Error -Message "Layout failed for '$($component.Name)'" }
                }
                foreach ($child in $component.Children) { & $script:collectComponents $child }
            }
        }
        if ($script:TuiState.CurrentScreen) { & $collectComponents -component $script:TuiState.CurrentScreen }
        if ($dialog = Get-CurrentDialog) { & $collectComponents -component $dialog }

        $sortedQueue = $renderQueue | Sort-Object { $_.ZIndex ?? 0 }

        foreach ($component in $sortedQueue) {
            if (-not ($component.PSObject.Properties.Name -contains 'Render')) { continue }
            if ($component -is [UIElement]) {
                $componentOutput = $component.Render()
                if (-not [string]::IsNullOrEmpty($componentOutput)) { [Console]::Write($componentOutput) }
            } else {
                Invoke-WithErrorHandling -Component ($component.Name ?? $component.Type) -Context "Functional Render" -ScriptBlock { & $component.Render -self $component }
            }
        }
        
        Render-BufferOptimized
        [Console]::SetCursorPosition($script:TuiState.BufferWidth - 1, $script:TuiState.BufferHeight - 1)
    } catch { Write-Warning "Fatal Frame render error: $_" }
}

function Request-TuiRefresh { $script:TuiState.IsDirty = $true }

function Cleanup-TuiEngine {
    try {
        $script:TuiState.CancellationTokenSource?.Cancel()
        $script:TuiState.InputPowerShell?.EndInvoke($script:TuiState.InputAsyncResult)
        $script:TuiState.InputPowerShell?.Dispose()
        $script:TuiState.InputRunspace?.Dispose()
        $script:TuiState.CancellationTokenSource?.Dispose()
        
        Stop-AllTuiAsyncJobs
        
        foreach ($handlerId in $script:TuiState.EventHandlers.Values) { try { Unsubscribe-Event -HandlerId $handlerId } catch {} }
        $script:TuiState.EventHandlers.Clear()
        
        if ($Host.Name -ne 'Visual Studio Code Host') {
            [Console]::Write("`e[0m"); [Console]::CursorVisible = $true; [Console]::Clear(); [Console]::ResetColor()
        }
    } catch { Write-Warning "A secondary error occurred during TUI cleanup: $_" }
}
#endregion

#region Screen Management
function Push-Screen {
    param([hashtable]$Screen)
    if (-not $Screen) { return }
    Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    try {
        $script:TuiState.FocusedComponent?.OnBlur?.Invoke()
        if ($script:TuiState.CurrentScreen) {
            $script:TuiState.CurrentScreen.OnExit?.Invoke()
            $script:TuiState.ScreenStack.Push($script:TuiState.CurrentScreen)
        }
        $script:TuiState.CurrentScreen = $Screen
        $script:TuiState.FocusedComponent = $null
        
        if ($Screen.Init) { 
            Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock { 
                $services = $Screen._services ?? $global:Services
                & $Screen.Init -self $Screen -services $services
            }
        }
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
    } catch { Write-Warning "Push screen error: $_" }
}

function Pop-Screen {
    if ($script:TuiState.ScreenStack.Count -eq 0) { return $false }
    Write-Log -Level Debug -Message "Popping screen"
    try {
        $script:TuiState.FocusedComponent?.OnBlur?.Invoke()
        $screenToExit = $script:TuiState.CurrentScreen
        $script:TuiState.CurrentScreen = $script:TuiState.ScreenStack.Pop()
        $script:TuiState.FocusedComponent = $null
        
        $screenToExit?.OnExit?.Invoke()
        $script:TuiState.CurrentScreen?.OnResume?.Invoke()
        if ($script:TuiState.CurrentScreen.LastFocusedComponent) { Set-ComponentFocus -Component $script:TuiState.CurrentScreen.LastFocusedComponent }
        
        Request-TuiRefresh
        Publish-Event -EventName "Screen.Popped" -Data @{ ScreenName = $script:TuiState.CurrentScreen.Name }
        return $true
    } catch { Write-Warning "Pop screen error: $_"; return $false }
}
#endregion

#region Buffer and Rendering
function Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
            $script:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = $BackgroundColor }
        }
    }
}

function Write-BufferString {
    param([int]$X, [int]$Y, [string]$Text, [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    if ($Y -lt 0 -or $Y -ge $script:TuiState.BufferHeight -or [string]::IsNullOrEmpty($Text)) { return }
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:TuiState.BufferWidth) { break }
        if ($currentX -ge 0) { $script:TuiState.BackBuffer[$Y, $currentX] = @{ Char = $char; FG = $ForegroundColor; BG = $BackgroundColor } }
        $currentX++
    }
}

function Write-BufferBox {
    param([int]$X, [int]$Y, [int]$Width, [int]$Height, [string]$BorderStyle = "Single", [ConsoleColor]$BorderColor = [ConsoleColor]::White, [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, [string]$Title = "")
    $borders = Get-BorderChars -Style $BorderStyle
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    if ($Title) {
        $titleText = " $Title "; if ($titleText.Length -gt ($Width-2)) { $titleText = " $($Title.Substring(0,[Math]::Max(0,$Width-5)))... " }
        Write-BufferString -X ($X + [Math]::Floor(($Width - $titleText.Length) / 2)) -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function Render-BufferOptimized {
    $outputBuilder = [System.Text.StringBuilder]::new(20000); $lastFG = -1; $lastBG = -1
    $forceFullRender = $script:TuiState.RenderStats.FrameCount -eq 0
    try {
        for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
                $backCell = $script:TuiState.BackBuffer[$y, $x]; $frontCell = $script:TuiState.FrontBuffer[$y, $x]
                if (-not $forceFullRender -and $backCell.Char -eq $frontCell.Char -and $backCell.FG -eq $frontCell.FG -and $backCell.BG -eq $frontCell.BG) { continue }
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) { $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null }
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG; $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null; $lastFG = $backCell.FG; $lastBG = $backCell.BG
                }
                $outputBuilder.Append($backCell.Char) | Out-Null
                $script:TuiState.FrontBuffer[$y, $x] = @{ Char = $backCell.Char; FG = $backCell.FG; BG = $backCell.BG }
            }
        }
        $outputBuilder.Append("`e[0m") | Out-Null
        if ($outputBuilder.Length -gt 0) { [Console]::Write($outputBuilder.ToString()) }
    } catch { Write-Warning "Render error: $_" }
}
#endregion

#region Component System
function Initialize-ComponentSystem { $script:TuiState.Components = @(); $script:TuiState.FocusedComponent = $null }
function Register-Component { param([hashtable]$Component); $script:TuiState.Components += $Component; if ($Component.Init) { try { & $Component.Init -self $Component } catch { Write-Warning "Component init error: $_" } }; return $Component }
function Set-ComponentFocus { param([hashtable]$Component); if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) { return }; $script:TuiState.FocusedComponent?.OnBlur?.Invoke(); if ($script:TuiState.CurrentScreen) { $script:TuiState.CurrentScreen.LastFocusedComponent = $Component }; $script:TuiState.FocusedComponent = $Component; $Component?.OnFocus?.Invoke(); Request-TuiRefresh }
function Clear-ComponentFocus { $script:TuiState.FocusedComponent?.OnBlur?.Invoke(); $script:TuiState.FocusedComponent = $null; if ($script:TuiState.CurrentScreen) { $script:TuiState.CurrentScreen.LastFocusedComponent = $null }; Request-TuiRefresh }
function Get-NextFocusableComponent { param([hashtable]$CurrentComponent, [bool]$Reverse = $false); if (-not $script:TuiState.CurrentScreen) { return $null }; $focusableComponents = @(); function Find-Focusable([hashtable]$Comp) { if ($Comp.IsFocusable -eq $true -and $Comp.Visible -ne $false) { $focusableComponents += $Comp }; if ($Comp.Children) { foreach ($c in $Comp.Children) { Find-Focusable $c } } }; if ($script:TuiState.CurrentScreen.Components) { foreach ($c in $script:TuiState.CurrentScreen.Components.Values) { Find-Focusable $c } }; if ($focusableComponents.Count -eq 0) { return $null }; $sorted = $focusableComponents | Sort-Object { $_.TabIndex ?? ($_.Y * 1000 + $_.X) }; if ($Reverse) { [Array]::Reverse($sorted) }; $currentIndex = [array]::IndexOf($sorted, $CurrentComponent); if ($currentIndex -ge 0) { return $sorted[($currentIndex + 1) % $sorted.Count] } else { return $sorted[0] } }
function Handle-TabNavigation { param([bool]$Reverse = $false); $next = Get-NextFocusableComponent -CurrentComponent $script:TuiState.FocusedComponent -Reverse $Reverse; if ($next) { Set-ComponentFocus -Component $next } }

# AI: FIX - Added missing helper functions
function Get-FocusedComponent { return $script:TuiState.FocusedComponent }

function Move-Focus { 
    param([bool]$Reverse = $false)
    Handle-TabNavigation -Reverse $Reverse
}

function Get-CurrentDialog {
    # Check if dialog system module is loaded and retrieve current dialog
    if (Get-Module -Name 'dialog-system') {
        $dialogModule = Get-Module -Name 'dialog-system'
        $dialogState = & $dialogModule { $script:DialogState }
        return $dialogState.CurrentDialog
    }
    return $null
}

function Stop-AllTuiAsyncJobs {
    # AI: Placeholder for async job cleanup - currently no async jobs in the system
    Write-Log -Level Debug -Message "Stopping all TUI async jobs (none currently active)"
}
#endregion

#region Layout Management & Utilities
function Initialize-LayoutEngines { $script:TuiState.Layouts = @{} }
function Get-BorderChars { param([string]$Style); $styles = @{ Single=@{TopLeft='┌';TopRight='┐';BottomLeft='└';BottomRight='┘';Horizontal='─';Vertical='│'}; Double=@{TopLeft='╔';TopRight='╗';BottomLeft='╚';BottomRight='╝';Horizontal='═';Vertical='║'}; Rounded=@{TopLeft='╭';TopRight='╮';BottomLeft='╰';BottomRight='╯';Horizontal='─';Vertical='│'} }; return $styles[$Style] ?? $styles.Single }
function Get-AnsiColorCode { param([ConsoleColor]$Color, [bool]$IsBackground); $map = @{ Black=30;DarkBlue=34;DarkGreen=32;DarkCyan=36;DarkRed=31;DarkMagenta=35;DarkYellow=33;Gray=37;DarkGray=90;Blue=94;Green=92;Cyan=96;Red=91;Magenta=95;Yellow=93;White=97 }; $code = $map[$Color.ToString()]; return $IsBackground ? $code + 10 : $code }
function Get-WordWrappedLines { param([string]$Text, [int]$MaxWidth); if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }; $lines = @(); $words = $Text -split '\s+'; $sb = [System.Text.StringBuilder]::new(); foreach ($word in $words) { if ($sb.Length -eq 0) { [void]$sb.Append($word) } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) { [void]$sb.Append(' ').Append($word) } else { $lines += $sb.ToString(); [void]$sb.Clear().Append($word) } }; if ($sb.Length -gt 0) { $lines += $sb.ToString() }; return $lines }
function Stop-TuiEngine { Write-Log -Level Info -Message "Stop-TuiEngine called"; $script:TuiState.Running = $false; $script:TuiState.CancellationTokenSource?.Cancel(); Publish-Event -EventName "System.Shutdown" }
#endregion

Export-ModuleMember -Function 'Initialize-TuiEngine', 'Start-TuiLoop', 'Stop-TuiEngine', 'Push-Screen', 'Pop-Screen', 'Request-TuiRefresh', 'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer', 'Get-BorderChars', 'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 'Get-NextFocusableComponent', 'Handle-TabNavigation', 'Get-WordWrappedLines' -Variable 'TuiState'


####\modules\tui-framework.psm1
# TUI Framework Integration Module
# Contains utility functions for interacting with the TUI engine and components.

$script:TuiAsyncJobs = @()

function Invoke-TuiMethod {
    <# .SYNOPSIS Safely invokes a method on a TUI component. #>
    param(
        [Parameter(Mandatory)] [hashtable]$Component,
        [Parameter(Mandatory)] [string]$MethodName,
        [Parameter()] [hashtable]$Arguments = @{}
    )
    if (-not $Component) { return }
    $method = $Component[$MethodName]
    if (-not ($method -is [scriptblock])) { return }

    $Arguments['self'] = $Component
    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock { & $method @Arguments }
}

function Initialize-TuiFramework {
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        if (-not $global:TuiState) { throw "TUI Engine must be initialized before the TUI Framework." }
        Write-Log -Level Info -Message "TUI Framework initialized."
    }
}

function Invoke-TuiAsync {
    <# .SYNOPSIS Executes a script block asynchronously with job management. #>
    param(
        [Parameter(Mandatory)] [scriptblock]$ScriptBlock,
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        [hashtable]$ArgumentList = @{}
    )
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        $script:TuiAsyncJobs += $job
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ JobId = $job.Id }
        return $job
    }
}

function Get-TuiAsyncResults {
    <# .SYNOPSIS Checks for completed async jobs and returns their results. #>
    param([switch]$RemoveCompleted = $true)
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = $script:TuiAsyncJobs | Where-Object { $_.State -in @('Completed', 'Failed', 'Stopped') }
        
        foreach ($job in $completedJobs) {
            $results += @{
                JobId = $job.Id; JobName = $job.Name; State = $job.State
                Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
            }
            Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ JobId = $job.Id; State = $job.State }
        }
        
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        return $results
    }
}

function Stop-AllTuiAsyncJobs {
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)"
            } catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_"
            }
        }
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped."
    }
}

function Request-TuiRefresh {
    if ($global:TuiState.RequestRefresh) { & $global:TuiState.RequestRefresh }
    else { Publish-Event -EventName "TUI.RefreshRequested" }
}

function Get-TuiState { return $global:TuiState }

function Test-TuiState {
    param([switch]$ThrowOnError)
    $isValid = $global:TuiState -and $global:TuiState.Running -and $global:TuiState.CurrentScreen
    if (-not $isValid -and $ThrowOnError) { throw "TUI state is not properly initialized. Call Initialize-TuiEngine first." }
    return $isValid
}

Export-ModuleMember -Function 'Invoke-TuiMethod', 'Initialize-TuiFramework', 'Invoke-TuiAsync', 'Get-TuiAsyncResults', 'Stop-AllTuiAsyncJobs', 'Request-TuiRefresh', 'Get-TuiState', 'Test-TuiState'


####\screens\dashboard\dashboard-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dashboard Screen
# Main entry screen for the application.
# ==============================================================================

# AI: CRITICAL FIX - Import models module for TaskStatus enum and other types
using module '..\..\modules\models.psm1'

# AI: FIX - Use $PSScriptRoot-based paths for better portability
using module '..\..\components\ui-classes.psm1'
using module '..\..\layout\panels-class.psm1'
using module '..\..\components\navigation-class.psm1'
using module '..\..\components\advanced-data-components.psm1'

class DashboardScreen : Screen {
    [BorderPanel] $MainPanel
    [ContentPanel] $SummaryPanel
    [NavigationMenu] $MainMenu
    [BorderPanel] $MenuPanel
    [object[]] $Tasks = @()

    DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) {
        Write-Log -Level Info -Message "Creating DashboardScreen instance."
    }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "Initialize" -ScriptBlock {
            $this.MainPanel = [BorderPanel]::new("DashboardMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "PMC Terminal v5 - Dashboard"
            $this.MainPanel.BorderStyle = "Double"
            $this.AddPanel($this.MainPanel)

            $this.SummaryPanel = [ContentPanel]::new("DashboardSummary", 2, 2, 40, 10)
            $this.MainPanel.AddChild($this.SummaryPanel)

            # AI: FIX - NavigationMenu doesn't need positioning - its parent panel handles that
            $this.MainMenu = [NavigationMenu]::new("MainMenu")
            
            $this.BuildMainMenu()
            
            # AI: FIX - Create menu panel with proper dimensions and position
            $this.MenuPanel = [BorderPanel]::new("MenuContainer", 44, 2, 50, 12)
            $this.MenuPanel.Title = "Main Menu"
            $this.MenuPanel.AddChild($this.MainMenu)
            $this.MainPanel.AddChild($this.MenuPanel)

            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData()
            
            Write-Log -Level Info -Message "DashboardScreen initialized successfully"
        }
    }

    hidden [void] BuildMainMenu() {
        $this.MainMenu.AddItem([NavigationItem]::new("1", "Task Management", { $this.Services.Navigation.GoTo("/tasks") }))
        $this.MainMenu.AddItem([NavigationItem]::new("2", "Project Management", { $this.Services.Navigation.GoTo("/projects") }))
        $this.MainMenu.AddItem([NavigationItem]::new("3", "Settings", { $this.Services.Navigation.GoTo("/settings") }))
        $this.MainMenu.AddSeparator()
        $this.MainMenu.AddItem([NavigationItem]::new("Q", "Quit Application", { $this.Services.Navigation.RequestExit() }))
        Write-Log -Level Debug -Message "Main menu built with $($this.MainMenu.Items.Count) items"
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "RefreshData" -ScriptBlock {
            if (-not $this.Services.DataManager) { Write-Log -Level Warning -Message "DataManager service not available"; return }
            $this.Tasks = @($this.Services.DataManager.GetTasks())
            $this.UpdateSummary()
            Write-Log -Level Debug -Message "Dashboard data refreshed - $($this.Tasks.Count) tasks loaded"
        }
    }

    hidden [void] UpdateSummary() {
        if (-not $this.SummaryPanel) { Write-Log -Level Warning -Message "Summary panel not initialized"; return }
        $total = $this.Tasks.Count
        # AI: FIX - TaskStatus enum should now be available from models.psm1 import
        $completed = ($this.Tasks | Where-Object { $_.Status -eq [TaskStatus]::Completed }).Count
        $pending = $total - $completed
        $summaryContent = @( "Task Summary", "═══════════", "", "Total Tasks: $total", "Completed:   $completed", "Pending:     $pending", "", "Use number keys or", "arrow keys + Enter" )
        $this.SummaryPanel.SetContent($summaryContent)
        Write-Log -Level Debug -Message "Summary updated: $total total, $completed completed"
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "HandleInput" -ScriptBlock {
            if (-not $this.MainMenu) { Write-Log -Level Warning -Message "Main menu not initialized"; return }
            
            $keyChar = $key.KeyChar.ToString().ToUpper()
            if ($keyChar -match '^[123Q]$') {
                Write-Log -Level Debug -Message "Processing hotkey: $keyChar"
                $this.MainMenu.ExecuteAction($keyChar)
                return
            }
            
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { if ($this.MainMenu.SelectedIndex -gt 0) { $this.MainMenu.SelectedIndex-- } }
                ([ConsoleKey]::DownArrow) { if ($this.MainMenu.SelectedIndex -lt ($this.MainMenu.Items.Count - 1)) { $this.MainMenu.SelectedIndex++ } }
                ([ConsoleKey]::Enter) {
                    $selectedItem = $this.MainMenu.Items[$this.MainMenu.SelectedIndex]
                    if ($selectedItem -and $selectedItem.Enabled) {
                        Write-Log -Level Debug -Message "Executing selected menu item: $($selectedItem.Key)"
                        $selectedItem.Execute()
                    }
                }
                ([ConsoleKey]::Escape) { Write-Log -Level Debug -Message "Escape pressed - requesting exit"; $this.Services.Navigation.RequestExit() }
                default { Write-Log -Level Debug -Message "Unhandled key: $($key.Key)" }
            }
        }
    }

    [void] OnDeactivate() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "OnDeactivate" -ScriptBlock {
            $this.Cleanup() # Unsubscribe from events
            Write-Log -Level Debug -Message "DashboardScreen deactivated and cleaned up"
        }
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\screens\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Task List Screen
# Displays and manages tasks.
# ==============================================================================

# AI: CRITICAL FIX - Import models module for TaskStatus enum and other types
using module '..\modules\models.psm1'

# AI: FIX - Use relative paths for better portability
using module '..\components\ui-classes.psm1'
using module '..\layout\panels-class.psm1'
using module '..\components\advanced-data-components.psm1'

class TaskListScreen : Screen {
    # --- UI Components ---
    [BorderPanel] $MainPanel
    [Table] $TaskTable
    [ContentPanel] $NavPanel

    # --- State ---
    [string] $FilterStatus = "All"

    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) { }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # --- Panel Setup ---
            $this.MainPanel = [BorderPanel]::new("TaskListMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "Task List"
            $this.AddPanel($this.MainPanel)

            # --- Task Table ---
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.SetColumns(@(
                [TableColumn]::new("Title", "Task Title", 50),
                [TableColumn]::new("Status", "Status", 15),
                [TableColumn]::new("Priority", "Priority", 12),
                [TableColumn]::new("DueDate", "Due Date", 15)
            ))
            
            $tableContainer = [BorderPanel]::new("TableContainer", 1, 1, 118, 24)
            $tableContainer.ShowBorder = $false
            $tableContainer.AddChild($this.TaskTable)
            $this.MainPanel.AddChild($tableContainer)
            
            # --- Navigation Panel ---
            $this.NavPanel = [ContentPanel]::new("NavPanel", 1, 26, 118, 3)
            $this.MainPanel.AddChild($this.NavPanel)
            
            # --- Event Subscriptions & Data Load ---
            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData()
        }
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            $allTasks = @($this.Services.DataManager.GetTasks())
            $filteredTasks = switch ($this.FilterStatus) {
                "Active" { $allTasks | Where-Object { $_.Status -ne [TaskStatus]::Completed } }
                "Completed" { $allTasks | Where-Object { $_.Status -eq [TaskStatus]::Completed } }
                default { $allTasks }
            }
            $this.TaskTable.SetData($filteredTasks)
            $this.UpdateNavText()
        }
    }

    hidden [void] UpdateNavText() {
        $navContent = @(
            "[N]ew | [E]dit | [D]elete | [Space]Toggle | [F]ilter: $($this.FilterStatus) | [Esc]Back"
        )
        $this.NavPanel.SetContent($navContent)
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { $this.TaskTable.SelectPrevious() }
                ([ConsoleKey]::DownArrow) { $this.TaskTable.SelectNext() }
                ([ConsoleKey]::Spacebar) { $this.ToggleSelectedTask() }
                ([ConsoleKey]::Escape) { $this.Services.Navigation.PopScreen() }
                default {
                    switch ($key.KeyChar.ToString().ToUpper()) {
                        'N' { $this.ShowNewTaskDialog() }
                        'E' { $this.EditSelectedTask() }
                        'D' { $this.DeleteSelectedTask() }
                        'F' { $this.CycleFilter() }
                    }
                }
            }
        }
    }
    
    hidden [void] ToggleSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            # AI: FIX - TaskStatus enum should now be available from models.psm1 import
            if ($task.Status -eq [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Pending
            } else {
                $task.Complete()
            }
            $this.Services.DataManager.UpdateTask($task)
        }
    }

    hidden [void] ShowNewTaskDialog() {
        # AI: FIX - Implemented new task dialog functionality
        Write-Log -Level Info -Message "New task dialog requested"
        
        # AI: FIX - Capture $this context for closure
        $dataManager = $this.Services.DataManager
        $refreshCallback = { $this.RefreshData() }.GetNewClosure()
        
        # Use the input dialog from dialog system
        Show-InputDialog -Title "New Task" -Prompt "Enter task title:" -OnSubmit {
            param($Value)
            if (-not [string]::IsNullOrWhiteSpace($Value)) {
                $newTask = $dataManager.AddTask($Value, "", [TaskPriority]::Medium, "General")
                Write-Log -Level Info -Message "Created new task: $($newTask.Title)"
                & $refreshCallback
            }
        }
    }

    hidden [void] EditSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Edit task requested for: $($task.Title)"
        }
    }

    hidden [void] DeleteSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            Write-Log -Level Info -Message "Delete task requested for: $($task.Title)"
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
    }
}

Export-ModuleMember -Function @() -Variable @() -Cmdlet @() -Alias @()



####\services\keybinding-service.psm1
# KeybindingService - Class-Based Implementation
# Manages application keybindings with proper error handling and validation
# AI: Updated with sophisticated keybinding features from R2 version

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# AI: FIX - Removed internal Import-Module statement. Dependencies managed by _CLASSY-MAIN.ps1.

# KeybindingService Class - Manages application-wide key bindings
class KeybindingService {
    [hashtable] $KeyMap = @{}
    [hashtable] $GlobalHandlers = @{}
    [System.Collections.Generic.List[string]] $ContextStack
    [bool] $EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized"
    }
    
    KeybindingService([bool]$enableChords) {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.EnableChords = $enableChords
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords"
    }
    
    hidden [void] InitializeDefaultBindings() {
        # AI: Standard application keybindings
        $this.KeyMap = @{
            "app.exit" = @{ Key = "Q"; Modifiers = @("Ctrl") }
            "app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }
            "nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
            "nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
            "nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
            "nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
            "nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
            "nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
            "nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
            "nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
            "nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
            "nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }
            "nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }
            "nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }
            "edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
            "edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }
            "edit.new" = @{ Key = "n"; Modifiers = @() }
            "edit.save" = @{ Key = "s"; Modifiers = @("Ctrl") }
            "app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKey]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [char]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key"
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
        }
        
        $modifiers = @()
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }

        $this.KeyMap[$actionName.ToLower()] = @{
            Key = $keyInfo.Key
            KeyChar = $keyInfo.KeyChar
            Modifiers = $modifiers
        }
        Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))"
    }
    
    [void] RemoveBinding([string]$actionName) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return
            }
            
            $normalizedName = $actionName.ToLower()
            if ($this.KeyMap.ContainsKey($normalizedName)) {
                $this.KeyMap.Remove($normalizedName)
                Write-Log -Level Debug -Message "Removed keybinding: $actionName"
            }
        }
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        return $this.IsAction($actionName, $keyInfo, $null)
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return $false
            }
            
            $normalizedName = $actionName.ToLower()
            if (-not $this.KeyMap.ContainsKey($normalizedName)) {
                return $false
            }
            
            $binding = $this.KeyMap[$normalizedName]
            
            # Check if the key matches
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = ($keyInfo.Key -eq $binding.Key)
            }
            elseif ($binding.Key -is [char]) {
                $keyMatches = ($keyInfo.KeyChar -eq $binding.Key)
            }
            elseif ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
                # Character-based binding (case-insensitive)
                $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.KeyChar.ToString(), [System.StringComparison]::OrdinalIgnoreCase)
            }
            else {
                # Try string comparison for backward compatibility
                $keyString = $binding.Key.ToString()
                if ($keyString.Length -eq 1) {
                    $keyMatches = ($keyInfo.KeyChar.ToString().ToUpper() -eq $keyString.ToUpper())
                }
                else {
                    # Try to match against ConsoleKey enum
                    try {
                        $consoleKey = [System.ConsoleKey]::Parse([System.ConsoleKey], $keyString, $true)
                        $keyMatches = ($keyInfo.Key -eq $consoleKey)
                    }
                    catch {
                        $keyMatches = $false
                    }
                }
            }
            
            if (-not $keyMatches) {
                return $false
            }
            
            # Check modifiers
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            $expectedCtrl = $binding.Modifiers -contains "Ctrl"
            $expectedAlt = $binding.Modifiers -contains "Alt"
            $expectedShift = $binding.Modifiers -contains "Shift"
            
            return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)
        }
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {
            foreach ($actionName in $this.KeyMap.Keys) {
                if ($this.IsAction($actionName, $keyInfo)) {
                    return $actionName
                }
            }
            return $null
        }
    }
    
    [void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $handler) {
                throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")
            }
            
            $this.GlobalHandlers[$actionName.ToLower()] = $handler
            Write-Log -Level Debug -Message "Registered global handler: $actionName"
        }
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        return $this.HandleKey($keyInfo, $null)
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {
            # Check all registered actions
            foreach ($action in $this.KeyMap.Keys) {
                if ($this.IsAction($action, $keyInfo, $context)) {
                    # Execute global handler if registered
                    if ($this.GlobalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler: $action"
                        try {
                            return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context
                        }
                        catch {
                            Write-Log -Level Error -Message "Global handler failed for '$action': $_"
                            return $null
                        }
                    }
                    
                    # Return the action name for the caller to handle
                    return $action
                }
            }
            
            return $null
        }
    }
    
    [void] PushContext([string]$context) {
        if (-not [string]::IsNullOrWhiteSpace($context)) {
            $this.ContextStack.Add($context)
            Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
        }
    }
    
    [string] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $context = $this.ContextStack[-1]
            $this.ContextStack.RemoveAt($this.ContextStack.Count - 1)
            Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))"
            return $context
        }
        return $null
    }
    
    [string] GetCurrentContext() {
        if ($this.ContextStack.Count -gt 0) {
            return $this.ContextStack[-1]
        }
        return "global"
    }
    
    [string] GetBindingDescription([string]$actionName) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            return $null
        }
        
        $normalizedName = $actionName.ToLower()
        if (-not $this.KeyMap.ContainsKey($normalizedName)) {
            return "Unbound"
        }
        
        $binding = $this.KeyMap[$normalizedName]
        $keyStr = if ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
            $binding.KeyChar.ToString().ToUpper()
        } elseif ($binding.Key -is [System.ConsoleKey]) {
            $binding.Key.ToString()
        } else {
            $binding.Key.ToString().ToUpper()
        }
        
        if ($binding.Modifiers.Count -gt 0) {
            return "$($binding.Modifiers -join '+') + $keyStr"
        }
        
        return $keyStr
    }
    
    [hashtable] GetAllBindings() {
        return $this.GetAllBindings($false)
    }
    
    [hashtable] GetAllBindings([bool]$groupByCategory) {
        if (-not $groupByCategory) {
            return $this.KeyMap.Clone()
        }
        
        # Group by category (part before the dot)
        $grouped = @{}
        foreach ($action in $this.KeyMap.Keys) {
            $parts = $action.Split('.')
            $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
            if (-not $grouped.ContainsKey($category)) {
                $grouped[$category] = @{}
            }
            $grouped[$category][$action] = $this.KeyMap[$action]
        }
        
        return $grouped
    }
    
    [void] ExportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            $this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8
            Write-Log -Level Info -Message "Exported keybindings to: $path"
        }
    }
    
    [void] ImportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            if (-not (Test-Path $path)) {
                Write-Log -Level Warning -Message "Keybindings file not found: $path"
                return
            }
            
            try {
                $imported = Get-Content $path -Raw | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $this.KeyMap[$prop.Name] = @{
                        Key = $prop.Value.Key
                        Modifiers = $prop.Value.Modifiers
                    }
                    # Handle KeyChar if present
                    if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {
                        $this.KeyMap[$prop.Name].KeyChar = $prop.Value.KeyChar
                    }
                }
                Write-Log -Level Info -Message "Imported keybindings from: $path"
            }
            catch {
                Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_"
                throw
            }
        }
    }
}

# Initialize function for backward compatibility
function Initialize-KeybindingService {
    param(
        [bool]$EnableChords = $false,
        [hashtable]$CustomBindings = @{}
    )
    
    $service = [KeybindingService]::new($EnableChords)
    
    # Apply custom bindings if provided
    if ($CustomBindings.Count -gt 0) {
        foreach ($action in $CustomBindings.Keys) {
            $binding = $CustomBindings[$action]
            if ($binding.Key -and $binding.Modifiers) {
                $service.SetBinding($action, $binding.Key, $binding.Modifiers)
            }
        }
    }
    
    return $service
}

# AI: FIX - PowerShell 7+ requires explicit class export for using module statements
Export-ModuleMember -Function 'Initialize-KeybindingService'



####\services\navigation-service-class.psm1
# Navigation Service - Class-Based Implementation
# Manages screen navigation, routing, and history.

using module ..\components\ui-classes.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

class ScreenFactory {
    hidden [hashtable] $Services
    hidden [hashtable] $ScreenTypes = @{}
    
    ScreenFactory([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        $this.RegisterDefaultScreens()
    }
    
    hidden [void] RegisterDefaultScreens() {
        # Screen classes are discovered by the main script's `using module` statements.
        $screenBaseType = [Screen]
        $loadedAssemblies = [System.AppDomain]::CurrentDomain.GetAssemblies()
        $screenClasses = $loadedAssemblies.GetTypes() | Where-Object { $_.IsSubclassOf($screenBaseType) -and -not $_.IsAbstract }
        
        foreach ($class in $screenClasses) {
            $this.RegisterScreen($class.Name, $class)
        }
    }
    
    [void] RegisterScreen([string]$name, [type]$screenType) {
        if (-not $screenType.IsSubclassOf([Screen])) { throw "'$($screenType.Name)' must inherit from the Screen class." }
        $this.ScreenTypes[$name] = $screenType
        Write-Log -Level Debug -Message "Registered screen factory: $name"
    }
    
    [Screen] CreateScreen([string]$screenName, [hashtable]$parameters) {
        $screenType = $this.ScreenTypes[$screenName] ?? (throw [System.InvalidOperationException]::new("Unknown screen type: '$screenName'."))
        
        try {
            $screen = $screenType.GetConstructor(@([hashtable])).Invoke(@($this.Services))
            if ($parameters) {
                foreach ($key in $parameters.Keys) { $screen.State[$key] = $parameters[$key] }
            }
            Write-Log -Level Debug -Message "Created screen: $screenName"
            return $screen
        } catch {
            Write-Log -Level Error -Message "Failed to create screen '$screenName': $_"
            throw
        }
    }
}

class NavigationService {
    [System.Collections.Generic.Stack[Screen]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [Screen] $CurrentScreen
    [hashtable] $Services
    [hashtable] $RouteMap = @{}
    
    NavigationService([hashtable]$services) {
        $this.Services = $services ?? (throw [System.ArgumentNullException]::new("services"))
        $this.ScreenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        $this.InitializeRoutes()
        Write-Log -Level Info -Message "NavigationService initialized"
    }
    
    hidden [void] InitializeRoutes() {
        $this.RouteMap = @{
            "/" = "DashboardScreen"
            "/dashboard" = "DashboardScreen"
            "/tasks" = "TaskListScreen"
        }
    }
    
    [void] GoTo([string]$path, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) { throw [System.ArgumentException]::new("Path cannot be empty.") }
            if ($path -eq "/exit") { $this.RequestExit(); return }
            
            $screenName = $this.RouteMap[$path] ?? (throw [System.InvalidOperationException]::new("Unknown route: $path"))
            $this.PushScreen($screenName, $parameters)
        }
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters = @{}) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            if ($this.CurrentScreen) {
                $this.CurrentScreen.OnExit()
                $this.ScreenStack.Push($this.CurrentScreen)
            }
            
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            $this.CurrentScreen = $newScreen
            
            $newScreen.Initialize()
            $newScreen.OnEnter()
            
            if ($global:TuiState) {
                $global:TuiState.CurrentScreen = $newScreen
                Request-TuiRefresh
            }
            Publish-Event -EventName "Navigation.ScreenChanged" -Data @{ Screen = $screenName; Action = "Push" }
        }
    }
    
    [bool] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) { Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"; return $false }
            
            $this.CurrentScreen?.OnExit()
            $this.CurrentScreen = $this.ScreenStack.Pop()
            $this.CurrentScreen?.OnResume()
            
            if ($global:TuiState) {
                $global:TuiState.CurrentScreen = $this.CurrentScreen
                Request-TuiRefresh
            }
            Publish-Event -EventName "Navigation.ScreenPopped" -Data @{ Screen = $this.CurrentScreen.Name }
            return $true
        }
    }
    
    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        while ($this.PopScreen()) {} # Pop all screens
        $this.CurrentScreen?.OnExit()
        Stop-TuiEngine
        Publish-Event -EventName "Application.Exit"
    }
    
    [Screen] GetCurrentScreen() { return $this.CurrentScreen }
    [bool] IsValidRoute([string]$path) { return $this.RouteMap.ContainsKey($path) }
}

function Initialize-NavigationService {
    param([hashtable]$Services)
    if (-not $Services) { throw [System.ArgumentNullException]::new("Services") }
    return [NavigationService]::new($Services)
}

# AI: FIX - Removed '-Class' parameter.
Export-ModuleMember -Function 'Initialize-NavigationService'


####\tests\Test-PMCTerminal.ps1
# ==============================================================================
# PMC Terminal v5 "Helios" - Comprehensive Test Script
# ==============================================================================

param(
    [switch]$Verbose,
    [switch]$SkipClearCache
)

$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# Change to project root
Set-Location $PSScriptRoot\..

Write-Host "`n=== PMC Terminal v5 Test Suite ===" -ForegroundColor Cyan

# 1. Clear module cache
if (-not $SkipClearCache) {
    Write-Host "`n[1] Clearing module cache..." -ForegroundColor Yellow
    & .\Clear-ModuleCache.ps1
    Write-Host "    ✓ Module cache cleared" -ForegroundColor Green
}

# 2. Test module loading
Write-Host "`n[2] Testing module loading..." -ForegroundColor Yellow
$modulesToTest = @(
    'exceptions', 'logger', 'event-system', 'theme-manager',
    'models', 'ui-classes', 'panels-class', 'navigation-class',
    'advanced-data-components', 'data-manager', 'keybinding-service',
    'navigation-service-class', 'dialog-system', 'tui-framework',
    'dashboard-screen', 'task-list-screen', 'tui-engine-v2'
)

$loadErrors = @()
foreach ($module in $modulesToTest) {
    try {
        $modulePath = Get-ChildItem -Path . -Filter "*$module*.psm1" -Recurse | Select-Object -First 1
        if ($modulePath) {
            Import-Module $modulePath.FullName -Force -ErrorAction Stop
            Write-Host "    ✓ Loaded: $module" -ForegroundColor Green
        } else {
            throw "Module file not found"
        }
    } catch {
        Write-Host "    ✗ Failed: $module - $_" -ForegroundColor Red
        $loadErrors += @{ Module = $module; Error = $_.Exception.Message }
    }
}

if ($loadErrors.Count -gt 0) {
    Write-Host "`nModule loading errors detected. Aborting tests." -ForegroundColor Red
    $loadErrors | Format-Table -AutoSize
    exit 1
}

# 3. Test service initialization
Write-Host "`n[3] Testing service initialization..." -ForegroundColor Yellow
try {
    # Initialize core services
    Initialize-Logger
    Write-Host "    ✓ Logger initialized" -ForegroundColor Green
    
    Initialize-EventSystem
    Write-Host "    ✓ Event system initialized" -ForegroundColor Green
    
    Initialize-ThemeManager
    Write-Host "    ✓ Theme manager initialized" -ForegroundColor Green
    
    Initialize-DialogSystem
    Write-Host "    ✓ Dialog system initialized" -ForegroundColor Green
    
    # Initialize data manager
    $dataManager = Initialize-DataManager
    Write-Host "    ✓ Data manager initialized" -ForegroundColor Green
    
    # Create services hashtable
    $services = @{
        DataManager = $dataManager
        Keybindings = [KeybindingService]::new()
    }
    $services.Navigation = [NavigationService]::new($services)
    Write-Host "    ✓ All services initialized" -ForegroundColor Green
    
} catch {
    Write-Host "    ✗ Service initialization failed: $_" -ForegroundColor Red
    exit 1
}

# 4. Test screen creation
Write-Host "`n[4] Testing screen creation..." -ForegroundColor Yellow
try {
    # Test dashboard screen
    $dashboardScreen = [DashboardScreen]::new($services)
    $dashboardScreen.Initialize()
    Write-Host "    ✓ Dashboard screen created and initialized" -ForegroundColor Green
    
    # Test task list screen
    $taskScreen = [TaskListScreen]::new($services)
    $taskScreen.Initialize()
    Write-Host "    ✓ Task list screen created and initialized" -ForegroundColor Green
    
} catch {
    Write-Host "    ✗ Screen creation failed: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    exit 1
}

# 5. Test data operations
Write-Host "`n[5] Testing data operations..." -ForegroundColor Yellow
try {
    # Add test task
    $testTask = $dataManager.AddTask("Test Task", "This is a test task", [TaskPriority]::Medium, "General")
    Write-Host "    ✓ Created test task: $($testTask.Title)" -ForegroundColor Green
    
    # Get tasks
    $tasks = $dataManager.GetTasks()
    Write-Host "    ✓ Retrieved $($tasks.Count) tasks" -ForegroundColor Green
    
    # Save data
    $dataManager.SaveData()
    Write-Host "    ✓ Data saved successfully" -ForegroundColor Green
    
} catch {
    Write-Host "    ✗ Data operations failed: $_" -ForegroundColor Red
    exit 1
}

# 6. Test TUI engine functions
Write-Host "`n[6] Testing TUI engine functions..." -ForegroundColor Yellow
try {
    # Test missing function availability
    if (Get-Command Get-CurrentDialog -ErrorAction SilentlyContinue) {
        Write-Host "    ✓ Get-CurrentDialog function available" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Get-CurrentDialog function missing" -ForegroundColor Red
    }
    
    if (Get-Command Stop-AllTuiAsyncJobs -ErrorAction SilentlyContinue) {
        Write-Host "    ✓ Stop-AllTuiAsyncJobs function available" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Stop-AllTuiAsyncJobs function missing" -ForegroundColor Red
    }
    
    if (Get-Command Move-Focus -ErrorAction SilentlyContinue) {
        Write-Host "    ✓ Move-Focus function available" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Move-Focus function missing" -ForegroundColor Red
    }
    
} catch {
    Write-Host "    ✗ TUI engine function test failed: $_" -ForegroundColor Red
}

# 7. Test navigation
Write-Host "`n[7] Testing navigation..." -ForegroundColor Yellow
try {
    # Check if dashboard route exists
    if ($services.Navigation.IsValidRoute("/dashboard")) {
        Write-Host "    ✓ Dashboard route is valid" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Dashboard route not found" -ForegroundColor Red
    }
    
    # Check if tasks route exists
    if ($services.Navigation.IsValidRoute("/tasks")) {
        Write-Host "    ✓ Tasks route is valid" -ForegroundColor Green
    } else {
        Write-Host "    ✗ Tasks route not found" -ForegroundColor Red
    }
    
} catch {
    Write-Host "    ✗ Navigation test failed: $_" -ForegroundColor Red
}

Write-Host "`n=== Test Summary ===" -ForegroundColor Cyan
Write-Host "All critical tests passed! The application should now work." -ForegroundColor Green
Write-Host "`nTo run the application, execute:" -ForegroundColor Yellow
Write-Host "    .\_CLASSY-MAIN.ps1" -ForegroundColor White
Write-Host "`nNote: If you still encounter errors, check the log file at:" -ForegroundColor Yellow
Write-Host "    $env:TEMP\PMCTerminal\pmc_terminal_$(Get-Date -Format 'yyyy-MM-dd').log" -ForegroundColor White



####\_CLASSY-MAIN.ps1
# ==============================================================================
# PMC Terminal v5 "Helios" - Modern PowerShell 7 Main Entry Point
# ==============================================================================

# --- Declarative Module Loading ---
# PowerShell 7+ loads all necessary modules and their classes/functions here.
# Order is important: dependencies must be loaded before dependents.

# Core Services (no dependencies)
using module '.\modules\exceptions.psm1'
using module '.\modules\logger.psm1'
using module '.\modules\event-system.psm1'
using module '.\modules\theme-manager.psm1'

# Base Classes
using module '.\modules\models.psm1'
using module '.\components\ui-classes.psm1'

# Components (depend on base classes)
using module '.\layout\panels-class.psm1'
using module '.\components\navigation-class.psm1'
using module '.\components\advanced-data-components.psm1'
using module '.\components\advanced-input-components.psm1'
using module '.\components\tui-components.psm1'

# Framework & Services (depend on core services and models)
using module '.\modules\data-manager.psm1'
using module '.\services\keybinding-service.psm1'
using module '.\services\navigation-service-class.psm1'
using module '.\modules\dialog-system.psm1'
using module '.\modules\tui-framework.psm1'

# Screens (depend on services and components)
using module '.\screens\dashboard\dashboard-screen.psm1'
using module '.\screens\task-list-screen.psm1'

# Engine (loaded last, depends on many utilities)
using module '.\modules\tui-engine-v2.psm1'

# --- Script Configuration ---
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# --- Main Application Logic ---
function Start-PMCTerminal {
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "Main" -Context "Main startup sequence" -ScriptBlock {
        # --- 1. Initialize Core Systems ---
        Initialize-Logger
        Write-Log -Level Info -Message "PMC Terminal v5 'Helios' startup initiated."
        
        Initialize-EventSystem
        Initialize-ThemeManager
        Initialize-DialogSystem
        
        # --- 2. Initialize and Assemble Services ---
        $services = @{
            DataManager = Initialize-DataManager
            Keybindings = [KeybindingService]::new()
        }
        $services.Navigation = [NavigationService]::new($services)
        
        $global:Services = $services
        Write-Log -Level Info -Message "All services initialized and assembled."
        
        # --- 3. Initialize TUI Engine and Navigate ---
        Write-Host "`nStarting TUI..." -ForegroundColor Green
        Clear-Host
        
        Initialize-TuiEngine
        
        $startPath = if ($args -contains "-start" -and ($args.IndexOf("-start") + 1) -lt $args.Count) {
            $args[$args.IndexOf("-start") + 1]
        } else {
            "/dashboard"
        }
        
        if (-not $services.Navigation.IsValidRoute($startPath)) {
            Write-Log -Level Warning -Message "Startup path '$startPath' is not valid. Defaulting to /dashboard."
            $startPath = "/dashboard"
        }
        
        $services.Navigation.GoTo($startPath, @{})
        
        # --- 4. Start the Main Loop ---
        Start-TuiLoop
        
        Write-Log -Level Info -Message "PMC Terminal exited gracefully."
    }
}

# --- Main Execution Block ---
try {
    Start-PMCTerminal
}
catch {
    $errorMessage = "A fatal, unhandled exception occurred: $($_.Exception.Message)"
    Write-Host "`n$errorMessage" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Fatal -Message $errorMessage -Data @{ Exception = $_.Exception; Stack = $_.ScriptStackTrace } -Force
    }
    
    exit 1
}
finally {
    if ($global:Services -and $global:Services.DataManager) {
        try {
            $global:Services.DataManager.SaveData()
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Info -Message "Data saved on exit." -Force
            }
        }
        catch {
            Write-Warning "Failed to save data on exit: $_"
        }
    }
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Application shutdown complete." -Force
    }
}



####\Clear-ModuleCache.ps1
# Clear PowerShell Module Cache for PMC Terminal
Write-Host "Clearing PowerShell module cache..." -ForegroundColor Yellow

# Get all loaded modules from our application
$modulesToRemove = Get-Module | Where-Object { 
    $_.Path -like "*\_CLASSY*" -or 
    $_.Name -in @('models', 'logger', 'exceptions', 'event-system', 'data-manager', 
                   'theme-manager', 'tui-framework', 'tui-engine-v2', 'dialog-system',
                   'keybinding-service', 'navigation-service-class', 'panels-class',
                   'focus-manager', 'advanced-input-components', 'advanced-data-components',
                   'ui-classes', 'panel-classes', 'table-class', 'navigation-class')
}

foreach ($module in $modulesToRemove) {
    Write-Host "Removing module: $($module.Name)" -ForegroundColor Cyan
    Remove-Module $module -Force -ErrorAction SilentlyContinue
}

# Clear any compiled assemblies (for our custom exceptions)
if ('Helios.HeliosException' -as [type]) {
    Write-Host "Note: Custom exception types are loaded and cannot be unloaded in this session." -ForegroundColor Yellow
    Write-Host "For a complete refresh, please start a new PowerShell session." -ForegroundColor Yellow
}

Write-Host "`nModule cache cleared. You can now run the application again." -ForegroundColor Green
Write-Host "Run: pwsh -file _CLASSY-MAIN.ps1" -ForegroundColor White



####\filecopy.ps1
# This script finds all .ps1 and .psm1 files in the current directory and its subdirectories.
# For each found file, it creates a copy with a .txt extension in the same location.
# Finally, it concatenates the content of all original .ps1 and .psm1 files into a single file named 'all.txt'
# in the current directory. Each appended file is preceded by a header indicating its relative path.

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the current working directory, ensuring no trailing backslash for consistent path manipulation
$currentDirectory = (Get-Location).Path.TrimEnd('\')

# Define the name of the output concatenated file
$outputFileName = "all.txt"

Write-Host "Starting script operations in: $currentDirectory"

# --- Step 1: Clear the existing output file if it exists ---
try {
    if (Test-Path $outputFileName) {
        Remove-Item $outputFileName -Force -ErrorAction Stop
        Write-Host "Cleared existing '$outputFileName'."
    }
} catch {
    Write-Warning "Failed to clear '$outputFileName': $($_.Exception.Message)"
    # Continue, as this might not be a fatal error for the rest of the script
}

# --- Step 2: Find all .ps1 and .psm1 files recursively ---
try {
    $scriptFiles = Get-ChildItem -Path $currentDirectory -Recurse -Include *.ps1, *.psm1 -File -ErrorAction Stop
    Write-Host "Found $($scriptFiles.Count) PowerShell script files."
} catch {
    Write-Error "Failed to enumerate script files: $($_.Exception.Message)"
    exit 1 # Exit if we can't even find the files
}

# --- Step 3: Process each file (copy and concatenate) ---
if ($scriptFiles.Count -eq 0) {
    Write-Warning "No .ps1 or .psm1 files found to process."
} else {
    foreach ($file in $scriptFiles) {
        # Create a copy with .txt ending in the same folder
        $txtCopyPath = Join-Path -Path $file.DirectoryName -ChildPath ($file.BaseName + ".txt")
        try {
            Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force -ErrorAction Stop
            Write-Host "  Copied: $($file.Name) to $($txtCopyPath)"
        } catch {
            Write-Warning "  Failed to copy $($file.FullName) to $($txtCopyPath): $($_.Exception.Message)"
        }

        # Prepare header for all.txt using relative path
        # Remove the base directory part from the full path to get the relative path
        $relativePath = $file.FullName.Substring($currentDirectory.Length)
        # Ensure the relative path starts with a single backslash
        if (-not $relativePath.StartsWith('\')) {
            $relativePath = '\' + $relativePath
        }

        $header = "####$relativePath"
        
        # Append the header and file content to all.txt
        try {
            Add-Content -Path $outputFileName -Value $header -Encoding UTF8 -ErrorAction Stop
            # Read the entire file content as a single string
            $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value $fileContent -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value "`n" -Encoding UTF8 -ErrorAction Stop # Add an extra newline for separation
            Write-Host "  Appended: $($file.Name) to $($outputFileName)"
        } catch {
            Write-Warning "  Failed to append $($file.FullName) to $($outputFileName): $($_.Exception.Message)"
        }
    }
}

Write-Host "All operations complete. Concatenated content saved to '$outputFileName'."


