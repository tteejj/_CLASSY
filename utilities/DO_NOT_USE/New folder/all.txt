####\components\advanced-data-components.psm1
# Advanced Data Components Module for PMC Terminal v5
# Enhanced data display components with sorting, filtering, and pagination
# AI: Class-based implementation following CLASSY architecture patterns

using module '..\components\ui-classes.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import utilities for error handling
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

#region Advanced Data Table Class

class DataTableComponent : UIElement {
    [hashtable[]] $Data = @()
    [hashtable[]] $Columns = @()
    [int] $X = 0
    [int] $Y = 0
    [int] $Width = 80
    [int] $Height = 20
    [string] $Title = "Data Table"
    [bool] $ShowBorder = $true
    [bool] $IsFocusable = $true
    [int] $SelectedRow = 0
    [int] $ScrollOffset = 0
    [string] $SortColumn = $null
    [string] $SortDirection = "Ascending"
    [string] $FilterText = ""
    [string] $FilterColumn = $null
    [int] $PageSize = 0  # 0 = auto-calculate
    [int] $CurrentPage = 0
    [bool] $ShowHeader = $true
    [bool] $ShowFooter = $true
    [bool] $ShowRowNumbers = $false
    [bool] $AllowSort = $true
    [bool] $AllowFilter = $true
    [bool] $AllowSelection = $true
    [bool] $MultiSelect = $false
    [int[]] $SelectedRows = @()
    [hashtable[]] $FilteredData = @()
    [hashtable[]] $ProcessedData = @()
    [bool] $FilterMode = $false
    hidden [int] $_lastRenderedWidth = 0
    hidden [int] $_lastRenderedHeight = 0
    
    # Event handlers
    [scriptblock] $OnRowSelect = $null
    [scriptblock] $OnSelectionChange = $null
    
    DataTableComponent([string]$name) : base($name) {
        $this.IsFocusable = $true
    }
    
    DataTableComponent([string]$name, [hashtable[]]$data, [hashtable[]]$columns) : base($name) {
        $this.IsFocusable = $true
        $this.Data = $data
        $this.Columns = $columns
        $this.ProcessData()
    }
    
    [void] ProcessData() {
        Invoke-WithErrorHandling -Component "$($this.Name).ProcessData" -Context "Processing table data" -ScriptBlock {
            # Filter data
            if ([string]::IsNullOrWhiteSpace($this.FilterText)) {
                $this.FilteredData = $this.Data
            } else {
                if ($this.FilterColumn) {
                    # Filter specific column
                    $this.FilteredData = @($this.Data | Where-Object {
                        $value = $_."$($this.FilterColumn)"
                        $value -and $value.ToString() -like "*$($this.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $this.FilteredData = @($this.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $this.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($this.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($this.SortColumn -and $this.AllowSort) {
                $this.ProcessedData = $this.FilteredData | Sort-Object -Property $this.SortColumn -Descending:($this.SortDirection -eq "Descending")
            } else {
                $this.ProcessedData = $this.FilteredData
            }
            
            # Reset selection if needed
            if ($this.SelectedRow -ge $this.ProcessedData.Count) {
                $this.SelectedRow = [Math]::Max(0, $this.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($this.PageSize -eq 0) {
                $headerLines = if ($this.ShowHeader) { 3 } else { 0 }
                $footerLines = if ($this.ShowFooter) { 2 } else { 0 }
                $filterLines = if ($this.AllowFilter) { 2 } else { 0 }
                $borderAdjust = if ($this.ShowBorder) { 2 } else { 0 }
                $calculatedPageSize = $this.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
                $this.PageSize = [Math]::Max(1, $calculatedPageSize)
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($this.ProcessedData.Count / [Math]::Max(1, $this.PageSize))
            if ($this.CurrentPage -ge $totalPages) {
                $this.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
    }
    
    [hashtable] GetContentBounds() {
        $borderOffset = if ($this.ShowBorder) { 1 } else { 0 }
        return @{
            X = $this.X + $borderOffset
            Y = $this.Y + $borderOffset
            Width = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
    
    hidden [string] _RenderContent() {
        $renderedContent = [System.Text.StringBuilder]::new()
        
        # Force ProcessData if dimensions changed
        if ($this._lastRenderedWidth -ne $this.Width -or $this._lastRenderedHeight -ne $this.Height) {
            $this.ProcessData()
            $this._lastRenderedWidth = $this.Width
            $this._lastRenderedHeight = $this.Height
        }
        
        # Calculate content area based on border settings
        if ($this.ShowBorder) {
            $borderColor = if ($this.IsFocusable -and $this.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            [void]$renderedContent.Append($this.MoveCursor($this.X, $this.Y))
            [void]$renderedContent.Append($this.SetColor($borderColor))
            [void]$renderedContent.Append($this.RenderBorder($this.Title))
            
            # Adjust content area for border
            $contentX = $this.X + 1
            $contentY = $this.Y + 1
            $contentWidth = $this.Width - 2
            $contentHeight = $this.Height - 2
        } else {
            # No border, use full dimensions
            $contentX = $this.X
            $contentY = $this.Y
            $contentWidth = $this.Width
            $contentHeight = $this.Height
        }
        
        $currentY = $contentY
        
        # Filter bar
        if ($this.AllowFilter) {
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::White))
            [void]$renderedContent.Append("Filter: ")
            
            $filterDisplayText = if ($this.FilterText) { $this.FilterText } else { "Type to filter..." }
            $filterColor = if ($this.FilterText) { [ConsoleColor]::Yellow } else { [ConsoleColor]::DarkGray }
            [void]$renderedContent.Append($this.SetColor($filterColor))
            [void]$renderedContent.Append($filterDisplayText)
            
            $currentY += 2
        }
        
        # Calculate column widths
        $totalDefinedWidth = ($this.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum
        if ($null -eq $totalDefinedWidth) { $totalDefinedWidth = 0 }
        $flexColumns = @($this.Columns | Where-Object { -not $_.Width })
        $columnSeparators = if ($this.Columns.Count -gt 1) { $this.Columns.Count - 1 } else { 0 }
        $rowNumberWidth = if ($this.ShowRowNumbers) { 5 } else { 0 }
        $remainingWidth = $contentWidth - $totalDefinedWidth - $rowNumberWidth - $columnSeparators
        
        $flexWidth = 0
        if ($flexColumns.Count -gt 0) {
            $flexWidth = [Math]::Floor($remainingWidth / $flexColumns.Count)
        }
        
        # Assign calculated widths
        foreach ($col in $this.Columns) {
            if ($col.Width) {
                $col.CalculatedWidth = $col.Width
            } else {
                $col.CalculatedWidth = [Math]::Max(5, $flexWidth)
            }
        }
        
        # Header
        if ($this.ShowHeader) {
            $headerX = $contentX
            
            # Row number header
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append("#".PadRight(4))
                $headerX += 5
            }
            
            # Column headers
            foreach ($col in $this.Columns) {
                $headerText = if ($col.Header) { $col.Header } else { $col.Name }
                $width = $col.CalculatedWidth
                
                # Add sort indicator
                if ($this.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $this.SortColumn) {
                    $sortIndicator = if ($this.SortDirection -eq "Ascending") { "▲" } else { "▼" }
                    $headerText = "$headerText $sortIndicator"
                }
                
                # Truncate if needed
                if ($headerText.Length -gt $width) {
                    $maxLength = [Math]::Max(0, $width - 3)
                    $headerText = $headerText.Substring(0, $maxLength) + "..."
                }
                
                # Align header
                if ($col.Align -eq "Right") {
                    $alignedText = $headerText.PadLeft($width)
                } elseif ($col.Align -eq "Center") {
                    $padding = $width - $headerText.Length
                    $leftPad = [Math]::Floor($padding / 2)
                    $rightPad = $padding - $leftPad
                    $alignedText = " " * $leftPad + $headerText + " " * $rightPad
                } else {
                    $alignedText = $headerText.PadRight($width)
                }
                
                [void]$renderedContent.Append($this.MoveCursor($headerX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Cyan))
                [void]$renderedContent.Append($alignedText)
                
                $headerX += $width + 1
            }
            
            $currentY++
            
            # Header separator
            [void]$renderedContent.Append($this.MoveCursor($contentX, $currentY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append("─" * $contentWidth)
            $currentY++
        }
        
        # Data rows
        $dataToRender = if ($this.ProcessedData.Count -eq 0 -and $this.Data.Count -gt 0) {
            $this.Data
        } else {
            $this.ProcessedData
        }
        
        $startIdx = $this.CurrentPage * $this.PageSize
        $endIdx = [Math]::Min($startIdx + $this.PageSize - 1, $dataToRender.Count - 1)
        
        for ($i = $startIdx; $i -le $endIdx; $i++) {
            $row = $dataToRender[$i]
            $rowX = $contentX
            
            # Selection highlighting
            $isSelected = if ($this.MultiSelect) {
                $this.SelectedRows -contains $i
            } else {
                $i -eq $this.SelectedRow
            }
            
            $rowBg = if ($isSelected) { [ConsoleColor]::Cyan } else { [ConsoleColor]::Black }
            $rowFg = if ($isSelected) { [ConsoleColor]::Black } else { [ConsoleColor]::White }
            
            # Clear row background if selected
            if ($isSelected) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(" " * $contentWidth)
            }
            
            # Row number
            if ($this.ShowRowNumbers) {
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append(($i + 1).ToString().PadRight(4))
                $rowX += 5
            }
            
            # Cell data
            foreach ($col in $this.Columns) {
                $value = $row."$($col.Name)"
                $width = $col.CalculatedWidth
                
                # Format value
                $displayValue = if ($col.Format -and $value -ne $null) {
                    & $col.Format $value
                } elseif ($value -ne $null) {
                    $value.ToString()
                } else {
                    ""
                }
                
                # Truncate if needed
                if ($displayValue.Length -gt $width) {
                    $maxLength = [Math]::Max(0, $width - 3)
                    if ($maxLength -le 0) {
                        $displayValue = "..."
                    } else {
                        $displayValue = $displayValue.Substring(0, $maxLength) + "..."
                    }
                }
                
                # Align value
                if ($col.Align -eq "Right") {
                    $alignedValue = $displayValue.PadLeft($width)
                } elseif ($col.Align -eq "Center") {
                    $padding = $width - $displayValue.Length
                    $leftPad = [Math]::Floor($padding / 2)
                    $rightPad = $padding - $leftPad
                    $alignedValue = " " * $leftPad + $displayValue + " " * $rightPad
                } else {
                    $alignedValue = $displayValue.PadRight($width)
                }
                
                # Determine color
                $cellFg = if ($col.Color -and -not $isSelected) {
                    $colorName = & $col.Color $value $row
                    Get-ThemeColor $colorName -Default ([ConsoleColor]::White)
                } else {
                    $rowFg
                }
                
                [void]$renderedContent.Append($this.MoveCursor($rowX, $currentY))
                [void]$renderedContent.Append($this.SetColor($cellFg))
                [void]$renderedContent.Append($this.SetBackgroundColor($rowBg))
                [void]$renderedContent.Append($alignedValue)
                
                $rowX += $width + 1
            }
            
            $currentY++
        }
        
        # Empty state
        if ($dataToRender.Count -eq 0) {
            $emptyMessage = if ($this.FilterText) {
                "No results match the filter"
            } else {
                "No data to display"
            }
            $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
            $msgY = $contentY + [Math]::Floor($contentHeight / 2)
            [void]$renderedContent.Append($this.MoveCursor($msgX, $msgY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($emptyMessage)
        }
        
        # Footer
        if ($this.ShowFooter) {
            $footerY = $contentY + $contentHeight - 1
            
            # Status
            $statusText = "$($dataToRender.Count) rows"
            if ($this.FilterText) {
                $statusText += " (filtered from $($this.Data.Count))"
            }
            if ($this.MultiSelect) {
                $statusText += " | $($this.SelectedRows.Count) selected"
            }
            [void]$renderedContent.Append($this.MoveCursor($contentX + 1, $footerY))
            [void]$renderedContent.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$renderedContent.Append($statusText)
            
            # Pagination
            if ($dataToRender.Count -gt $this.PageSize) {
                $totalPages = [Math]::Ceiling($dataToRender.Count / [Math]::Max(1, $this.PageSize))
                $pageText = "Page $($this.CurrentPage + 1)/$totalPages"
                [void]$renderedContent.Append($this.MoveCursor($contentX + $contentWidth - $pageText.Length - 1, $footerY))
                [void]$renderedContent.Append($this.SetColor([ConsoleColor]::Blue))
                [void]$renderedContent.Append($pageText)
            }
        }
        
        [void]$renderedContent.Append($this.ResetColor())
        return $renderedContent.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Filter mode
        if ($key.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($key.Key) {
                ([ConsoleKey]::F) {
                    $this.FilterMode = -not $this.FilterMode
                    if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::S) {
                    if ($this.AllowSort) {
                        $sortableCols = @($this.Columns | Where-Object { $_.Sortable -ne $false })
                        if ($sortableCols.Count -gt 0) {
                            $currentIdx = [array]::IndexOf($sortableCols.Name, $this.SortColumn)
                            $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                            $this.SortColumn = $sortableCols[$nextIdx].Name
                            $this.ProcessData()
                            if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                                Request-TuiRefresh
                            }
                        }
                    }
                    return $true
                }
            }
        }
        
        # Filter text input
        if ($this.FilterMode) {
            switch ($key.Key) {
                ([ConsoleKey]::Escape) {
                    $this.FilterMode = $false
                    if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    $this.FilterMode = $false
                    $this.ProcessData()
                    if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($this.FilterText.Length -gt 0) {
                        $this.FilterText = $this.FilterText.Substring(0, $this.FilterText.Length - 1)
                        $this.ProcessData()
                        if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
                default {
                    if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                        $this.FilterText += $key.KeyChar
                        $this.ProcessData()
                        if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                            Request-TuiRefresh
                        }
                        return $true
                    }
                }
            }
            return $false
        }
        
        # Normal navigation
        switch ($key.Key) {
            ([ConsoleKey]::UpArrow) {
                if ($this.SelectedRow -gt 0) {
                    $this.SelectedRow--
                    if ($this.SelectedRow -lt ($this.CurrentPage * $this.PageSize)) {
                        $this.CurrentPage--
                    }
                    if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                        Request-TuiRefresh
                    }
                }
                return $true
            }
            ([ConsoleKey]::DownArrow) {
                if ($this.SelectedRow -lt ($this.ProcessedData.Count - 1)) {
                    $this.SelectedRow++
                    if ($this.SelectedRow -ge (($this.CurrentPage + 1) * $this.PageSize)) {
                        $this.CurrentPage++
                    }
                    if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                        Request-TuiRefresh
                    }
                }
                return $true
            }
            ([ConsoleKey]::Enter) {
                if ($this.OnRowSelect -and $this.ProcessedData.Count -gt 0) {
                    $selectedData = if ($this.MultiSelect) {
                        @($this.SelectedRows | ForEach-Object { $this.ProcessedData[$_] })
                    } else {
                        $this.ProcessedData[$this.SelectedRow]
                    }
                    & $this.OnRowSelect $selectedData $this.SelectedRow
                }
                return $true
            }
        }
        
        return $false
    }
    
    # Helper methods for ANSI escape sequences
    hidden [string] MoveCursor([int]$x, [int]$y) {
        return "`e[$($y + 1);$($x + 1)H"
    }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] SetBackgroundColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 40; 'DarkRed' = 41; 'DarkGreen' = 42; 'DarkYellow' = 43
            'DarkBlue' = 44; 'DarkMagenta' = 45; 'DarkCyan' = 46; 'Gray' = 47
            'DarkGray' = 100; 'Red' = 101; 'Green' = 102; 'Yellow' = 103
            'Blue' = 104; 'Magenta' = 105; 'Cyan' = 106; 'White' = 107
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
    
    hidden [string] RenderBorder([string]$title) {
        $borderBuilder = [System.Text.StringBuilder]::new()
        
        # Top border
        [void]$borderBuilder.Append("┌")
        
        if (-not [string]::IsNullOrWhiteSpace($title)) {
            $titleText = " $title "
            $horizontalSpace = $this.Width - 2
            if ($titleText.Length -gt $horizontalSpace) {
                $titleText = $titleText.Substring(0, $horizontalSpace)
            }
            
            $paddingBefore = [Math]::Floor(($horizontalSpace - $titleText.Length) / 2)
            $paddingAfter = $horizontalSpace - $titleText.Length - $paddingBefore
            
            [void]$borderBuilder.Append("─" * $paddingBefore)
            [void]$borderBuilder.Append($titleText)
            [void]$borderBuilder.Append("─" * $paddingAfter)
        } else {
            [void]$borderBuilder.Append("─" * ($this.Width - 2))
        }
        
        [void]$borderBuilder.Append("┐")
        
        # Side borders
        for ($row = 1; $row -lt $this.Height - 1; $row++) {
            [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $row))
            [void]$borderBuilder.Append("│")
            [void]$borderBuilder.Append($this.MoveCursor($this.X + $this.Width - 1, $this.Y + $row))
            [void]$borderBuilder.Append("│")
        }
        
        # Bottom border
        [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $this.Height - 1))
        [void]$borderBuilder.Append("└")
        [void]$borderBuilder.Append("─" * ($this.Width - 2))
        [void]$borderBuilder.Append("┘")
        
        return $borderBuilder.ToString()
    }
    
    # Public methods
    [void] RefreshData() {
        $this.ProcessData()
        if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
            Request-TuiRefresh
        }
    }
    
    [void] SetData([hashtable[]]$data) {
        $this.Data = $data
        $this.ProcessData()
        if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
            Request-TuiRefresh
        }
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this.ProcessData()
        if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
            Request-TuiRefresh
        }
    }
}

#endregion

#region Factory Functions for Backward Compatibility

function global:New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $name = if ($Props.Name) { $Props.Name } else { "DataTable_$([Guid]::NewGuid().ToString('N').Substring(0,8))" }
    $data = if ($Props.Data) { $Props.Data } else { @() }
    $columns = if ($Props.Columns) { $Props.Columns } else { @() }
    
    $table = [DataTableComponent]::new($name, $data, $columns)
    
    # Set properties from Props
    if ($Props.X) { $table.X = $Props.X }
    if ($Props.Y) { $table.Y = $Props.Y }
    if ($Props.Width) { $table.Width = $Props.Width }
    if ($Props.Height) { $table.Height = $Props.Height }
    if ($Props.Title) { $table.Title = $Props.Title }
    if ($null -ne $Props.ShowBorder) { $table.ShowBorder = $Props.ShowBorder }
    if ($null -ne $Props.ShowHeader) { $table.ShowHeader = $Props.ShowHeader }
    if ($null -ne $Props.ShowFooter) { $table.ShowFooter = $Props.ShowFooter }
    if ($null -ne $Props.ShowRowNumbers) { $table.ShowRowNumbers = $Props.ShowRowNumbers }
    if ($null -ne $Props.AllowSort) { $table.AllowSort = $Props.AllowSort }
    if ($null -ne $Props.AllowFilter) { $table.AllowFilter = $Props.AllowFilter }
    if ($null -ne $Props.AllowSelection) { $table.AllowSelection = $Props.AllowSelection }
    if ($null -ne $Props.MultiSelect) { $table.MultiSelect = $Props.MultiSelect }
    if ($null -ne $Props.Visible) { $table.Visible = $Props.Visible }
    if ($Props.OnRowSelect) { $table.OnRowSelect = $Props.OnRowSelect }
    if ($Props.OnSelectionChange) { $table.OnSelectionChange = $Props.OnSelectionChange }
    
    return $table
}

#endregion

# Export classes and functions
Export-ModuleMember -Function @('New-TuiDataTable') -Class @('DataTableComponent')


####\components\advanced-input-components.psm1
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function global:New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Mode = if ($null -ne $Props.Mode) { $Props.Mode } else { "Date" } # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        ViewDate = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSelect = $Props.OnSelect
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Main container
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " Calendar "
                
                # Header with navigation
                $headerY = $self.Y + 1
                $monthYear = $self.ViewDate.ToString("MMMM yyyy")
                $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
                
                Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
                Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
                Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
                
                # Day headers
                $dayHeaderY = $headerY + 2
                $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
                $dayWidth = 4
                $startX = $self.X + 2
                
                for ($i = 0; $i -lt $days.Count; $i++) {
                    Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                        -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
                }
                
                # Calendar grid
                $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
                $startDayOfWeek = [int]$firstDay.DayOfWeek
                $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
                
                $currentDay = 1
                $calendarY = $dayHeaderY + 1
                
                for ($week = 0; $week -lt 6; $week++) {
                    if ($currentDay -gt $daysInMonth) { break }
                    
                    for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                        $x = $startX + ($dayOfWeek * $dayWidth)
                        
                        if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                            continue
                        }
                        
                        if ($currentDay -le $daysInMonth) {
                            $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                         $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                         $self.ViewDate.Year -eq $self.SelectedDate.Year)
                            
                            $isToday = ($currentDay -eq (Get-Date).Day -and 
                                      $self.ViewDate.Month -eq (Get-Date).Month -and 
                                      $self.ViewDate.Year -eq (Get-Date).Year)
                            
                            $fg = if ($isSelected) { 
                                Get-ThemeColor "Background" 
                            } elseif ($isToday) { 
                                Get-ThemeColor "Accent" 
                            } else { 
                                Get-ThemeColor "Primary" 
                            }
                            
                            $bg = if ($isSelected) { 
                                Get-ThemeColor "Accent" 
                            } else { 
                                Get-ThemeColor "Background" 
                            }
                            
                            $dayText = $currentDay.ToString().PadLeft(2)
                            Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText `
                                -ForegroundColor $fg -BackgroundColor $bg
                            
                            $currentDay++
                        }
                    }
                }
                
                # Time picker if in DateTime mode
                if ($self.Mode -eq "DateTime") {
                    $timeY = $self.Y + $self.Height - 2
                    $timeStr = $self.SelectedDate.ToString("HH:mm")
                    Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" `
                        -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "CalendarPicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $date = $self.SelectedDate
                $viewDate = $self.ViewDate
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            # Previous month
                            $self.ViewDate = $viewDate.AddMonths(-1)
                        } else {
                            # Previous day
                            $date = $date.AddDays(-1)
                            if ($date.Month -ne $viewDate.Month) {
                                $self.ViewDate = $date
                            }
                        }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            # Next month
                            $self.ViewDate = $viewDate.AddMonths(1)
                        } else {
                            # Next day
                            $date = $date.AddDays(1)
                            if ($date.Month -ne $viewDate.Month) {
                                $self.ViewDate = $date
                            }
                        }
                    }
                    ([ConsoleKey]::UpArrow) {
                        $date = $date.AddDays(-7)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        $date = $date.AddDays(7)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                    ([ConsoleKey]::PageUp) {
                        $self.ViewDate = $viewDate.AddMonths(-1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                            -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::PageDown) {
                        $self.ViewDate = $viewDate.AddMonths(1)
                        $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                            -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                    }
                    ([ConsoleKey]::Home) {
                        $date = Get-Date
                        $self.ViewDate = $date
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSelect) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSelect" -ScriptBlock {
                                & $self.OnSelect -Date $date
                            } -AdditionalData @{ Component = $self.Name; SelectedDate = $date }
                        }
                    }
                    default {
                        $handled = $false
                    }
                }
                
                if ($handled) {
                    $self.SelectedDate = $date
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $date
                        } -AdditionalData @{ Component = $self.Name; NewValue = $date }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "CalendarPicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function global:New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        Value = $Props.Value
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Type to search..." }
        MaxDisplayItems = if ($null -ne $Props.MaxDisplayItems) { $Props.MaxDisplayItems } else { 5 }
        AllowCustomValue = if ($null -ne $Props.AllowCustomValue) { $Props.AllowCustomValue } else { $false }
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Main dropdown box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor
                
                # Display text
                $displayText = ""
                if ($self.IsOpen) {
                    $displayText = $self.SearchText
                    if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                        $displayText = $self.Placeholder
                    }
                } else {
                    if ($self.Value) {
                        $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                        if ($selected) {
                            $displayText = $selected.Display
                        } else {
                            $displayText = $self.Value.ToString()
                        }
                    } else {
                        $displayText = "Select..."
                    }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                # Dropdown indicator
                $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator `
                    -ForegroundColor $borderColor
                
                # Cursor for search mode
                if ($self.IsOpen -and $self.IsFocused) {
                    $cursorX = $self.X + 2 + $self.SearchText.Length
                    if ($cursorX -lt ($self.X + $self.Width - 3)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                            -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Options dropdown
                if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                    $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                    Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $startIdx = 0
                    if ($self.SelectedIndex -ge $self.MaxDisplayItems) {
                        $startIdx = $self.SelectedIndex - $self.MaxDisplayItems + 1
                    }
                    
                    $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                    
                    for ($i = $startIdx; $i -le $endIdx; $i++) {
                        $option = $self.FilteredOptions[$i]
                        $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                        
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $fg = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                        $bg = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                        
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) {
                            $text = $text.Substring(0, $self.Width - 7) + "..."
                        }
                        
                        # Highlight matching text
                        if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                            $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                            if ($matchIndex -ge 0) {
                                # Draw text before match
                                if ($matchIndex -gt 0) {
                                    Write-BufferString -X ($self.X + 2) -Y $y `
                                        -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg
                                }
                                
                                # Draw matching text highlighted
                                Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y `
                                    -Text $text.Substring($matchIndex, $self.SearchText.Length) `
                                    -ForegroundColor (Get-ThemeColor "Warning")
                                
                                # Draw text after match
                                $afterMatch = $matchIndex + $self.SearchText.Length
                                if ($afterMatch -lt $text.Length) {
                                    Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y `
                                        -Text $text.Substring($afterMatch) -ForegroundColor $fg
                                }
                                
                                continue
                            }
                        }
                        
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text `
                            -ForegroundColor $fg -BackgroundColor $bg
                    }
                    
                    # Scrollbar if needed
                    if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                        $scrollHeight = $self.MaxDisplayItems
                        $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                        
                        for ($i = 0; $i -lt $scrollHeight; $i++) {
                            $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                            $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                            Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) `
                                -Text $char -ForegroundColor $color
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        FilterOptions = {
            try {
                if ([string]::IsNullOrEmpty($this.SearchText)) {
                    $this.FilteredOptions = $this.Options
                } else {
                    $this.FilteredOptions = @($this.Options | Where-Object {
                        $_.Display -like "*$($this.SearchText)*"
                    })
                    
                    # Add custom value option if allowed and no exact match
                    if ($this.AllowCustomValue) {
                        $exactMatch = $this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText }
                        if (-not $exactMatch) {
                            $this.FilteredOptions = @(@{
                                Display = $this.SearchText
                                Value = $this.SearchText
                                IsCustom = $true
                            }) + $this.FilteredOptions
                        }
                    }
                }
                
                # Reset selection to first item
                $this.SelectedIndex = 0
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown FilterOptions error for '$($this.Name)': $_" -Data @{ Component = $this.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    switch ($Key.Key) {
                        { $_ -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow) } {
                            $self.IsOpen = $true
                            $self.SearchText = ""
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                    return $false
                }
                
                # Handle open dropdown
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) {
                        $self.IsOpen = $false
                        $self.SearchText = ""
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.FilteredOptions.Count -gt 0) {
                            $selected = $self.FilteredOptions[$self.SelectedIndex]
                            if ($self.OnChange) {
                                Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                    & $self.OnChange -NewValue $selected.Value -Option $selected
                                } -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value; Option = $selected }
                            }
                            $self.Value = $selected.Value
                            $self.IsOpen = $false
                            $self.SearchText = ""
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::UpArrow) {
                        if ($self.SelectedIndex -gt 0) {
                            $self.SelectedIndex--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) {
                            $self.SelectedIndex++
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.SearchText.Length -gt 0) {
                            $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                            & $self.FilterOptions
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.SearchText += $Key.KeyChar
                            & $self.FilterOptions
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "SearchableDropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function global:New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        SelectedValues = if ($null -ne $Props.SelectedValues) { $Props.SelectedValues } else { @() }
        Title = if ($null -ne $Props.Title) { $Props.Title } else { "Select items" }
        AllowSelectAll = if ($null -ne $Props.AllowSelectAll) { $Props.AllowSelectAll } else { $true }
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        OnSubmit = $Props.OnSubmit
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " $($self.Title) "
                
                # Select all option
                $currentY = $self.Y + 1
                if ($self.AllowSelectAll) {
                    $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                    $checkbox = if ($allSelected) { "[X]" } else { "[ ]" }
                    $fg = if ($self.SelectedIndex -eq -1) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" `
                        -ForegroundColor $fg
                    $currentY += 2
                }
                
                # Options
                $visibleHeight = $self.Height - 4
                if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.Options[$i]
                    $isChecked = $self.SelectedValues -contains $option.Value
                    $isHighlighted = ($i -eq $self.SelectedIndex)
                    
                    $checkbox = if ($isChecked) { "[X]" } else { "[ ]" }
                    $fg = if ($isHighlighted) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                    
                    $text = "$checkbox $($option.Display)"
                    if ($text.Length -gt ($self.Width - 4)) {
                        $text = $text.Substring(0, $self.Width - 7) + "..."
                    }
                    
                    Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                    $currentY++
                }
                
                # Status line
                $statusY = $self.Y + $self.Height - 2
                $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
                Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText `
                    -ForegroundColor (Get-ThemeColor "Subtle")
            } catch {
                Write-Log -Level Error -Message "MultiSelect Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $maxIndex = $self.Options.Count - 1
                if ($self.AllowSelectAll) { $maxIndex++ }
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) {
                            $self.SelectedIndex = -1
                        } elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                            $self.SelectedIndex--
                            if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) {
                                $self.ScrollOffset = $self.SelectedIndex
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                            $self.SelectedIndex++
                            $visibleHeight = $self.Height - 4
                            if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                            if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) {
                                $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1
                            }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                            # Toggle all
                            if ($self.SelectedValues.Count -eq $self.Options.Count) {
                                $self.SelectedValues = @()
                            } else {
                                $self.SelectedValues = @($self.Options | ForEach-Object { $_.Value })
                            }
                        } elseif ($self.SelectedIndex -ge 0) {
                            # Toggle individual
                            $option = $self.Options[$self.SelectedIndex]
                            if ($self.SelectedValues -contains $option.Value) {
                                $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $option.Value })
                            } else {
                                $self.SelectedValues += $option.Value
                            }
                        }
                        
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -SelectedValues $self.SelectedValues
                            } -AdditionalData @{ Component = $self.Name; SelectedValues = $self.SelectedValues }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.OnSubmit) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnSubmit" -ScriptBlock {
                                & $self.OnSubmit -SelectedValues $self.SelectedValues
                            } -AdditionalData @{ Component = $self.Name; SelectedValues = $self.SelectedValues }
                        }
                        return $true
                    }
                }
            } catch {
                Write-Log -Level Error -Message "MultiSelect HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function global:New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Min = if ($null -ne $Props.Min) { $Props.Min } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        Step = if ($null -ne $Props.Step) { $Props.Step } else { 1 }
        DecimalPlaces = if ($null -ne $Props.DecimalPlaces) { $Props.DecimalPlaces } else { 0 }
        IsFocusable = $true
        TextValue = (if ($null -ne $Props.Value) { $Props.Value } else { 0 }).ToString()
        CursorPosition = 0
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $borderColor = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor
                
                # Value display
                $displayValue = $self.TextValue
                if ($displayValue.Length -gt ($self.Width - 6)) {
                    $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..."
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
                
                # Cursor
                if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    if ($cursorX -lt ($self.X + $self.Width - 4)) {
                        Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                            -BackgroundColor (Get-ThemeColor "Accent")
                    }
                }
                
                # Spinner buttons
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" `
                    -ForegroundColor $borderColor
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" `
                    -ForegroundColor $borderColor
                
                # Min/Max indicators
                if ($self.Value -le $self.Min) {
                    Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" `
                        -ForegroundColor (Get-ThemeColor "Warning")
                }
                if ($self.Value -ge $self.Max) {
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" `
                        -ForegroundColor (Get-ThemeColor "Warning")
                }
            } catch {
                Write-Log -Level Error -Message "NumberInput Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                
                if ($this.DecimalPlaces -eq 0) {
                    $newValue = [Math]::Floor($newValue)
                } else {
                    $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
                }
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) {
                    Invoke-WithErrorHandling -Component "$($this.Name).OnChange" -ScriptBlock {
                        & $this.OnChange -NewValue $newValue
                    } -AdditionalData @{ Component = $this.Name; NewValue = $newValue }
                }
                
                return $true
            } catch {
                # Invalid input, restore previous value
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                Write-Log -Level Warning -Message "NumberInput ValidateAndUpdate error for '$($this.Name)': $_" -Data @{ Component = $this.Name; InputText = $this.TextValue; Exception = $_ }
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                        $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                        $self.CursorPosition = $self.TextValue.Length
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -NewValue $self.Value
                            } -AdditionalData @{ Component = $self.Name; NewValue = $self.Value }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::DownArrow) {
                        $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                        $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                        $self.CursorPosition = $self.TextValue.Length
                        if ($self.OnChange) {
                            Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                                & $self.OnChange -NewValue $self.Value
                            } -AdditionalData @{ Component = $self.Name; NewValue = $self.Value }
                        }
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.TextValue.Length) {
                            $self.CursorPosition++
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.TextValue.Length
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.CursorPosition -gt 0) {
                            $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.TextValue.Length) {
                            $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1)
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        & $self.ValidateAndUpdate -self $self
                        Request-TuiRefresh
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                            $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "NumberInput HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

function global:New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 30 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 50 }
        Min = if ($null -ne $Props.Min) { $Props.Min } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        Step = if ($null -ne $Props.Step) { $Props.Step } else { 1 }
        ShowValue = if ($null -ne $Props.ShowValue) { $Props.ShowValue } else { $true }
        IsFocusable = $true
        Name = $Props.Name
        OnChange = $Props.OnChange
        
        Render = {
            param($self)
            try {
                $fg = if ($self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                }
                
                # Calculate position
                $range = $self.Max - $self.Min
                $percent = ($self.Value - $self.Min) / $range
                $trackWidth = $self.Width - 2
                $thumbPos = [Math]::Floor($trackWidth * $percent)
                
                # Draw track
                $track = "─" * $trackWidth
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $track -ForegroundColor (Get-ThemeColor "Subtle")
                
                # Draw filled portion
                if ($thumbPos -gt 0) {
                    $filled = "═" * $thumbPos
                    Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $filled -ForegroundColor $fg
                }
                
                # Draw thumb
                Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
                
                # Draw bounds
                Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
                Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
                
                # Show value
                if ($self.ShowValue) {
                    $valueText = $self.Value.ToString()
                    $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                    Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
                }
            } catch {
                Write-Log -Level Error -Message "Slider Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $oldValue = $self.Value
                
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                    }
                    ([ConsoleKey]::RightArrow) {
                        $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                    }
                    ([ConsoleKey]::Home) {
                        $self.Value = $self.Min
                    }
                    ([ConsoleKey]::End) {
                        $self.Value = $self.Max
                    }
                    ([ConsoleKey]::PageDown) {
                        $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                        $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep)
                    }
                    ([ConsoleKey]::PageUp) {
                        $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                        $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep)
                    }
                    default {
                        $handled = $false
                    }
                }
                
                if ($handled -and $self.Value -ne $oldValue) {
                    if ($self.OnChange) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -ScriptBlock {
                            & $self.OnChange -NewValue $self.Value
                        } -AdditionalData @{ Component = $self.Name; NewValue = $self.Value }
                    }
                    Request-TuiRefresh
                }
                
                return $handled
            } catch {
                Write-Log -Level Error -Message "Slider HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiCalendarPicker',
    'New-TuiSearchableDropdown',
    'New-TuiMultiSelect',
    'New-TuiNumberInput',
    'New-TuiSlider'
)


####\components\navigation-class.psm1
# Navigation Component Classes Module for PMC Terminal v5
# Implements navigation menu functionality with keyboard shortcuts
# AI: Implements Phase 2.2 of the class migration plan - Navigation Component

# Import base classes
using module '.\ui-classes.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"



# Import utilities for error handling
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# NavigationItem - Represents a single menu item
class NavigationItem {
    [string] $Key
    [string] $Label
    [scriptblock] $Action
    [bool] $Enabled = $true
    [bool] $Visible = $true
    [string] $Description = ""
    [ConsoleColor] $KeyColor = [ConsoleColor]::Yellow
    [ConsoleColor] $LabelColor = [ConsoleColor]::White
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) {
            throw [System.ArgumentException]::new("Navigation key cannot be null or empty")
        }
        if ([string]::IsNullOrWhiteSpace($label)) {
            throw [System.ArgumentException]::new("Navigation label cannot be null or empty")
        }
        if ($null -eq $action) {
            throw [System.ArgumentNullException]::new("action", "Navigation action cannot be null")
        }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }
    
    # AI: Execute the action with error handling
    [void] Execute() {
        if (-not $this.Enabled) {
            Write-Log -Level Warning -Message "Attempted to execute disabled navigation item: $($this.Key)" -Component "NavigationItem"
            return
        }
        
        try {
            Write-Log -Level Debug -Message "Executing navigation item: $($this.Key) - $($this.Label)" -Component "NavigationItem"
            & $this.Action
        }
        catch {
            Write-Log -Level Error -Message "Navigation action failed for item '$($this.Key)': $_" -Component "NavigationItem"
            throw
        }
    }
    
    # AI: Format the menu item for display
    [string] FormatDisplay([bool]$showDescription = $false) {
        $display = [System.Text.StringBuilder]::new()
        
        # Key with brackets
        [void]$display.Append($this.SetColor($this.KeyColor))
        [void]$display.Append("[$($this.Key)]")
        [void]$display.Append($this.ResetColor())
        
        # Label
        [void]$display.Append(" ")
        
        if ($this.Enabled) {
            [void]$display.Append($this.SetColor($this.LabelColor))
            [void]$display.Append($this.Label)
        }
        else {
            [void]$display.Append($this.SetColor([ConsoleColor]::DarkGray))
            [void]$display.Append($this.Label)
            [void]$display.Append(" (Disabled)")
        }
        
        [void]$display.Append($this.ResetColor())
        
        # Description if requested
        if ($showDescription -and -not [string]::IsNullOrWhiteSpace($this.Description)) {
            [void]$display.Append(" - ")
            [void]$display.Append($this.SetColor([ConsoleColor]::Gray))
            [void]$display.Append($this.Description)
            [void]$display.Append($this.ResetColor())
        }
        
        return $display.ToString()
    }
    
    # AI: Helper methods for ANSI colors
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# NavigationMenu - Component for displaying and handling navigation options
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]] $Items
    [hashtable] $Services
    [string] $Orientation = "Horizontal" # Horizontal or Vertical
    [string] $Separator = "  |  "
    [bool] $ShowDescriptions = $false
    [ConsoleColor] $SeparatorColor = [ConsoleColor]::DarkGray
    
    NavigationMenu([string]$name, [hashtable]$services) : base($name) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        
        $this.Services = $services
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
    }
    
    [void] AddItem([NavigationItem]$item) {
        if ($null -eq $item) {
            throw [System.ArgumentNullException]::new("item", "NavigationItem cannot be null")
        }
        
        # AI: Check for duplicate keys
        $existingItem = $this.Items | Where-Object { $_.Key -eq $item.Key } | Select-Object -First 1
        if ($null -ne $existingItem) {
            throw [System.InvalidOperationException]::new("Navigation item with key '$($item.Key)' already exists")
        }
        
        $this.Items.Add($item)
    }
    
    [void] RemoveItem([string]$key) {
        $item = $this.Items | Where-Object { $_.Key -eq $key.ToUpper() } | Select-Object -First 1
        if ($null -ne $item) {
            [void]$this.Items.Remove($item)
        }
    }
    
    [void] EnableItem([string]$key, [bool]$enabled = $true) {
        $item = $this.GetItem($key)
        if ($null -ne $item) {
            $item.Enabled = $enabled
        }
    }
    
    [void] ShowItem([string]$key, [bool]$visible = $true) {
        $item = $this.GetItem($key)
        if ($null -ne $item) {
            $item.Visible = $visible
        }
    }
    
    [NavigationItem] GetItem([string]$key) {
        return $this.Items | Where-Object { $_.Key -eq $key.ToUpper() } | Select-Object -First 1
    }
    
    [void] ExecuteAction([string]$key) {
        $item = $this.GetItem($key)
        
        if ($null -eq $item) {
            Write-Log -Level Debug -Message "Navigation key '$key' not found" -Component "NavigationMenu"
            return
        }
        
        if (-not $item.Visible) {
            Write-Log -Level Debug -Message "Navigation item '$key' is not visible" -Component "NavigationMenu"
            return
        }
        
        Invoke-WithErrorHandling -Component "NavigationMenu" -Context "ExecuteAction:$key" -ScriptBlock {
            $item.Execute()
        }
    }
    
    [void] AddSeparator() {
        # AI: Add a special separator item
        $separatorItem = [NavigationItem]::new("-", "---", {})
        $separatorItem.Visible = $true
        $separatorItem.Enabled = $false
        $this.Items.Add($separatorItem)
    }
    
    # AI: Build navigation menu with context-aware items
    [void] BuildContextMenu([string]$context) {
        $this.Items.Clear()
        
        switch ($context) {
            "Dashboard" {
                $this.AddItem([NavigationItem]::new("N", "New Task", {
                    $this.Services.Navigation.PushScreen("NewTaskScreen")
                }))
                
                $this.AddItem([NavigationItem]::new("P", "Projects", {
                    $this.Services.Navigation.PushScreen("ProjectListScreen")
                }))
                
                $this.AddItem([NavigationItem]::new("S", "Settings", {
                    $this.Services.Navigation.PushScreen("SettingsScreen")
                }))
                
                $this.AddSeparator()
                
                $this.AddItem([NavigationItem]::new("Q", "Quit", {
                    $this.Services.AppState.RequestExit()
                }))
            }
            
            "TaskList" {
                $this.AddItem([NavigationItem]::new("N", "New", {
                    $this.Services.Navigation.PushScreen("NewTaskScreen")
                }))
                
                $this.AddItem([NavigationItem]::new("E", "Edit", {
                    # Context-specific logic would go here
                }))
                
                $this.AddItem([NavigationItem]::new("D", "Delete", {
                    # Context-specific logic would go here
                }))
                
                $this.AddItem([NavigationItem]::new("F", "Filter", {
                    $this.Services.Navigation.PushScreen("FilterScreen")
                }))
                
                $this.AddSeparator()
                
                $this.AddItem([NavigationItem]::new("B", "Back", {
                    $this.Services.Navigation.PopScreen()
                }))
            }
            
            default {
                # Default navigation for unknown contexts
                $this.AddItem([NavigationItem]::new("B", "Back", {
                    $this.Services.Navigation.PopScreen()
                }))
                
                $this.AddItem([NavigationItem]::new("H", "Home", {
                    $this.Services.Navigation.NavigateToRoot()
                }))
            }
        }
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "NavigationMenu" -Context "Render:$($this.Name)" -ScriptBlock {
            $menuBuilder = [System.Text.StringBuilder]::new()
            
            $visibleItems = $this.Items | Where-Object { $_.Visible }
            
            if ($visibleItems.Count -eq 0) {
                return ""
            }
            
            if ($this.Orientation -eq "Horizontal") {
                $this.RenderHorizontal($menuBuilder, $visibleItems)
            }
            else {
                $this.RenderVertical($menuBuilder, $visibleItems)
            }
            
            return $menuBuilder.ToString()
        }
    }
    
    hidden [void] RenderHorizontal([System.Text.StringBuilder]$builder, [object[]]$items) {
        $isFirst = $true
        
        foreach ($item in $items) {
            if (-not $isFirst) {
                [void]$builder.Append($this.SetColor($this.SeparatorColor))
                [void]$builder.Append($this.Separator)
                [void]$builder.Append($this.ResetColor())
            }
            
            [void]$builder.Append($item.FormatDisplay($this.ShowDescriptions))
            $isFirst = $false
        }
    }
    
    hidden [void] RenderVertical([System.Text.StringBuilder]$builder, [object[]]$items) {
        foreach ($item in $items) {
            [void]$builder.AppendLine($item.FormatDisplay($this.ShowDescriptions))
        }
    }
    
    # AI: Helper methods for ANSI colors
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\components\panel-classes.psm1
# (Keep all other functions in tui-engine-v2.psm1 the same)

# ==============================================================================
# === FINAL, UNIFIED RENDER-FRAME IMPLEMENTATION ===============================
# ==============================================================================
function Render-Frame {
    try {
        # --- 1. Preparation ---
        $bgColor = Get-ThemeColor "Background" -Default ([ConsoleColor]::Black)
        Clear-BackBuffer -BackgroundColor $bgColor
        
        # --- 2. Component Collection ---
        $renderQueue = [System.Collections.Generic.List[object]]::new()
        $script:collectComponents = {
            param($component)
            if (-not $component -or -not $component.Visible) { return }
            
            $renderQueue.Add($component)
            
            if ($component.Children -and $component.Children.Count -gt 0) {
                if ($component.CalculateLayout) {
                    try { & $component.CalculateLayout -self $component } catch { Write-Log -Level Error -Message "Layout failed for '$($component.Name)'" -Data $_ }
                }
                foreach ($child in $component.Children) { & $script:collectComponents $child }
            }
        }

        # Start collection from the active screen and any dialogs
        if ($script:TuiState.CurrentScreen) { & $script:collectComponents -component $script:TuiState.CurrentScreen }
        if ((Get-Command -Name "Get-CurrentDialog" -ErrorAction SilentlyContinue) -and ($dialog = Get-CurrentDialog)) {
             & $script:collectComponents -component $dialog
        }

        # --- 3. Sorting ---
        # Sort by Z-Index to ensure proper layering (e.g., dialogs on top).
        $sortedQueue = $renderQueue | Sort-Object { $_.ZIndex ?? 0 }

        # --- 4. The Unified Rendering Loop ---
        foreach ($component in $sortedQueue) {
            if (-not $component.Render) { continue }
            
            # This is the core architectural decision point.
            if ($component -is [UIElement]) {
                # PATTERN A: Class-Based Component (returns a string)
                # The engine is responsible for placing the component's output.
                $componentOutput = $component.Render() # This calls the safe base Render()
                if (-not [string]::IsNullOrEmpty($componentOutput)) {
                    $lines = $componentOutput.Split([Environment]::NewLine)
                    for ($i = 0; $i -lt $lines.Count; $i++) {
                        Write-BufferString -X $component.X -Y ($component.Y + $i) -Text $lines[$i]
                    }
                }
            } else {
                # PATTERN B: Functional Component (calls Write-BufferString itself)
                # We simply invoke its Render method and let it draw itself.
                Invoke-WithErrorHandling -Component "$($component.Name ?? $component.Type).Render" -Context "Functional Render" -ScriptBlock {
                    & $component.Render -self $component
                }
            }
        }
        
        # --- 5. Final Draw ---
        Render-BufferOptimized
        [Console]::SetCursorPosition($script:TuiState.BufferWidth - 1, $script:TuiState.BufferHeight - 1)

    } catch {
        Write-Warning "Fatal Frame render error: $_"
    }
}

# (Keep all other functions in tui-engine-v2.psm1 the same)


####\components\table-class.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Navigation Menu Component
# Provides a reusable menu component driven by keyboard shortcuts.
# ==============================================================================

# Import base classes this module extends
using module '.\ui-classes.psm1'

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import utilities
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# --- NavigationItem Class ---
# Represents a single, executable item within a NavigationMenu.
class NavigationItem {
    [string]$Key
    [string]$Label
    [scriptblock]$Action
    [bool]$Enabled = $true
    
    NavigationItem([string]$key, [string]$label, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($key)) { throw [System.ArgumentException]::new("key") }
        if ([string]::IsNullOrWhiteSpace($label)) { throw [System.ArgumentException]::new("label") }
        if (-not $action) { throw [System.ArgumentNullException]::new("action") }
        
        $this.Key = $key.ToUpper()
        $this.Label = $label
        $this.Action = $action
    }

    [void] Execute() {
        if (-not $this.Enabled) { return }
        Invoke-WithErrorHandling -Component "NavigationItem" -Context "Execute:$($this.Key)" -ScriptBlock {
            & $this.Action
        }
    }
}

# --- NavigationMenu Class ---
# A component that renders a list of NavigationItems and executes their actions.
class NavigationMenu : Component {
    [System.Collections.Generic.List[NavigationItem]]$Items
    [string]$Orientation = "Horizontal" # 'Horizontal' or 'Vertical'
    [string]$Separator = " | "

    NavigationMenu([string]$name) : base($name) {
        $this.Items = [System.Collections.Generic.List[NavigationItem]]::new()
    }

    [void] AddItem([NavigationItem]$item) {
        if (-not $item) { throw [System.ArgumentNullException]::new("item") }
        $this.Items.Add($item)
    }

    [void] ExecuteActionByKey([string]$key) {
        $item = $this.Items.Find({ param($i) $i.Key -eq $key.ToUpper() })
        if ($item) { $item.Execute() }
    }

    # AI: Implements the abstract _RenderContent from UIElement.
    hidden [string] _RenderContent() {
        $sb = [System.Text.StringBuilder]::new()
        $visibleItems = $this.Items | Where-Object { $_.Visible -ne $false }

        if ($this.Orientation -eq "Horizontal") {
            $line = $visibleItems.ForEach({
                $text = if ($_.Enabled) { "[$($_.Key)]$($_.Label)" } else { "(dim)[$($_.Key)]$($_.Label)(/dim)" }
                $text
            }) -join $this.Separator
            [void]$sb.Append($line)
        } else {
            foreach ($item in $visibleItems) {
                $text = if ($item.Enabled) { "[$($item.Key)] $($item.Label)" } else { "(dim)[$($item.Key)] $($item.Label)(/dim)" }
                [void]$sb.AppendLine($text)
            }
        }
        return $sb.ToString()
    }
}


####\components\tui-components.psm1
# TUI Component Library - COMPLIANT VERSION
# Stateful component factories following the canonical architecture
# LEGACY New-TuiPanel has been REMOVED.

#region Basic Components

function global:New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Label"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        ForegroundColor = $Props.ForegroundColor
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $fg = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Primary" }
                Write-BufferString -X $self.X -Y $self.Y -Text $self.Text -ForegroundColor $fg
            } catch {
                Write-Log -Level Error -Message "Label Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "Label HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiButton {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Button"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 10 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Button" }
        Name = $Props.Name
        
        # Internal State
        IsPressed = $false
        
        # Event Handlers (from Props)
        OnClick = $Props.OnClick
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                $bgColor = if ($self.IsPressed) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                $fgColor = if ($self.IsPressed) { Get-ThemeColor "Background" } else { $borderColor }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor $bgColor
                    
                $textX = $self.X + [Math]::Floor(($self.Width - $self.Text.Length) / 2)
                Write-BufferString -X $textX -Y ($self.Y + 1) -Text $self.Text `
                    -ForegroundColor $fgColor -BackgroundColor $bgColor
            } catch {
                Write-Log -Level Error -Message "Button Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    if ($self.OnClick) {
                        Invoke-WithErrorHandling -Component "$($self.Name).OnClick" -Context "OnClick" -AdditionalData @{ Component = $self.Name; Key = $Key } -ScriptBlock {
                            & $self.OnClick
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "Button HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "" }
        MaxLength = if ($null -ne $Props.MaxLength) { $Props.MaxLength } else { 100 }
        Name = $Props.Name
        
        # Internal State
        CursorPosition = if ($null -ne $Props.CursorPosition) { $Props.CursorPosition } else { 0 }
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = if ($self.Text) { $self.Text } else { "" }
                if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) { 
                    $displayText = if ($self.Placeholder) { $self.Placeholder } else { "" }
                }
                
                $maxDisplayLength = $self.Width - 4
                if ($displayText.Length -gt $maxDisplayLength) {
                    $displayText = $displayText.Substring(0, $maxDisplayLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                
                if ($self.IsFocused -and $self.CursorPosition -le $displayText.Length) {
                    $cursorX = $self.X + 2 + $self.CursorPosition
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            } catch {
                Write-Log -Level Error -Message "TextBox Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $text = if ($self.Text) { $self.Text } else { "" }
                $cursorPos = if ($null -ne $self.CursorPosition) { $self.CursorPosition } else { 0 }
                $oldText = $text
                
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) { 
                        if ($cursorPos -gt 0) { 
                            $text = $text.Remove($cursorPos - 1, 1)
                            $cursorPos-- 
                        }
                    }
                    ([ConsoleKey]::Delete) { 
                        if ($cursorPos -lt $text.Length) { 
                            $text = $text.Remove($cursorPos, 1) 
                        }
                    }
                    ([ConsoleKey]::LeftArrow) { 
                        if ($cursorPos -gt 0) { $cursorPos-- }
                    }
                    ([ConsoleKey]::RightArrow) { 
                        if ($cursorPos -lt $text.Length) { $cursorPos++ }
                    }
                    ([ConsoleKey]::Home) { $cursorPos = 0 }
                    ([ConsoleKey]::End) { $cursorPos = $text.Length }
                    ([ConsoleKey]::V) {
                        # Handle Ctrl+V (paste)
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                # Get clipboard text (Windows only)
                                $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                    Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                } else {
                                    $null
                                }
                                
                                if ($clipboardText) {
                                    # Remove newlines for single-line textbox
                                    $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                    
                                    # Insert as much as will fit
                                    $remainingSpace = $self.MaxLength - $text.Length
                                    if ($remainingSpace -gt 0) {
                                        $toInsert = if ($clipboardText.Length -gt $remainingSpace) {
                                            $clipboardText.Substring(0, $remainingSpace)
                                        } else {
                                            $clipboardText
                                        }
                                        
                                        $text = $text.Insert($cursorPos, $toInsert)
                                        $cursorPos += $toInsert.Length
                                    }
                                }
                            } catch {
                                # Silently ignore clipboard errors
                                Write-Log -Level Warning -Message "TextBox clipboard paste error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
                            }
                        } else {
                            # Regular 'V' key
                            if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                                $text = $text.Insert($cursorPos, $Key.KeyChar)
                                $cursorPos++
                            } else {
                                return $false
                            }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                            $text = $text.Insert($cursorPos, $Key.KeyChar)
                            $cursorPos++
                        } else { 
                            return $false 
                        }
                    }
                }
                
                if ($text -ne $oldText -or $cursorPos -ne $self.CursorPosition) {
                    $self.Text = $text
                    $self.CursorPosition = $cursorPos
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $text } -ScriptBlock {
                            & $self.OnChange -NewValue $text
                        }
                    }
                    Request-TuiRefresh
                }
                return $true
            } catch {
                Write-Log -Level Error -Message "TextBox HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "CheckBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "Checkbox" }
        Checked = if ($null -ne $Props.Checked) { $Props.Checked } else { $false }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $fg = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                $checkbox = if ($self.Checked) { "[X]" } else { "[ ]" }
                Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
            } catch {
                Write-Log -Level Error -Message "CheckBox Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                    $self.Checked = -not $self.Checked
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $self.Checked } -ScriptBlock {
                            & $self.OnChange -NewValue $self.Checked 
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "CheckBox HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Dropdown"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 10 }
        Options = if ($null -ne $Props.Options) { $Props.Options } else { @() }
        Value = $Props.Value
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Select..." }
        Name = $Props.Name
        
        # Internal State
        IsOpen = $false
        SelectedIndex = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                $displayText = $self.Placeholder
                if ($self.Value -and $self.Options) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) { $displayText = $selected.Display }
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
                $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
                Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
                
                if ($self.IsOpen -and $self.Options.Count -gt 0) {
                    $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                    Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight `
                        -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                    
                    $displayCount = [Math]::Min($self.Options.Count, 6)
                    for ($i = 0; $i -lt $displayCount; $i++) {
                        $option = $self.Options[$i]
                        $y = $self.Y + 4 + $i
                        $fg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                        $bg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Secondary" } else { Get-ThemeColor "Background" }
                        $text = $option.Display
                        if ($text.Length -gt ($self.Width - 4)) { 
                            $text = $text.Substring(0, $self.Width - 7) + "..." 
                        }
                        Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Dropdown Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if (-not $self.IsOpen) {
                    if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                        $self.IsOpen = $true
                        Request-TuiRefresh
                        return $true
                    }
                } else {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) { 
                            if ($self.SelectedIndex -gt 0) { 
                                $self.SelectedIndex--
                                Request-TuiRefresh 
                            }
                            return $true 
                        }
                        ([ConsoleKey]::DownArrow) { 
                            if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { 
                                $self.SelectedIndex++
                                Request-TuiRefresh 
                            }
                            return $true 
                        }
                        ([ConsoleKey]::Enter) {
                            if ($self.Options.Count -gt 0) {
                                $selected = $self.Options[$self.SelectedIndex]
                                $self.Value = $selected.Value
                                
                                if ($self.OnChange) { 
                                    Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $selected.Value } -ScriptBlock {
                                        & $self.OnChange -NewValue $selected.Value 
                                    }
                                }
                            }
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Escape) { 
                            $self.IsOpen = $false
                            Request-TuiRefresh
                            return $true 
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Dropdown HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $false
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "ProgressBar"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 1 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { 0 }
        Max = if ($null -ne $Props.Max) { $Props.Max } else { 100 }
        ShowPercent = if ($null -ne $Props.ShowPercent) { $Props.ShowPercent } else { $false }
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
                $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
                $empty = ($self.Width - 2) - $filled
                
                $bar = "█" * $filled + "░" * $empty
                Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
                
                if ($self.ShowPercent) {
                    $percentText = "$([Math]::Round($percent))%"
                    $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
                }
            } catch {
                Write-Log -Level Error -Message "ProgressBar Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "ProgressBar HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextArea"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 6 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Text = if ($null -ne $Props.Text) { $Props.Text } else { "" }
        Placeholder = if ($null -ne $Props.Placeholder) { $Props.Placeholder } else { "Enter text..." }
        WrapText = if ($null -ne $Props.WrapText) { $Props.WrapText } else { $true }
        Name = $Props.Name
        
        # Internal State
        Lines = @()
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $innerWidth = $self.Width - 4
                $innerHeight = $self.Height - 2
                $displayLines = @()
                if ($self.Lines.Count -eq 0) { $self.Lines = @("") }
                
                foreach ($line in $self.Lines) {
                    if ($self.WrapText -and $line.Length -gt $innerWidth) {
                        for ($i = 0; $i -lt $line.Length; $i += $innerWidth) {
                            $displayLines += $line.Substring($i, [Math]::Min($innerWidth, $line.Length - $i))
                        }
                    } else { 
                        $displayLines += $line 
                    }
                }
                
                if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                    Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                    return
                }
                
                $startLine = $self.ScrollOffset
                $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
                
                for ($i = $startLine; $i -le $endLine; $i++) {
                    $y = $self.Y + 1 + ($i - $startLine)
                    $line = $displayLines[$i]
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $line
                }
                
                if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                    $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                    $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                    Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
                
                if ($displayLines.Count -gt $innerHeight) {
                    $scrollbarHeight = $innerHeight
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "TextArea Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $lines = $self.Lines
                $cursorY = $self.CursorY
                $cursorX = $self.CursorX
                $innerHeight = $self.Height - 2
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) {
                        if ($cursorY -gt 0) {
                            $cursorY--
                            $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                            if ($cursorY -lt $self.ScrollOffset) { 
                                $self.ScrollOffset = $cursorY 
                            }
                        }
                    }
                    ([ConsoleKey]::DownArrow) {
                        if ($cursorY -lt $lines.Count - 1) {
                            $cursorY++
                            $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                            if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                $self.ScrollOffset = $cursorY - $innerHeight + 1 
                            }
                        }
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($cursorX -gt 0) { 
                            $cursorX-- 
                        } elseif ($cursorY -gt 0) { 
                            $cursorY--
                            $cursorX = $lines[$cursorY].Length 
                        }
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($cursorX -lt $lines[$cursorY].Length) { 
                            $cursorX++ 
                        } elseif ($cursorY -lt $lines.Count - 1) { 
                            $cursorY++
                            $cursorX = 0 
                        }
                    }
                    ([ConsoleKey]::Home) { $cursorX = 0 }
                    ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                    ([ConsoleKey]::Enter) {
                        $currentLine = $lines[$cursorY]
                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                        $afterCursor = $currentLine.Substring($cursorX)
                        $lines[$cursorY] = $beforeCursor
                        $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                        $cursorY++
                        $cursorX = 0
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                            $self.ScrollOffset = $cursorY - $innerHeight + 1 
                        }
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($cursorX -gt 0) { 
                            $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1)
                            $cursorX-- 
                        } elseif ($cursorY -gt 0) {
                            $prevLineLength = $lines[$cursorY - 1].Length
                            $lines[$cursorY - 1] += $lines[$cursorY]
                            $newLines = @()
                            for ($i = 0; $i -lt $lines.Count; $i++) { 
                                if ($i -ne $cursorY) { $newLines += $lines[$i] } 
                            }
                            $lines = $newLines
                            $cursorY--
                            $cursorX = $prevLineLength
                        }
                    }
                    ([ConsoleKey]::Delete) {
                        if ($cursorX -lt $lines[$cursorY].Length) { 
                            $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) 
                        } elseif ($cursorY -lt $lines.Count - 1) {
                            $lines[$cursorY] += $lines[$cursorY + 1]
                            $newLines = @()
                            for ($i = 0; $i -lt $lines.Count; $i++) { 
                                if ($i -ne ($cursorY + 1)) { $newLines += $lines[$i] } 
                            }
                            $lines = $newLines
                        }
                    }
                    ([ConsoleKey]::V) {
                        # Handle Ctrl+V (paste)
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                            try {
                                # Get clipboard text (Windows only)
                                $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                    Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                                } else {
                                    $null
                                }
                                
                                if ($clipboardText) {
                                    # Split clipboard text into lines
                                    $clipboardLines = $clipboardText -split '[\r\n]+'
                                    
                                    if ($clipboardLines.Count -eq 1) {
                                        # Single line paste - insert at cursor
                                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0])
                                        $cursorX += $clipboardLines[0].Length
                                    } else {
                                        # Multi-line paste
                                        $currentLine = $lines[$cursorY]
                                        $beforeCursor = $currentLine.Substring(0, $cursorX)
                                        $afterCursor = $currentLine.Substring($cursorX)
                                        
                                        # First line
                                        $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                        
                                        # Insert middle lines
                                        $insertLines = @()
                                        for ($i = 1; $i -lt $clipboardLines.Count - 1; $i++) {
                                            $insertLines += $clipboardLines[$i]
                                        }
                                        
                                        # Last line
                                        $lastLine = $clipboardLines[-1] + $afterCursor
                                        $insertLines += $lastLine
                                        
                                        # Insert all new lines
                                        $newLines = @()
                                        for ($i = 0; $i -le $cursorY; $i++) {
                                            $newLines += $lines[$i]
                                        }
                                        $newLines += $insertLines
                                        for ($i = $cursorY + 1; $i -lt $lines.Count; $i++) {
                                            $newLines += $lines[$i]
                                        }
                                        
                                        $lines = $newLines
                                        $cursorY += $clipboardLines.Count - 1
                                        $cursorX = $clipboardLines[-1].Length
                                    }
                                    
                                    # Adjust scroll if needed
                                    $innerHeight = $self.Height - 2
                                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                        $self.ScrollOffset = $cursorY - $innerHeight + 1 
                                    }
                                }
                            } catch {
                                # Silently ignore clipboard errors
                                Write-Log -Level Warning -Message "TextArea clipboard paste error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
                            }
                        } else {
                            # Regular 'V' key
                            if (-not [char]::IsControl($Key.KeyChar)) {
                                $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                                $cursorX++
                            } else {
                                return $false
                            }
                        }
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                            $cursorX++
                        } else { 
                            return $false 
                        }
                    }
                }
                
                $self.Lines = $lines
                $self.CursorX = $cursorX
                $self.CursorY = $cursorY
                $self.Text = $lines -join "`n"
                
                if ($self.OnChange) { 
                    Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $self.Text } -ScriptBlock {
                        & $self.OnChange -NewValue $self.Text 
                    }
                }
                Request-TuiRefresh
                return $true
            } catch {
                Write-Log -Level Error -Message "TextArea HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # AI: Initialize Lines array from Text property (PowerShell 5.1 compatible)
    if ($null -ne $Props.Text -and $Props.Text -ne "") {
        $component.Lines = $Props.Text -split "`n"
    } else {
        $component.Lines = @("")
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region DateTime Components

function global:New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "DatePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 20 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Value = if ($null -ne $Props.Value) { $Props.Value } else { (Get-Date) }
        Format = if ($null -ne $Props.Format) { $Props.Format } else { "yyyy-MM-dd" }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                $dateStr = $self.Value.ToString($self.Format)
                
                # Truncate date string if too long
                $maxLength = $self.Width - 6
                if ($dateStr.Length -gt $maxLength) {
                    $dateStr = $dateStr.Substring(0, $maxLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
                if ($self.IsFocused -and $self.Width -ge 6) { 
                    Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "📅" -ForegroundColor $borderColor 
                }
            } catch {
                Write-Log -Level Error -Message "DatePicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $date = $self.Value
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                    ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                    ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                    ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                    ([ConsoleKey]::Home)      { $date = Get-Date }
                    ([ConsoleKey]::T) { 
                        if ($Key.Modifiers -band [ConsoleModifiers]::Control) { 
                            $date = Get-Date 
                        } else { 
                            $handled = $false 
                        } 
                    }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Value = $date
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewValue = $date } -ScriptBlock {
                            & $self.OnChange -NewValue $date 
                        }
                    }
                    Request-TuiRefresh
                }
                return $handled
            } catch {
                Write-Log -Level Error -Message "DatePicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TimePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 15 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 3 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Hour = if ($null -ne $Props.Hour) { $Props.Hour } else { 0 }
        Minute = if ($null -ne $Props.Minute) { $Props.Minute } else { 0 }
        Format24H = if ($null -ne $Props.Format24H) { $Props.Format24H } else { $true }
        Name = $Props.Name
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
                
                if ($self.Format24H) { 
                    $timeStr = "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
                } else {
                    $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                    $ampm = if ($self.Hour -lt 12) { "AM" } else { "PM" }
                    $timeStr = "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
                }
                
                # Truncate time string if too long
                $maxLength = $self.Width - 6
                if ($timeStr.Length -gt $maxLength) {
                    $timeStr = $timeStr.Substring(0, $maxLength)
                }
                
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
                if ($self.IsFocused -and $self.Width -ge 6) { 
                    Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "⏰" -ForegroundColor $borderColor 
                }
            } catch {
                Write-Log -Level Error -Message "TimePicker Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                $handled = $true
                $hour = $self.Hour
                $minute = $self.Minute
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        $minute = ($minute + 15) % 60
                        if ($minute -eq 0) { $hour = ($hour + 1) % 24 } 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        $minute = ($minute - 15 + 60) % 60
                        if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } 
                    }
                    ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                    ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                    default { $handled = $false }
                }
                
                if ($handled) {
                    $self.Hour = $hour
                    $self.Minute = $minute
                    
                    if ($self.OnChange) { 
                        Invoke-WithErrorHandling -Component "$($self.Name).OnChange" -Context "OnChange" -AdditionalData @{ Component = $self.Name; NewHour = $hour; NewMinute = $minute } -ScriptBlock {
                            & $self.OnChange -NewHour $hour -NewMinute $minute 
                        }
                    }
                    Request-TuiRefresh
                }
                return $handled
            } catch {
                Write-Log -Level Error -Message "TimePicker HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Data Display Components

function global:New-TuiTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Table"
        IsFocusable = $true
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 60 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 15 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        Columns = if ($null -ne $Props.Columns) { $Props.Columns } else { @() }
        Rows = if ($null -ne $Props.Rows) { $Props.Rows } else { @() }
        Name = $Props.Name
        
        # Internal State
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        
        # Event Handlers (from Props)
        OnRowSelect = $Props.OnRowSelect
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
                
                $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
                
                $totalWidth = $self.Width - 4
                $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count)
                $headerY = $self.Y + 1
                $currentX = $self.X + 2
                
                # Draw headers
                foreach ($col in $self.Columns) {
                    $header = $col.Header
                    if ($col.Name -eq $self.SortColumn) { 
                        $arrow = if ($self.SortAscending) { "▲" } else { "▼" }
                        $header = "$header $arrow" 
                    }
                    if ($header.Length -gt $colWidth - 1) { 
                        $header = $header.Substring(0, $colWidth - 4) + "..." 
                    }
                    Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header")
                    $currentX += $colWidth
                }
                
                # Header separator
                Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("─" * ($self.Width - 2)) -ForegroundColor $borderColor
                
                # Draw rows
                $visibleRows = $self.Height - 5
                $startIdx = $self.ScrollOffset
                $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $row = $self.Rows[$i]
                    $rowY = ($headerY + 2) + ($i - $startIdx)
                    $currentX = $self.X + 2
                    $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                    $bgColor = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                    $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                    
                    if ($isSelected) { 
                        Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor 
                    }
                    
                    foreach ($col in $self.Columns) {
                        $value = $row.($col.Name)
                        if ($null -eq $value) { $value = "" }
                        $text = $value.ToString()
                        if ($text.Length -gt $colWidth - 1) { 
                            $text = $text.Substring(0, $colWidth - 4) + "..." 
                        }
                        Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor
                        $currentX += $colWidth
                    }
                }
                
                # Scrollbar
                if ($self.Rows.Count -gt $visibleRows) {
                    $scrollbarHeight = $visibleRows
                    $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                    for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                        $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Table Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($self.Rows.Count -eq 0) { return $false }
                
                $visibleRows = $self.Height - 5
                $handled = $true
                
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        if ($self.SelectedRow -gt 0) { 
                            $self.SelectedRow--
                            if ($self.SelectedRow -lt $self.ScrollOffset) { 
                                $self.ScrollOffset = $self.SelectedRow 
                            }
                            Request-TuiRefresh 
                        } 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        if ($self.SelectedRow -lt $self.Rows.Count - 1) { 
                            $self.SelectedRow++
                            if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { 
                                $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 
                            }
                            Request-TuiRefresh 
                        } 
                    }
                    ([ConsoleKey]::PageUp) { 
                        $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows)
                        $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::PageDown) { 
                        $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows)
                        $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                        $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::Home) { 
                        $self.SelectedRow = 0
                        $self.ScrollOffset = 0
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::End) { 
                        $self.SelectedRow = $self.Rows.Count - 1
                        $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                        Request-TuiRefresh 
                    }
                    ([ConsoleKey]::Enter) { 
                        if ($self.OnRowSelect) { 
                            Invoke-WithErrorHandling -Component "$($self.Name).OnRowSelect" -Context "OnRowSelect" -AdditionalData @{ Component = $self.Name; SelectedRow = $self.SelectedRow } -ScriptBlock {
                                & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow 
                            }
                        } 
                    }
                    default {
                        if ($Key.KeyChar -match '\d') {
                            $colIndex = [int]$Key.KeyChar.ToString() - 1
                            if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                                $colName = $self.Columns[$colIndex].Name
                                if ($self.SortColumn -eq $colName) { 
                                    $self.SortAscending = -not $self.SortAscending 
                                } else { 
                                    $self.SortColumn = $colName
                                    $self.SortAscending = $true 
                                }
                                $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                                Request-TuiRefresh
                            }
                        } else { 
                            $handled = $false 
                        }
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Table HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
            }
            return $handled
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

function global:New-TuiChart {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Chart"
        IsFocusable = $false
        
        # Properties (from Props)
        X = if ($null -ne $Props.X) { $Props.X } else { 0 }
        Y = if ($null -ne $Props.Y) { $Props.Y } else { 0 }
        Width = if ($null -ne $Props.Width) { $Props.Width } else { 40 }
        Height = if ($null -ne $Props.Height) { $Props.Height } else { 10 }
        Visible = if ($null -ne $Props.Visible) { $Props.Visible } else { $true }
        ZIndex = if ($null -ne $Props.ZIndex) { $Props.ZIndex } else { 0 }
        ChartType = if ($null -ne $Props.ChartType) { $Props.ChartType } else { "Bar" }
        Data = if ($null -ne $Props.Data) { $Props.Data } else { @() }
        ShowValues = if ($null -ne $Props.ShowValues) { $Props.ShowValues } else { $true }
        Name = $Props.Name
        
        # Methods
        Render = {
            param($self)
            try {
                if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
                
                switch ($self.ChartType) {
                    "Bar" {
                        $maxValue = ($self.Data | Measure-Object -Property Value -Maximum).Maximum
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        $chartHeight = $self.Height - 2
                        $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                        
                        for ($i = 0; $i -lt $self.Data.Count; $i++) {
                            $item = $self.Data[$i]
                            $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                            $barX = $self.X + 2 + ($i * $barWidth)
                            
                            for ($y = 0; $y -lt $barHeight; $y++) { 
                                $barY = $self.Y + $self.Height - 2 - $y
                                Write-BufferString -X $barX -Y $barY -Text ("█" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                            }
                            
                            if ($item.Label -and $barWidth -gt 3) { 
                                $label = $item.Label
                                if ($label.Length -gt $barWidth - 1) { 
                                    $label = $label.Substring(0, $barWidth - 2) 
                                }
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                            }
                            
                            if ($self.ShowValues -and $barHeight -gt 0) { 
                                $valueText = $item.Value.ToString()
                                Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                            }
                        }
                    }
                    "Sparkline" {
                        $width = $self.Width - 2
                        $height = $self.Height - 1
                        $maxValue = ($self.Data | Measure-Object -Maximum).Maximum
                        if ($maxValue -eq 0) { $maxValue = 1 }
                        
                        $sparkChars = @(" ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█")
                        $sparkline = ""
                        
                        foreach ($value in $self.Data) { 
                            $normalized = ($value / $maxValue)
                            $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1))
                            $sparkline += $sparkChars[$charIndex] 
                        }
                        
                        if ($sparkline.Length -gt $width) { 
                            $sparkline = $sparkline.Substring($sparkline.Length - $width) 
                        } else { 
                            $sparkline = $sparkline.PadLeft($width) 
                        }
                        
                        Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                    }
                }
            } catch {
                Write-Log -Level Error -Message "Chart Render error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Exception = $_ }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                return $false
            } catch {
                Write-Log -Level Error -Message "Chart HandleInput error for '$($self.Name)': $_" -Data @{ Component = $self.Name; Key = $Key; Exception = $_ }
                return $false
            }
        }
    }
    
    # Return as hashtable to allow dynamic property assignment
    return $component
}

#endregion

#region Container Components

# FIX: REMOVED the legacy New-TuiPanel function entirely.
# All code should now use the more specific panels from layout/panels.psm1.

#endregion

Export-ModuleMember -Function @(
    # Basic Components
    'New-TuiLabel',
    'New-TuiButton',
    'New-TuiTextBox',
    'New-TuiCheckBox',
    'New-TuiDropdown',
    'New-TuiProgressBar',
    'New-TuiTextArea',
    # DateTime Components
    'New-TuiDatePicker',
    'New-TuiTimePicker',
    # Data Display Components
    'New-TuiTable',
    'New-TuiChart'
)


####\components\ui-classes.psm1
# ==============================================================================
# PMC Terminal v5 - Base UI Class Hierarchy
# Provides the foundational classes for all UI components, incorporating the
# stable and safe IRenderable pattern directly into the base element.
# ==============================================================================

using namespace System.Text

# Import error handling utilities
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# --- Base UI Element (with integrated safe rendering) ---
class UIElement {
    [string]$Name
    [bool]$Visible = $true
    [bool]$Enabled = $true
    
    UIElement([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [System.ArgumentException]::new("UIElement name cannot be null or empty.")
        }
        $this.Name = $name
    }

    # Public, safe render method. Derived classes should NOT override this.
    [string] Render() {
        return Invoke-WithErrorHandling -Component $this.Name -Context "Render" -ScriptBlock {
            if (-not $this.Visible) { return "" }
            
            # Call the internal, abstract render method that derived classes MUST implement.
            return $this._RenderContent()
        } -AdditionalData @{ ComponentType = $this.GetType().Name }
    }

    # Abstract method - must be implemented by derived classes.
    hidden [string] _RenderContent() {
        throw [System.NotImplementedException]::new("Component '$($this.Name)' of type '$($this.GetType().Name)' must implement the _RenderContent() method.")
    }
    
    [string] ToString() {
        return "$($this.GetType().Name): $($this.Name)"
    }
}

# --- Base Component (can contain children) ---
class Component : UIElement {
    [object]$Parent
    [System.Collections.Generic.List[UIElement]]$Children

    Component([string]$name) : base($name) {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }

    [void] AddChild([UIElement]$child) {
        if (-not $child) { throw [System.ArgumentNullException]::new("child") }
        if ($child -eq $this) { throw [System.InvalidOperationException]::new("A component cannot be its own child.") }
        
        $child.Parent = $this
        $this.Children.Add($child)
    }
}

# --- Base Panel (rectangular area) ---
class Panel : Component {
    [int]$X
    [int]$Y
    [int]$Width
    [int]$Height
    [string]$Title = ""
    [bool]$ShowBorder = $true

    Panel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name) {
        if ($width -le 0 -or $height -le 0) { throw [System.ArgumentOutOfRangeException]::new("Panel dimensions must be positive.") }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
    }

    [hashtable] GetContentArea() {
        $borderOffset = if ($this.ShowBorder) { 1 } else { 0 }
        return @{
            X      = $this.X + $borderOffset
            Y      = $this.Y + $borderOffset
            Width  = $this.Width - (2 * $borderOffset)
            Height = $this.Height - (2 * $borderOffset)
        }
    }
}

# --- Base Screen (top-level container) ---
class Screen : UIElement {
    [hashtable]$Services
    [System.Collections.Generic.Dictionary[string, object]]$State
    [System.Collections.Generic.List[Panel]]$Panels
    hidden [System.Collections.Generic.Dictionary[string, string]]$EventSubscriptions

    Screen([string]$name, [hashtable]$services) : base($name) {
        if (-not $services) { throw [System.ArgumentNullException]::new("services") }
        
        $this.Services = $services
        $this.State = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.Panels = [System.Collections.Generic.List[Panel]]::new()
        $this.EventSubscriptions = [System.Collections.Generic.Dictionary[string, string]]::new()
    }
    
    # Virtual lifecycle methods for derived screens to override.
    [void] Initialize() { }
    [void] OnEnter() { }
    [void] OnExit() { }
    [void] OnResume() { }
    [void] HandleInput([System.ConsoleKeyInfo]$key) { }

    [void] Cleanup() {
        # Unsubscribe from all events to prevent memory leaks
        foreach ($kvp in $this.EventSubscriptions.GetEnumerator()) {
            try {
                Unsubscribe-Event -EventName $kvp.Key -SubscriberId $kvp.Value
            }
            catch {
                Write-Log -Level Warning -Message "Failed to unregister event '$($kvp.Key)' for screen '$($this.Name)'."
            }
        }
        $this.EventSubscriptions.Clear()
        $this.Panels.Clear()
        Write-Log -Level Debug -Message "Cleaned up screen: $($this.Name)"
    }
    
    [void] AddPanel([Panel]$panel) {
        if (-not $panel) { throw [System.ArgumentNullException]::new("panel") }
        $this.Panels.Add($panel)
    }

    [void] SubscribeToEvent([string]$eventName, [scriptblock]$action) {
        if ([string]::IsNullOrWhiteSpace($eventName)) { throw [System.ArgumentException]::new("Event name cannot be null or empty.") }
        if (-not $action) { throw [System.ArgumentNullException]::new("action") }
        
        $subscriptionId = Subscribe-Event -EventName $eventName -Action $action
        $this.EventSubscriptions[$eventName] = $subscriptionId
    }
}

# Export all base classes for other modules to use.
Export-ModuleMember -Class @('UIElement', 'Component', 'Panel', 'Screen')


####\layout\panels-class.psm1
# Panel Classes Module for PMC Terminal v5
# Implements specialized panel types for the TUI layout system
# AI: Implements Phase 1.2 of the class migration plan - layout components

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# AI: Import dependencies using absolute paths for PowerShell 5.1 compatibility
# PowerShell 5.1 requires 'using module' statements to be at the top level, not in conditional blocks
$uiClassesPath = Join-Path (Split-Path $PSScriptRoot -Parent) "components\ui-classes.psm1"
if (-not (Test-Path $uiClassesPath)) {
    throw "Required module not found: ui-classes.psm1 at $uiClassesPath"
}

# Import the base UI classes module
Import-Module $uiClassesPath -Force -Global

# Import utilities for error handling
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# BorderPanel - Panel with customizable border rendering
class BorderPanel : Panel {
    [ConsoleColor] $BorderColor = [ConsoleColor]::Gray
    [string] $BorderStyle = "Single" # Single, Double, Rounded
    [ConsoleColor] $TitleColor = [ConsoleColor]::White
    
    # AI: Border character sets for different styles
    hidden static [hashtable] $BorderChars = @{
        Single = @{
            TopLeft = '┌'; TopRight = '┐'; BottomLeft = '└'; BottomRight = '┘'
            Horizontal = '─'; Vertical = '│'
        }
        Double = @{
            TopLeft = '╔'; TopRight = '╗'; BottomLeft = '╚'; BottomRight = '╝'
            Horizontal = '═'; Vertical = '║'
        }
        Rounded = @{
            TopLeft = '╭'; TopRight = '╮'; BottomLeft = '╰'; BottomRight = '╯'
            Horizontal = '─'; Vertical = '│'
        }
    }
    
    BorderPanel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name, $x, $y, $width, $height) {
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "BorderPanel" -Context "Render:$($this.Name)" -ScriptBlock {
            $renderedContent = [System.Text.StringBuilder]::new()
            
            if ($this.ShowBorder) {
                [void]$renderedContent.Append($this.RenderBorder())
            }
            
            # Render children within content area
            if ($this.Children.Count -gt 0) {
                [void]$renderedContent.Append($this.RenderContent())
            }
            
            return $renderedContent.ToString()
        }
    }
    
    hidden [string] RenderBorder() {
        $borderBuilder = [System.Text.StringBuilder]::new()
        $chars = [BorderPanel]::BorderChars[$this.BorderStyle]
        
        if ($null -eq $chars) {
            Write-Log -Level Warning -Message "Unknown border style: $($this.BorderStyle), defaulting to Single" -Component "BorderPanel"
            $chars = [BorderPanel]::BorderChars["Single"]
        }
        
        # Top border
        [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y))
        [void]$borderBuilder.Append($this.SetColor($this.BorderColor))
        [void]$borderBuilder.Append($chars.TopLeft)
        
        # Title handling
        $horizontalSpace = $this.Width - 2
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $titleText = " $($this.Title) "
            if ($titleText.Length -gt $horizontalSpace) {
                $titleText = $titleText.Substring(0, $horizontalSpace)
            }
            
            $paddingBefore = [Math]::Floor(($horizontalSpace - $titleText.Length) / 2)
            $paddingAfter = $horizontalSpace - $titleText.Length - $paddingBefore
            
            [void]$borderBuilder.Append($chars.Horizontal * $paddingBefore)
            [void]$borderBuilder.Append($this.SetColor($this.TitleColor))
            [void]$borderBuilder.Append($titleText)
            [void]$borderBuilder.Append($this.SetColor($this.BorderColor))
            [void]$borderBuilder.Append($chars.Horizontal * $paddingAfter)
        }
        else {
            [void]$borderBuilder.Append($chars.Horizontal * $horizontalSpace)
        }
        
        [void]$borderBuilder.Append($chars.TopRight)
        
        # Side borders
        for ($row = 1; $row -lt $this.Height - 1; $row++) {
            [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $row))
            [void]$borderBuilder.Append($chars.Vertical)
            [void]$borderBuilder.Append($this.MoveCursor($this.X + $this.Width - 1, $this.Y + $row))
            [void]$borderBuilder.Append($chars.Vertical)
        }
        
        # Bottom border
        [void]$borderBuilder.Append($this.MoveCursor($this.X, $this.Y + $this.Height - 1))
        [void]$borderBuilder.Append($chars.BottomLeft)
        [void]$borderBuilder.Append($chars.Horizontal * $horizontalSpace)
        [void]$borderBuilder.Append($chars.BottomRight)
        
        [void]$borderBuilder.Append($this.ResetColor())
        
        return $borderBuilder.ToString()
    }
    
    hidden [string] RenderContent() {
        $contentBuilder = [System.Text.StringBuilder]::new()
        $contentArea = $this.GetContentArea()
        
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                [void]$contentBuilder.Append($child.Render())
            }
        }
        
        return $contentBuilder.ToString()
    }
    
    # AI: Helper methods for ANSI escape sequences
    hidden [string] MoveCursor([int]$x, [int]$y) {
        return "`e[$($y + 1);$($x + 1)H"
    }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# ContentPanel - Panel for displaying scrollable content
class ContentPanel : Panel {
    [string[]] $Content = @()
    [int] $ScrollOffset = 0
    [ConsoleColor] $TextColor = [ConsoleColor]::White
    [bool] $WordWrap = $true
    
    ContentPanel([string]$name, [int]$x, [int]$y, [int]$width, [int]$height) : base($name, $x, $y, $width, $height) {
    }
    
    [void] SetContent([string[]]$content) {
        if ($null -eq $content) {
            $this.Content = @()
        }
        else {
            $this.Content = $content
        }
        $this.ScrollOffset = 0
    }
    
    [void] AppendContent([string]$line) {
        if ($null -ne $line) {
            $this.Content += $line
        }
    }
    
    [void] ClearContent() {
        $this.Content = @()
        $this.ScrollOffset = 0
    }
    
    [void] ScrollUp([int]$lines = 1) {
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset - $lines)
    }
    
    [void] ScrollDown([int]$lines = 1) {
        $maxOffset = [Math]::Max(0, $this.Content.Count - $this.GetContentArea().Height)
        $this.ScrollOffset = [Math]::Min($maxOffset, $this.ScrollOffset + $lines)
    }
    
    [void] ScrollToTop() {
        $this.ScrollOffset = 0
    }
    
    [void] ScrollToBottom() {
        $maxOffset = [Math]::Max(0, $this.Content.Count - $this.GetContentArea().Height)
        $this.ScrollOffset = $maxOffset
    }
    
    [string] Render() {
        return Invoke-WithErrorHandling -Component "ContentPanel" -Context "Render:$($this.Name)" -ScriptBlock {
            $contentBuilder = [System.Text.StringBuilder]::new()
            $contentArea = $this.GetContentArea()
            
            # Process content with word wrapping if enabled
            $processedLines = @()
            if ($this.WordWrap) {
                foreach ($line in $this.Content) {
                    $processedLines += $this.WrapText($line, $contentArea.Width)
                }
            }
            else {
                $processedLines = $this.Content
            }
            
            # Render visible lines
            $visibleLines = [Math]::Min($contentArea.Height, $processedLines.Count - $this.ScrollOffset)
            
            for ($i = 0; $i -lt $visibleLines; $i++) {
                $lineIndex = $this.ScrollOffset + $i
                if ($lineIndex -lt $processedLines.Count) {
                    $line = $processedLines[$lineIndex]
                    
                    # Truncate if needed (when word wrap is off)
                    if ($line.Length -gt $contentArea.Width) {
                        $line = $line.Substring(0, $contentArea.Width)
                    }
                    
                    [void]$contentBuilder.Append($this.MoveCursor($contentArea.X, $contentArea.Y + $i))
                    [void]$contentBuilder.Append($this.SetColor($this.TextColor))
                    [void]$contentBuilder.Append($line)
                }
            }
            
            # Clear remaining lines in content area
            $clearLine = ' ' * $contentArea.Width
            for ($i = $visibleLines; $i -lt $contentArea.Height; $i++) {
                [void]$contentBuilder.Append($this.MoveCursor($contentArea.X, $contentArea.Y + $i))
                [void]$contentBuilder.Append($clearLine)
            }
            
            [void]$contentBuilder.Append($this.ResetColor())
            
            return $contentBuilder.ToString()
        }
    }
    
    # AI: Word wrap implementation
    hidden [string[]] WrapText([string]$text, [int]$maxWidth) {
        if ([string]::IsNullOrEmpty($text) -or $maxWidth -le 0) {
            return @()
        }
        
        $lines = [System.Collections.Generic.List[string]]::new()
        $words = $text -split '\s+'
        $currentLine = [System.Text.StringBuilder]::new()
        
        foreach ($word in $words) {
            if ($currentLine.Length -eq 0) {
                [void]$currentLine.Append($word)
            }
            elseif (($currentLine.Length + 1 + $word.Length) -le $maxWidth) {
                [void]$currentLine.Append(' ').Append($word)
            }
            else {
                $lines.Add($currentLine.ToString())
                $currentLine.Clear()
                [void]$currentLine.Append($word)
            }
        }
        
        if ($currentLine.Length -gt 0) {
            $lines.Add($currentLine.ToString())
        }
        
        return $lines.ToArray()
    }
    
    # AI: Helper methods (inherited from BorderPanel, but redefined for clarity)
    hidden [string] MoveCursor([int]$x, [int]$y) {
        return "`e[$($y + 1);$($x + 1)H"
    }
    
    hidden [string] SetColor([ConsoleColor]$color) {
        $colorMap = @{
            'Black' = 30; 'DarkRed' = 31; 'DarkGreen' = 32; 'DarkYellow' = 33
            'DarkBlue' = 34; 'DarkMagenta' = 35; 'DarkCyan' = 36; 'Gray' = 37
            'DarkGray' = 90; 'Red' = 91; 'Green' = 92; 'Yellow' = 93
            'Blue' = 94; 'Magenta' = 95; 'Cyan' = 96; 'White' = 97
        }
        $colorCode = $colorMap[$color.ToString()]
        return "`e[${colorCode}m"
    }
    
    hidden [string] ResetColor() {
        return "`e[0m"
    }
}

# Export all classes
Export-ModuleMember -Function * -Cmdlet * -Variable * -Alias *


####\modules\data-manager.psm1
# Data Manager Module
# Unified data persistence and CRUD operations with event integration
# AI: Refactored from dispatch-based actions to direct function calls
# AI: Now uses strongly-typed PmcTask and PmcProject classes from models module

# AI: Using absolute path for models module to ensure proper loading
using module $PSScriptRoot\models.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Module-level state variables
$script:Data = @{
    Projects = [System.Collections.Generic.List[PmcProject]]::new()
    Tasks = [System.Collections.Generic.List[PmcTask]]::new()
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
    # AI: Maintaining compatibility with legacy underscore format
    time_entries = @()    # underscore format for action compatibility
    timers = @()          # for action compatibility
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system
    
    .DESCRIPTION
    Sets up the data directory, loads existing data, and configures event handlers
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "DataManager initialization" -ScriptBlock {
        # Ensure data directory exists
        $dataDirectory = Split-Path $script:DataPath -Parent
        if (-not (Test-Path $dataDirectory)) {
            New-Item -ItemType Directory -Path $dataDirectory -Force | Out-Null
            Write-Log -Level Info -Message "Created data directory: $dataDirectory"
        }
        
        # Ensure backup directory exists
        if (-not (Test-Path $script:BackupPath)) {
            New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
            Write-Log -Level Info -Message "Created backup directory: $script:BackupPath"
        }
        
        # Load existing data
        Load-UnifiedData
        
        # Initialize event handlers
        Initialize-DataEventHandlers
        
        Write-Log -Level Info -Message "DataManager initialized successfully"
        
        # AI: Return both service object with methods and class-based DataManager
        $serviceObject = [PSCustomObject]@{
            AddTask = Get-Command Add-PmcTask
            UpdateTask = Get-Command Update-PmcTask
            RemoveTask = Get-Command Remove-PmcTask
            GetTasks = Get-Command Get-PmcTasks
            GetProjects = Get-Command Get-PmcProjects
            SaveData = Get-Command Save-UnifiedData
            LoadData = Get-Command Load-UnifiedData
        }
        
        # Also provide class-based interface for compatibility
        $dataManager = [DataManager]::new()
        return $dataManager
    }
}

function Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads application data from disk
    
    .DESCRIPTION
    Loads the unified data file and populates the global data structure with strongly-typed objects
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.LoadData" -Context "Loading unified data from disk" -ScriptBlock {
        if (Test-Path $script:DataPath) {
            try {
                $content = Get-Content -Path $script:DataPath -Raw
                $loadedData = $content | ConvertFrom-Json -AsHashtable
                
                # AI: Defensive validation of loaded data structure
                if ($loadedData -and $loadedData -is [hashtable]) {
                    # AI: Re-hydrate Tasks as PmcTask objects
                    if ($loadedData.ContainsKey('Tasks') -and $loadedData.Tasks) {
                        $script:Data.Tasks.Clear()
                        foreach ($taskData in $loadedData.Tasks) {
                            if ($taskData -is [hashtable]) {
                                # AI: Use static method to create from legacy format
                                $task = [PmcTask]::FromLegacyFormat($taskData)
                                $script:Data.Tasks.Add($task)
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Tasks.Count) tasks as PmcTask objects"
                    }
                    
                    # AI: Re-hydrate Projects as PmcProject objects
                    if ($loadedData.ContainsKey('Projects') -and $loadedData.Projects) {
                        $script:Data.Projects.Clear()
                        # AI: Projects were stored as hashtable, need to convert each value
                        if ($loadedData.Projects -is [hashtable]) {
                            foreach ($projectKey in $loadedData.Projects.Keys) {
                                $projectData = $loadedData.Projects[$projectKey]
                                if ($projectData -is [hashtable]) {
                                    $project = [PmcProject]::FromLegacyFormat($projectData)
                                    $script:Data.Projects.Add($project)
                                }
                            }
                        }
                        Write-Log -Level Debug -Message "Re-hydrated $($script:Data.Projects.Count) projects as PmcProject objects"
                    }
                    
                    # AI: Load other data structures as-is for now
                    foreach ($key in @('TimeEntries', 'ActiveTimers', 'TodoTemplates', 'Settings', 'time_entries', 'timers')) {
                        if ($loadedData.ContainsKey($key)) {
                            $script:Data[$key] = $loadedData[$key]
                        }
                    }
                    
                    # Update global data reference
                    $global:Data = $script:Data
                    
                    Write-Log -Level Info -Message "Data loaded successfully from disk"
                } else {
                    Write-Log -Level Warning -Message "Invalid data format in file, using defaults"
                    $global:Data = $script:Data
                }
            } catch {
                Write-Log -Level Error -Message "Failed to parse data file: $_"
                Write-Log -Level Info -Message "Using default data structure"
                $global:Data = $script:Data
            }
        } else {
            Write-Log -Level Info -Message "No existing data file found, using defaults"
            $global:Data = $script:Data
        }
        
        $script:LastSaveTime = Get-Date
    }
}

function Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves application data to disk
    
    .DESCRIPTION
    Persists the current data state to disk with automatic backup rotation
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.SaveData" -Context "Saving unified data to disk" -ScriptBlock {
        # Create backup if file exists
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_{0:yyyyMMdd_HHmmss}.json" -f (Get-Date)
            $backupFilePath = Join-Path $script:BackupPath $backupName
            Copy-Item -Path $script:DataPath -Destination $backupFilePath -Force
            
            # Rotate backups
            $backups = Get-ChildItem -Path $script:BackupPath -Filter "pmc-data_*.json" | 
                       Sort-Object LastWriteTime -Descending
            
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | Remove-Item -Force
            }
        }
        
        # AI: Convert strongly-typed objects to legacy format for JSON serialization
        $dataToSave = @{
            Tasks = @($script:Data.Tasks | ForEach-Object { $_.ToLegacyFormat() })
            Projects = @{}  # AI: Convert back to hashtable format for compatibility
            TimeEntries = $script:Data.TimeEntries
            ActiveTimers = $script:Data.ActiveTimers
            TodoTemplates = $script:Data.TodoTemplates
            Settings = $script:Data.Settings
            time_entries = $script:Data.time_entries
            timers = $script:Data.timers
        }
        
        # AI: Rebuild Projects hashtable keyed by project key
        foreach ($project in $script:Data.Projects) {
            $dataToSave.Projects[$project.Key] = $project.ToLegacyFormat()
        }
        
        # Save current data
        $dataToSave | ConvertTo-Json -Depth 10 | Out-File -FilePath $script:DataPath -Encoding UTF8
        $script:LastSaveTime = Get-Date
        $script:DataModified = $false
        
        Write-Log -Level Debug -Message "Data saved successfully"
    }
}

#region Task Management Functions

function Add-PmcTask {
    <#
    .SYNOPSIS
    Creates a new task
    
    .DESCRIPTION
    Adds a new task to the data store and publishes a Tasks.Changed event
    
    .PARAMETER Title
    The title of the task (required)
    
    .PARAMETER Description
    The task description
    
    .PARAMETER Priority
    Task priority: low, medium, or high
    
    .PARAMETER Category
    Task category/project name
    
    .PARAMETER DueDate
    Task due date
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Title,
        
        [string]$Description = "",
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority = "medium",
        
        [string]$Category = "General",
        
        [string]$DueDate = ""
    )
    
    Invoke-WithErrorHandling -Component "DataManager.AddTask" -Context "Adding new task to data store" -ScriptBlock {
        # AI: Input validation
        if ([string]::IsNullOrWhiteSpace($Title)) {
            throw [StateMutationException]::new("Task title cannot be empty", @{ Title = $Title })
        }
        
        # AI: Convert string priority to enum
        $taskPriority = switch ($Priority.ToLower()) {
            "low" { [TaskPriority]::Low }
            "medium" { [TaskPriority]::Medium }
            "high" { [TaskPriority]::High }
            default { [TaskPriority]::Medium }
        }
        
        # AI: Create new task using class constructor
        $newTask = [PmcTask]::new($Title, $Description, $taskPriority, $Category)
        
        # AI: Set due date if provided
        if ($DueDate -and $DueDate -ne "N/A") {
            try {
                $newTask.DueDate = [datetime]::Parse($DueDate)
            } catch {
                Write-Log -Level Warning -Message "Invalid due date format: $DueDate"
                $newTask.DueDate = $null
            }
        }
        
        # AI: Add to strongly-typed task list
        $script:Data.Tasks.Add($newTask)
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Created task '$($newTask.Title)' with ID $($newTask.Id)"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Tasks.Changed" -Data @{
            Action = "Created"
            TaskId = $newTask.Id
            Task = $newTask
        }
        
        return $newTask
    }
}

function Update-PmcTask {
    <#
    .SYNOPSIS
    Updates an existing task
    
    .DESCRIPTION
    Modifies task properties and publishes a Tasks.Changed event
    
    .PARAMETER Task
    The PmcTask object to update (required)
    
    .PARAMETER Title
    New task title
    
    .PARAMETER Description
    New task description
    
    .PARAMETER Priority
    New task priority
    
    .PARAMETER Category
    New task category
    
    .PARAMETER DueDate
    New due date
    
    .PARAMETER Completed
    Task completion status
    
    .PARAMETER Progress
    Task progress percentage (0-100)
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcTask]$Task,
        
        [string]$Title,
        
        [string]$Description,
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority,
        
        [string]$Category,
        
        [string]$DueDate,
        
        [bool]$Completed,
        
        [ValidateRange(0, 100)]
        [int]$Progress
    )
    
    Invoke-WithErrorHandling -Component "DataManager.UpdateTask" -Context "Updating existing task" -ScriptBlock {
        # AI: Find task in list to ensure we're updating the managed instance
        $managedTask = $script:Data.Tasks | Where-Object { $_.Id -eq $Task.Id } | Select-Object -First 1
        
        if (-not $managedTask) {
            throw [StateMutationException]::new("Task not found in data store", @{ TaskId = $Task.Id })
        }
        
        $updatedFields = @()
        
        # AI: Update task properties using proper object properties
        if ($PSBoundParameters.ContainsKey('Title') -and $Title) { 
            $managedTask.Title = $Title.Trim()
            $updatedFields += "Title"
        }
        if ($PSBoundParameters.ContainsKey('Description')) { 
            $managedTask.Description = $Description
            $updatedFields += "Description"
        }
        if ($PSBoundParameters.ContainsKey('Priority')) {
            $managedTask.Priority = switch ($Priority.ToLower()) {
                "low" { [TaskPriority]::Low }
                "medium" { [TaskPriority]::Medium }
                "high" { [TaskPriority]::High }
                default { [TaskPriority]::Medium }
            }
            $updatedFields += "Priority"
        }
        if ($PSBoundParameters.ContainsKey('Category')) { 
            $managedTask.ProjectKey = $Category
            $managedTask.Category = $Category  # AI: Maintain backward compatibility
            $updatedFields += "Category"
        }
        if ($PSBoundParameters.ContainsKey('DueDate')) {
            if ($DueDate -and $DueDate -ne "N/A") {
                try {
                    $managedTask.DueDate = [datetime]::Parse($DueDate)
                } catch {
                    Write-Log -Level Warning -Message "Invalid due date format: $DueDate"
                    $managedTask.DueDate = $null
                }
            } else {
                $managedTask.DueDate = $null
            }
            $updatedFields += "DueDate"
        }
        if ($PSBoundParameters.ContainsKey('Progress')) {
            # AI: Use class method which handles status updates
            $managedTask.UpdateProgress($Progress)
            $updatedFields += "Progress"
        }
        if ($PSBoundParameters.ContainsKey('Completed')) {
            if ($Completed) {
                $managedTask.Complete()
            } else {
                $managedTask.Status = [TaskStatus]::Pending
                $managedTask.Completed = $false
                $managedTask.Progress = 0
            }
            $updatedFields += "Completed"
        }
        
        $managedTask.UpdatedAt = [datetime]::Now
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Updated task $($managedTask.Id) - Fields: $($updatedFields -join ', ')"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Tasks.Changed" -Data @{
            Action = "Updated"
            TaskId = $managedTask.Id
            Task = $managedTask
            UpdatedFields = $updatedFields
        }
        
        return $managedTask
    }
}

function Remove-PmcTask {
    <#
    .SYNOPSIS
    Removes a task from the data store
    
    .DESCRIPTION
    Deletes a task and publishes a Tasks.Changed event
    
    .PARAMETER Task
    The PmcTask object to remove
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcTask]$Task
    )
    
    Invoke-WithErrorHandling -Component "DataManager.RemoveTask" -Context "Removing task from data store" -ScriptBlock {
        # AI: Find and remove task from strongly-typed list
        $taskToRemove = $script:Data.Tasks | Where-Object { $_.Id -eq $Task.Id } | Select-Object -First 1
        
        if ($taskToRemove) {
            $script:Data.Tasks.Remove($taskToRemove) | Out-Null
            $script:DataModified = $true
            
            Write-Log -Level Info -Message "Deleted task $($Task.Id)"
            
            # Auto-save if enabled
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            # AI: Publish event for UI refresh
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Deleted"
                TaskId = $Task.Id
                Task = $Task
            }
            
            return $true
        } else {
            Write-Log -Level Warning -Message "Task not found with ID $($Task.Id)"
            return $false
        }
    }
}

function Get-PmcTasks {
    <#
    .SYNOPSIS
    Retrieves tasks from the data store
    
    .DESCRIPTION
    Returns all tasks or filtered tasks based on criteria
    
    .PARAMETER Completed
    Filter by completion status
    
    .PARAMETER Priority
    Filter by priority level
    
    .PARAMETER Category
    Filter by category/project
    #>
    [CmdletBinding()]
    param(
        [bool]$Completed,
        
        [ValidateSet("low", "medium", "high")]
        [string]$Priority,
        
        [string]$Category
    )
    
    Invoke-WithErrorHandling -Component "DataManager.GetTasks" -Context "Retrieving tasks from data store" -ScriptBlock {
        # AI: Start with all tasks from strongly-typed list
        $tasks = $script:Data.Tasks
        
        # Apply filters if specified
        if ($PSBoundParameters.ContainsKey('Completed')) {
            $tasks = $tasks | Where-Object { $_.Completed -eq $Completed }
        }
        
        if ($Priority) {
            # AI: Convert string to enum for comparison
            $priorityEnum = switch ($Priority.ToLower()) {
                "low" { [TaskPriority]::Low }
                "medium" { [TaskPriority]::Medium }
                "high" { [TaskPriority]::High }
            }
            $tasks = $tasks | Where-Object { $_.Priority -eq $priorityEnum }
        }
        
        if ($Category) {
            $tasks = $tasks | Where-Object { $_.ProjectKey -eq $Category -or $_.Category -eq $Category }
        }
        
        # AI: Return as array to maintain compatibility
        return @($tasks)
    }
}

#endregion

#region Project Management Functions

function Get-PmcProjects {
    <#
    .SYNOPSIS
    Retrieves all projects from the data store
    
    .DESCRIPTION
    Returns all PmcProject objects as an array
    #>
    [CmdletBinding()]
    param()
    
    # AI: Return projects from strongly-typed list as array
    return @($script:Data.Projects)
}

function Get-PmcProject {
    <#
    .SYNOPSIS
    Retrieves a specific project by key
    
    .PARAMETER Key
    The project key
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Key
    )
    
    # AI: Find project in list by key
    return $script:Data.Projects | Where-Object { $_.Key -eq $Key } | Select-Object -First 1
}

function Add-PmcProject {
    <#
    .SYNOPSIS
    Adds a new project to the data store
    
    .PARAMETER Project
    The PmcProject object to add
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [PmcProject]$Project
    )
    
    Invoke-WithErrorHandling -Component "DataManager.AddProject" -Context "Adding new project to data store" -ScriptBlock {
        # AI: Check if project with same key already exists
        $existing = $script:Data.Projects | Where-Object { $_.Key -eq $Project.Key } | Select-Object -First 1
        
        if ($existing) {
            throw [StateMutationException]::new("Project with key '$($Project.Key)' already exists", @{ ProjectKey = $Project.Key })
        }
        
        # AI: Add to strongly-typed project list
        $script:Data.Projects.Add($Project)
        $script:DataModified = $true
        
        Write-Log -Level Info -Message "Created project '$($Project.Name)' with key $($Project.Key)"
        
        # Auto-save if enabled
        if ($script:Data.Settings.AutoSave) {
            Save-UnifiedData
        }
        
        # AI: Publish event for UI refresh
        Publish-Event -EventName "Projects.Changed" -Data @{
            Action = "Created"
            ProjectKey = $Project.Key
            Project = $Project
        }
        
        return $Project
    }
}

#endregion

#region DataManager Class Definition

# AI: Maintain class-based interface for compatibility with existing code
class DataManager {
    hidden [hashtable] $DataStore
    hidden [string] $DataFilePath
    hidden [bool] $AutoSaveEnabled = $true
    
    DataManager() {
        $this.DataStore = $script:Data
        $global:Data = $script:Data # Ensure global state is set
        $this.DataFilePath = $script:DataPath
        $this.AutoSaveEnabled = $this.DataStore.Settings.AutoSave
    }

    [void] LoadData() {
        Load-UnifiedData
    }

    [void] SaveData() {
        Save-UnifiedData
    }

    [PmcTask] AddTask([string]$Title, [string]$Description, [TaskPriority]$Priority, [string]$ProjectKey) {
        return Add-PmcTask -Title $Title -Description $Description -Priority $Priority.ToString() -Category $ProjectKey
    }
    
    [PmcTask[]] GetTasks() {
        return @($this.DataStore.Tasks)
    }
    
    [PmcProject[]] GetProjects() {
        return @($this.DataStore.Projects)
    }
}

#endregion

#region Private Helper Functions

function Initialize-DataEventHandlers {
    <#
    .SYNOPSIS
    Sets up event handlers for data operations
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.InitializeEventHandlers" -Context "Initializing data event handlers" -ScriptBlock {
        # AI: Subscribe to refresh request events for backward compatibility
        $null = Subscribe-Event -EventName "Tasks.RefreshRequested" -Handler {
            param($EventData)
            
            # Simply publish the current task data
            Publish-Event -EventName "Tasks.Changed" -Data @{
                Action = "Refreshed"
                Tasks = @($script:Data.Tasks)
            }
        }
        
        Write-Log -Level Debug -Message "Data event handlers initialized"
    }
}

#endregion

#region Public Initialization Function

function Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data manager service and returns a DataManager instance
    
    .DESCRIPTION
    This function loads existing data, sets up event handlers, and returns
    a DataManager service instance for use by the application.
    #>
    [CmdletBinding()]
    param()
    
    Invoke-WithErrorHandling -Component "DataManager.Initialize" -Context "Initializing data manager service" -ScriptBlock {
        Write-Log -Level Info -Message "Initializing DataManager service"
        
        # Load existing data
        Load-UnifiedData
        
        # Initialize event handlers
        Initialize-DataEventHandlers
        
        # Create and return DataManager instance
        $dataManager = [DataManager]::new()
        
        Write-Log -Level Info -Message "DataManager service initialized successfully"
        
        return $dataManager
    }
}

#endregion

# Export public functions
Export-ModuleMember -Function @(
    'Initialize-DataManager',
    'Add-PmcTask',
    'Update-PmcTask', 
    'Remove-PmcTask',
    'Get-PmcTasks',
    'Get-PmcProjects',
    'Get-PmcProject',
    'Add-PmcProject',
    'Save-UnifiedData',
    'Load-UnifiedData'
)


####\modules\dialog-system.psm1
# Dialog System Module - FIXED VERSION
# Uses engine's word wrap helper and respects the framework

$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

#region --- Public API & Factory Functions ---

function global:Show-TuiDialog {
    <# .SYNOPSIS Internal function to display a dialog component. #>
    param([hashtable]$DialogComponent)
    Invoke-WithErrorHandling -Component "DialogSystem.ShowDialog" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            $script:DialogState.DialogStack.Push($script:DialogState.CurrentDialog)
        }
        $script:DialogState.CurrentDialog = $DialogComponent
        Request-TuiRefresh
    } -Context "Showing dialog: $($DialogComponent.Title)" -AdditionalData @{ DialogType = $DialogComponent.Type; DialogTitle = $DialogComponent.Title }
}

function global:Close-TuiDialog {
    <# .SYNOPSIS Closes the current dialog and restores the previous one, if any. #>
    Invoke-WithErrorHandling -Component "DialogSystem.CloseDialog" -ScriptBlock {
        if ($script:DialogState.DialogStack.Count -gt 0) {
            $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
        } else {
            $script:DialogState.CurrentDialog = $null
        }
        Request-TuiRefresh
    } -Context "Closing current dialog"
}

function global:Show-ConfirmDialog {
    <# .SYNOPSIS Displays a standard Yes/No confirmation dialog. #>
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowConfirmDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("Yes", "No")
            Width         = [Math]::Min(80, [Math]::Max(50, $Message.Length + 10))
            Height        = 10
            OnButtonClick = {
                param($Button, $Index)
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog
                    if ($Index -eq 0) { & $OnConfirm } else { & $OnCancel }
                } -Context "Confirm dialog button click: $Button" -AdditionalData @{ Button = $Button; Index = $Index; DialogTitle = $Title }
            }
            OnCancel      = { 
                Invoke-WithErrorHandling -Component "ConfirmDialog.OnCancel" -ScriptBlock {
                    Close-TuiDialog; & $OnCancel 
                } -Context "Confirm dialog cancelled" -AdditionalData @{ DialogTitle = $Title }
            }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context "Creating confirm dialog: $Title" -AdditionalData @{ Title = $Title; Message = $Message }
}

function global:Show-AlertDialog {
    <# .SYNOPSIS Displays a simple alert with an OK button. #>
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowAlertDialog" -ScriptBlock {
        $dialog = New-TuiDialog -Props @{
            Title         = $Title
            Message       = $Message
            Buttons       = @("OK")
            Width         = [Math]::Min(80, [Math]::Max(40, $Message.Length + 10))
            Height        = 10
            OnButtonClick = { 
                Invoke-WithErrorHandling -Component "AlertDialog.OnButtonClick" -ScriptBlock {
                    Close-TuiDialog 
                } -Context "Alert dialog OK clicked" -AdditionalData @{ DialogTitle = $Title }
            }
            OnCancel      = { 
                Invoke-WithErrorHandling -Component "AlertDialog.OnCancel" -ScriptBlock {
                    Close-TuiDialog 
                } -Context "Alert dialog cancelled" -AdditionalData @{ DialogTitle = $Title }
            }
        }
        Show-TuiDialog -DialogComponent $dialog
    } -Context "Creating alert dialog: $Title" -AdditionalData @{ Title = $Title; Message = $Message }
}

function global:Show-InputDialog {
    <# .SYNOPSIS Displays a dialog to get text input from the user. #>
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowInputDialog" -ScriptBlock {
        # Create a screen that contains the input components
        $inputScreen = @{
            Name = "InputDialog"
            State = @{
                InputValue = $DefaultValue
                FocusedIndex = 0  # Start with textbox focused
            }
            _focusableNames = @("InputTextBox", "OKButton", "CancelButton")
            _focusedIndex = 0
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Name).Render" -ScriptBlock {
                    # Calculate dialog dimensions
                    $dialogWidth = [Math]::Min(70, [Math]::Max(50, $Prompt.Length + 10))
                    $dialogHeight = 10
                    $dialogX = [Math]::Floor(($global:TuiState.BufferWidth - $dialogWidth) / 2)
                    $dialogY = [Math]::Floor(($global:TuiState.BufferHeight - $dialogHeight) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $dialogX -Y $dialogY -Width $dialogWidth -Height $dialogHeight `
                        -Title " $Title " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw prompt
                    $promptX = $dialogX + 2
                    $promptY = $dialogY + 2
                    Write-BufferString -X $promptX -Y $promptY -Text $Prompt
                    
                    # Draw text input
                    $inputY = $promptY + 2
                    $inputWidth = $dialogWidth - 4
                    $isFocused = ($self._focusedIndex -eq 0)
                    $borderColor = if ($isFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    
                    Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 `
                        -BorderColor $borderColor
                    
                    # Draw input value
                    $displayText = $self.State.InputValue
                    if ($displayText.Length -gt ($inputWidth - 3)) {
                        $displayText = $displayText.Substring(0, $inputWidth - 3) # Ensure it fits
                    }
                    Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText
                    
                    # Draw cursor if textbox is focused
                    if ($isFocused) {
                        $cursorPos = [Math]::Min($self.State.InputValue.Length, $inputWidth - 3)
                        Write-BufferString -X ($promptX + 1 + $cursorPos) -Y ($inputY + 1) `
                            -Text "_" -ForegroundColor (Get-ThemeColor "Warning")
                    }
                    
                    # Draw buttons
                    $buttonY = $dialogY + $dialogHeight - 2
                    $buttonSpacing = 15
                    $buttonsWidth = $buttonSpacing * 2
                    $buttonX = $dialogX + [Math]::Floor(($dialogWidth - $buttonsWidth) / 2)
                    
                    # OK button
                    $okFocused = ($self._focusedIndex -eq 1)
                    $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
                    $okColor = if ($okFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
                    
                    # Cancel button
                    $cancelFocused = ($self._focusedIndex -eq 2)
                    $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
                    $cancelColor = if ($cancelFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
                } -Context "Rendering input dialog" -AdditionalData @{ DialogName = $self.Name; Prompt = $Prompt; CurrentValue = $self.State.InputValue }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Name).HandleInput" -ScriptBlock {
                    # Handle Tab navigation
                    if ($Key.Key -eq [ConsoleKey]::Tab) {
                        $direction = if ($Key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                        $self._focusedIndex = ($self._focusedIndex + $direction + 3) % 3
                        Request-TuiRefresh
                        return $true
                    }
                    
                    # Handle Escape
                    if ($Key.Key -eq [ConsoleKey]::Escape) {
                        Close-TuiDialog
                        Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock {
                            & $OnCancel
                        } -Context "Input dialog cancelled via Escape" -AdditionalData @{ DialogTitle = $Title }
                        return $true
                    }
                    
                    # Handle based on focused element
                    switch ($self._focusedIndex) {
                        0 {  # TextBox
                            switch ($Key.Key) {
                                ([ConsoleKey]::Enter) {
                                    Close-TuiDialog
                                    Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock {
                                        & $OnSubmit -Value $self.State.InputValue
                                    } -Context "Input dialog submitted via Enter" -AdditionalData @{ DialogTitle = $Title; InputValue = $self.State.InputValue }
                                    return $true
                                }
                                ([ConsoleKey]::Backspace) {
                                    if ($self.State.InputValue.Length -gt 0) {
                                        $self.State.InputValue = $self.State.InputValue.Substring(0, $self.State.InputValue.Length - 1)
                                        Request-TuiRefresh
                                    }
                                    return $true
                                }
                                default {
                                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                        $self.State.InputValue += $Key.KeyChar
                                        Request-TuiRefresh
                                        return $true
                                    }
                                }
                            }
                        }
                        1 {  # OK Button
                            if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                                Close-TuiDialog
                                Invoke-WithErrorHandling -Component "InputDialog.OnSubmit" -ScriptBlock {
                                    & $OnSubmit -Value $self.State.InputValue
                                } -Context "Input dialog submitted via OK button" -AdditionalData @{ DialogTitle = $Title; InputValue = $self.State.InputValue }
                                return $true
                            }
                        }
                        2 {  # Cancel Button
                            if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                                Close-TuiDialog
                                Invoke-WithErrorHandling -Component "InputDialog.OnCancel" -ScriptBlock {
                                    & $OnCancel
                                } -Context "Input dialog cancelled via Cancel button" -AdditionalData @{ DialogTitle = $Title }
                                return $true
                            }
                        }
                    }
                    
                    return $false
                } -Context "Handling input dialog key press" -AdditionalData @{ DialogName = $self.Name; Key = $Key; FocusedIndex = $self._focusedIndex }
            }
        }
        
        $script:DialogState.CurrentDialog = $inputScreen
        Request-TuiRefresh
    } -Context "Creating input dialog: $Title" -AdditionalData @{ Title = $Title; Prompt = $Prompt; DefaultValue = $DefaultValue }
}

#endregion

#region --- Engine Integration & Initialization ---

function global:Initialize-DialogSystem {
    <# .SYNOPSIS Subscribes to high-level application events to show dialogs. #>
    Invoke-WithErrorHandling -Component "DialogSystem.Initialize" -ScriptBlock {
        Subscribe-Event -EventName "Confirm.Request" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.ConfirmEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-ConfirmDialog @dialogParams
            } -Context "Handling Confirm.Request event" -AdditionalData @{ EventData = $EventData }
        }
        
        Subscribe-Event -EventName "Alert.Show" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.AlertEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-AlertDialog @dialogParams
            } -Context "Handling Alert.Show event" -AdditionalData @{ EventData = $EventData }
        }
        
        Subscribe-Event -EventName "Input.Request" -Handler {
            param($EventData)
            Invoke-WithErrorHandling -Component "DialogSystem.InputEventHandler" -ScriptBlock {
                $dialogParams = $EventData.Data
                Show-InputDialog @dialogParams
            } -Context "Handling Input.Request event" -AdditionalData @{ EventData = $EventData }
        }
        
        Write-Verbose "Dialog System initialized and event handlers registered."
    } -Context "Initializing Dialog System"
}

function global:Render-Dialogs {
    <# .SYNOPSIS Engine Hook: Renders the current dialog over the screen. #>
    Invoke-WithErrorHandling -Component "DialogSystem.RenderDialogs" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            # If it's a component with its own render method
            if ($script:DialogState.CurrentDialog.Render) {
                & $script:DialogState.CurrentDialog.Render -self $script:DialogState.CurrentDialog
            }
        }
    } -Context "Rendering current dialog" -AdditionalData @{ CurrentDialog = $script:DialogState.CurrentDialog.Name }
}

function global:Handle-DialogInput {
    <# .SYNOPSIS Engine Hook: Intercepts input if a dialog is active. #>
    param($Key)
    Invoke-WithErrorHandling -Component "DialogSystem.HandleDialogInput" -ScriptBlock {
        if ($script:DialogState.CurrentDialog) {
            if ($script:DialogState.CurrentDialog.HandleInput) {
                return & $script:DialogState.CurrentDialog.HandleInput -self $script:DialogState.CurrentDialog -Key $Key
            }
        }
        return $false
    } -Context "Handling dialog input" -AdditionalData @{ CurrentDialog = $script:DialogState.CurrentDialog.Name; Key = $Key }
}

function global:Update-DialogSystem {
    <# .SYNOPSIS Engine Hook: Updates dialog system state. #>
    Invoke-WithErrorHandling -Component "DialogSystem.UpdateDialogSystem" -ScriptBlock {
        # Placeholder for any periodic updates needed
    } -Context "Updating dialog system"
}

function global:New-TuiDialog {
    <# .SYNOPSIS Creates a simple dialog component. #>
    param([hashtable]$Props = @{})
    
    $dialog = @{
        Type = "Dialog"
        Title = if ($Props.Title) { $Props.Title } else { "Dialog" }
        Message = if ($Props.Message) { $Props.Message } else { "" }
        Buttons = if ($Props.Buttons) { $Props.Buttons } else { @("OK") }
        SelectedButton = 0
        Width = if ($Props.Width) { $Props.Width } else { 50 }
        Height = if ($Props.Height) { $Props.Height } else { 10 }
        X = 0
        Y = 0
        OnButtonClick = if ($Props.OnButtonClick) { $Props.OnButtonClick } else { {} }
        OnCancel = if ($Props.OnCancel) { $Props.OnCancel } else { {} }
        
        Render = {
            param($self)
            Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                # Center the dialog
                $self.X = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                $self.Y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                
                # Draw dialog box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -Title $self.Title -BorderColor (Get-ThemeColor "Accent")
                
                # Use engine's word wrap helper
                $messageY = $self.Y + 2
                $messageX = $self.X + 2
                $maxWidth = $self.Width - 4
                
                $wrappedLines = Get-WordWrappedLines -Text $self.Message -MaxWidth $maxWidth
                
                foreach ($line in $wrappedLines) {
                    if ($messageY -ge ($self.Y + $self.Height - 3)) { break }  # Don't overwrite buttons
                    Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor (Get-ThemeColor "Primary")
                    $messageY++
                }
                
                # Buttons
                $buttonY = $self.Y + $self.Height - 3
                $totalButtonWidth = ($self.Buttons.Count * 12) + (($self.Buttons.Count - 1) * 2)
                $buttonX = $self.X + [Math]::Floor(($self.Width - $totalButtonWidth) / 2)
                
                for ($i = 0; $i -lt $self.Buttons.Count; $i++) {
                    $isSelected = ($i -eq $self.SelectedButton)
                    $buttonText = if ($isSelected) { "[ $($self.Buttons[$i]) ]" } else { "  $($self.Buttons[$i])  " }
                    $color = if ($isSelected) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                    
                    Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
                    $buttonX += 14
                }
            } -Context "Rendering dialog: $($self.Title)" -AdditionalData @{ DialogTitle = $self.Title; DialogMessage = $self.Message }
        }
        
        HandleInput = {
            param($self, $Key)
            Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                switch ($Key.Key) {
                    ([ConsoleKey]::LeftArrow) {
                        $self.SelectedButton = [Math]::Max(0, $self.SelectedButton - 1)
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        $self.SelectedButton = [Math]::Min($self.Buttons.Count - 1, $self.SelectedButton + 1)
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Tab) {
                        $self.SelectedButton = ($self.SelectedButton + 1) % $self.Buttons.Count
                        Request-TuiRefresh
                        return $true
                    }
                    
                    ([ConsoleKey]::Enter) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnButtonClick" -ScriptBlock {
                            & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                        } -Context "Dialog button clicked: $($self.Buttons[$self.SelectedButton])" -AdditionalData @{ DialogTitle = $self.Title; Button = $self.Buttons[$self.SelectedButton]; Index = $self.SelectedButton }
                        return $true
                    }
                    ([ConsoleKey]::Spacebar) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnButtonClick" -ScriptBlock {
                            & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                        } -Context "Dialog button activated: $($self.Buttons[$self.SelectedButton])" -AdditionalData @{ DialogTitle = $self.Title; Button = $self.Buttons[$self.SelectedButton]; Index = $self.SelectedButton }
                        return $true
                    }
                    ([ConsoleKey]::Escape) {
                        Invoke-WithErrorHandling -Component "$($self.Type).OnCancel" -ScriptBlock {
                            & $self.OnCancel
                        } -Context "Dialog cancelled via Escape" -AdditionalData @{ DialogTitle = $self.Title }
                        return $true
                    }
                }
                
                return $false
            } -Context "Handling dialog input" -AdditionalData @{ DialogTitle = $self.Title; Key = $Key; SelectedButton = $self.SelectedButton }
        }
    }
    
    return $dialog
}

function global:Show-ProgressDialog {
    <# .SYNOPSIS Shows a progress dialog with updating percentage. #>
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowProgressDialog" -ScriptBlock {
        $dialog = @{
            Type = "ProgressDialog"
            Title = $Title
            Message = $Message
            PercentComplete = $PercentComplete
            Width = 60
            Height = 8
            ShowCancel = $ShowCancel
            IsCancelled = $false
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    # Center the dialog
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                    $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                        -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw message
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Message
                    
                    # Draw progress bar
                    $barY = $y + 4
                    $barWidth = $self.Width - 4
                    $filledWidth = [Math]::Floor($barWidth * ($self.PercentComplete / 100))
                    
                    # Progress bar background
                    Write-BufferString -X ($x + 2) -Y $barY `
                        -Text ("─" * $barWidth) -ForegroundColor (Get-ThemeColor "Border")
                    
                    # Progress bar fill
                    if ($filledWidth -gt 0) {
                        Write-BufferString -X ($x + 2) -Y $barY `
                            -Text ("█" * $filledWidth) -ForegroundColor (Get-ThemeColor "Success")
                    }
                    
                    # Percentage text
                    $percentText = "$($self.PercentComplete)%"
                    $percentX = $x + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                    Write-BufferString -X $percentX -Y $barY -Text $percentText
                    
                    # Cancel button if requested
                    if ($self.ShowCancel) {
                        $buttonY = $y + $self.Height - 2
                        $buttonText = if ($self.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
                        $buttonX = $x + [Math]::Floor(($self.Width - $buttonText.Length) / 2)
                        Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText `
                            -ForegroundColor (Get-ThemeColor "Warning")
                    }
                } -Context "Rendering progress dialog" -AdditionalData @{ DialogTitle = $self.Title; Percent = $self.PercentComplete }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    if ($self.ShowCancel -and -not $self.IsCancelled) {
                        if ($Key.Key -eq [ConsoleKey]::Escape -or 
                            $Key.Key -eq [ConsoleKey]::Enter -or 
                            $Key.Key -eq [ConsoleKey]::Spacebar) {
                            $self.IsCancelled = $true
                            Request-TuiRefresh
                            return $true
                        }
                    }
                    
                    return $false
                } -Context "Handling progress dialog input" -AdditionalData @{ DialogTitle = $self.Title; Key = $Key }
            }
            
            UpdateProgress = {
                param($self, [int]$PercentComplete, [string]$Message = $null)
                Invoke-WithErrorHandling -Component "$($self.Type).UpdateProgress" -ScriptBlock {
                    $self.PercentComplete = [Math]::Min(100, [Math]::Max(0, $PercentComplete))
                    if ($Message) { $self.Message = $Message }
                    Request-TuiRefresh
                } -Context "Updating progress dialog" -AdditionalData @{ DialogTitle = $self.Title; NewPercent = $PercentComplete; NewMessage = $Message }
            }
        }
        
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
        return $dialog
    } -Context "Creating progress dialog: $Title" -AdditionalData @{ Title = $Title; Message = $Message; Percent = $PercentComplete }
}

function global:Show-ListDialog {
    <# .SYNOPSIS Shows a dialog with a selectable list of items. #>
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [array]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    Invoke-WithErrorHandling -Component "DialogSystem.ShowListDialog" -ScriptBlock {
        $dialog = @{
            Type = "ListDialog"
            Title = $Title
            Prompt = $Prompt
            Items = $Items
            SelectedIndex = 0
            SelectedItems = @()
            Width = 60
            Height = [Math]::Min(20, $Items.Count + 8)
            AllowMultiple = $AllowMultiple
            
            Render = {
                param($self)
                Invoke-WithErrorHandling -Component "$($self.Type).Render" -ScriptBlock {
                    $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
                    $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
                    
                    # Draw dialog box
                    Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                        -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
                    
                    # Draw prompt
                    Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Prompt
                    
                    # Calculate list area
                    $listY = $y + 4
                    $listHeight = $self.Height - 7
                    $listWidth = $self.Width - 4
                    
                    # Draw scrollable list
                    $startIndex = [Math]::Max(0, $self.SelectedIndex - [Math]::Floor($listHeight / 2))
                    $endIndex = [Math]::Min($self.Items.Count - 1, $startIndex + $listHeight - 1)
                    
                    for ($i = $startIndex; $i -le $endIndex; $i++) {
                        $itemY = $listY + ($i - $startIndex)
                        $item = $self.Items[$i]
                        $isSelected = ($i -eq $self.SelectedIndex)
                        $isChecked = $self.SelectedItems -contains $i
                        
                        # Selection indicator
                        $prefix = ""
                        if ($self.AllowMultiple) {
                            $prefix = if ($isChecked) { "[X] " } else { "[ ] " }
                        }
                        
                        $itemText = "$prefix$item"
                        if ($itemText.Length -gt $listWidth - 2) {
                            $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
                        }
                        
                        $bgColor = if ($isSelected) { Get-ThemeColor "Selection" } else { $null }
                        $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                        
                        Write-BufferString -X ($x + 2) -Y $itemY -Text $itemText `
                            -ForegroundColor $fgColor -BackgroundColor $bgColor
                    }
                    
                    # Draw scrollbar if needed
                    if ($self.Items.Count -gt $listHeight) {
                        $scrollbarX = $x + $self.Width - 2
                        $scrollbarHeight = $listHeight
                        $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $self.Items.Count))
                        $thumbPos = [Math]::Floor($scrollbarHeight * $self.SelectedIndex / $self.Items.Count)
                        
                        for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                            $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                            Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char `
                                -ForegroundColor (Get-ThemeColor "Border")
                        }
                    }
                    
                    # Draw buttons
                    $buttonY = $y + $self.Height - 2
                    if ($self.AllowMultiple) {
                        $okText = "[ OK ]"
                        $cancelText = "[ Cancel ]"
                        $buttonSpacing = 15
                        $totalWidth = 30
                        $startX = $x + [Math]::Floor(($self.Width - $totalWidth) / 2)
                        
                        Write-BufferString -X $startX -Y $buttonY -Text $okText `
                            -ForegroundColor (Get-ThemeColor "Success")
                        Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText `
                            -ForegroundColor (Get-ThemeColor "Primary")
                    }
                } -Context "Rendering list dialog" -AdditionalData @{ DialogTitle = $self.Title; Prompt = $self.Prompt; SelectedIndex = $self.SelectedIndex }
            }
            
            HandleInput = {
                param($self, $Key)
                Invoke-WithErrorHandling -Component "$($self.Type).HandleInput" -ScriptBlock {
                    switch ($Key.Key) {
                        ([ConsoleKey]::UpArrow) {
                            $self.SelectedIndex = [Math]::Max(0, $self.SelectedIndex - 1)
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::DownArrow) {
                            $self.SelectedIndex = [Math]::Min($self.Items.Count - 1, $self.SelectedIndex + 1)
                            Request-TuiRefresh
                            return $true
                        }
                        ([ConsoleKey]::Spacebar) {
                            if ($self.AllowMultiple) {
                                if ($self.SelectedItems -contains $self.SelectedIndex) {
                                    $self.SelectedItems = $self.SelectedItems | Where-Object { $_ -ne $self.SelectedIndex }
                                } else {
                                    $self.SelectedItems += $self.SelectedIndex
                                }
                                Request-TuiRefresh
                                return $true
                            }
                        }
                        ([ConsoleKey]::Enter) {
                            Close-TuiDialog
                            if ($self.AllowMultiple) {
                                $selectedValues = $self.SelectedItems | ForEach-Object { $self.Items[$_] }
                                Invoke-WithErrorHandling -Component "ListDialog.OnSelect" -ScriptBlock {
                                    & $OnSelect -Selected $selectedValues
                                } -Context "List dialog multi-select completed" -AdditionalData @{ DialogTitle = $self.Title; SelectedValues = $selectedValues }
                            } else {
                                Invoke-WithErrorHandling -Component "ListDialog.OnSelect" -ScriptBlock {
                                    & $OnSelect -Selected $self.Items[$self.SelectedIndex]
                                } -Context "List dialog selection completed" -AdditionalData @{ DialogTitle = $self.Title; SelectedValue = $self.Items[$self.SelectedIndex] }
                            }
                            return $true
                        }
                        ([ConsoleKey]::Escape) {
                            Close-TuiDialog
                            Invoke-WithErrorHandling -Component "ListDialog.OnCancel" -ScriptBlock {
                                & $OnCancel
                            } -Context "List dialog cancelled" -AdditionalData @{ DialogTitle = $self.Title }
                            return $true
                        }
                    }
                    
                    return $false
                } -Context "Handling list dialog input" -AdditionalData @{ DialogTitle = $self.Title; Key = $Key; SelectedIndex = $self.SelectedIndex }
            }
        }
        
        $script:DialogState.CurrentDialog = $dialog
        Request-TuiRefresh
    } -Context "Creating list dialog: $Title" -AdditionalData @{ Title = $Title; Prompt = $Prompt; ItemsCount = $Items.Count }
}

#endregion

# Export all public functions
Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-TuiDialog',
    'Close-TuiDialog',
    'Show-ConfirmDialog',
    'Show-AlertDialog',
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Render-Dialogs',
    'Handle-DialogInput',
    'Update-DialogSystem',
    'New-TuiDialog'
)



####\modules\event-system.psm1
# Event System Module
# Provides pub/sub event functionality for decoupled communication

$script:EventHandlers = @{}
$script:EventHistory = @()
$script:MaxEventHistory = 100

function global:Initialize-EventSystem {
    <#
    .SYNOPSIS
    Initializes the event system for the application
    #>
    Invoke-WithErrorHandling -Component "EventSystem.Initialize" -Context "Initializing event system" -ScriptBlock {
        $script:EventHandlers = @{}
        $script:EventHistory = @()
        Write-Verbose "Event system initialized"
    }
}

function global:Publish-Event {
    <#
    .SYNOPSIS
    Publishes an event to all registered handlers
    
    .PARAMETER EventName
    The name of the event to publish
    
    .PARAMETER Data
    Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    Invoke-WithErrorHandling -Component "EventSystem.PublishEvent" -Context "Publishing event '$EventName'" -ScriptBlock {
        # Record event in history
        $eventRecord = @{
            EventName = $EventName
            Data = $Data
            Timestamp = Get-Date
        }
        
        $script:EventHistory += $eventRecord
        if ($script:EventHistory.Count -gt $script:MaxEventHistory) {
            $script:EventHistory = $script:EventHistory[-$script:MaxEventHistory..-1]
        }
        
        # Execute handlers
        if ($script:EventHandlers.ContainsKey($EventName)) {
            foreach ($handler in $script:EventHandlers[$EventName]) {
                try { # Internal try/catch for handler execution
                    $eventData = @{
                        EventName = $EventName
                        Data = $Data
                        Timestamp = $eventRecord.Timestamp
                    }
                    
                    & $handler.ScriptBlock -EventData $eventData
                } catch {
                    Write-Log -Level Warning -Message "Error in event handler for '$EventName' (Handler ID: $($handler.HandlerId)): $_" -Data @{ EventName = $EventName; HandlerId = $handler.HandlerId; Exception = $_ }
                }
            }
        }
        
        Write-Verbose "Published event: $EventName"
    } -AdditionalData @{ EventName = $EventName; EventData = $Data }
}

function global:Subscribe-Event {
    <#
    .SYNOPSIS
    Subscribes to an event with a handler
    
    .PARAMETER EventName
    The name of the event to subscribe to
    
    .PARAMETER Handler
    The script block to execute when the event is published
    
    .PARAMETER HandlerId
    Optional unique identifier for the handler
    
    .PARAMETER Source
    Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$Handler,
        
        [Parameter()]
        [string]$HandlerId = [Guid]::NewGuid().ToString(),
        
        [Parameter()]
        [string]$Source = $null
    )
    Invoke-WithErrorHandling -Component "EventSystem.SubscribeEvent" -Context "Subscribing to event '$EventName'" -ScriptBlock {
        if (-not $script:EventHandlers.ContainsKey($EventName)) {
            $script:EventHandlers[$EventName] = @()
        }
        
        $handlerInfo = @{
            HandlerId = $HandlerId
            ScriptBlock = $Handler
            SubscribedAt = Get-Date
            Source = $Source
        }
        
        $script:EventHandlers[$EventName] += $handlerInfo
        
        Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
        
        # Only return handler ID, don't print it
        return $HandlerId
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId; Source = $Source }
}

function global:Unsubscribe-Event {
    <#
    .SYNOPSIS
    Unsubscribes from an event
    
    .PARAMETER EventName
    The name of the event to unsubscribe from (optional if HandlerId is provided)
    
    .PARAMETER HandlerId
    The unique identifier of the handler to remove
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [string]$HandlerId
    )
    Invoke-WithErrorHandling -Component "EventSystem.UnsubscribeEvent" -Context "Unsubscribing from event '$EventName' (Handler: $HandlerId)" -ScriptBlock {
        if ($EventName) {
            # Fast path when event name is known
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
                
                if ($script:EventHandlers[$EventName].Count -eq 0) {
                    $script:EventHandlers.Remove($EventName)
                }
                
                Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
            }
        } else {
            # Search all events for the handler ID
            $found = $false
            foreach ($eventKey in @($script:EventHandlers.Keys)) {
                $handlers = $script:EventHandlers[$eventKey]
                $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
                
                if ($newHandlers.Count -lt $handlers.Count) {
                    $found = $true
                    if ($newHandlers.Count -eq 0) {
                        $script:EventHandlers.Remove($eventKey)
                    } else {
                        $script:EventHandlers[$eventKey] = $newHandlers
                    }
                    Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"
                    break
                }
            }
            
            if (-not $found) {
                Write-Warning "Handler ID not found: $HandlerId"
            }
        }
    } -AdditionalData @{ EventName = $EventName; HandlerId = $HandlerId }
}

function global:Get-EventHandlers {
    <#
    .SYNOPSIS
    Gets all registered event handlers
    
    .PARAMETER EventName
    Optional event name to filter by
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    Invoke-WithErrorHandling -Component "EventSystem.GetEventHandlers" -Context "Getting event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                return $script:EventHandlers[$EventName]
            } else {
                return @()
            }
        } else {
            return $script:EventHandlers
        }
    } -AdditionalData @{ EventName = $EventName }
}

function global:Clear-EventHandlers {
    <#
    .SYNOPSIS
    Clears all event handlers for a specific event or all events
    
    .PARAMETER EventName
    Optional event name to clear handlers for
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    Invoke-WithErrorHandling -Component "EventSystem.ClearEventHandlers" -Context "Clearing event handlers for '$EventName'" -ScriptBlock {
        if ($EventName) {
            if ($script:EventHandlers.ContainsKey($EventName)) {
                $script:EventHandlers.Remove($EventName)
                Write-Verbose "Cleared handlers for event: $EventName"
            }
        } else {
            $script:EventHandlers = @{}
            Write-Verbose "Cleared all event handlers"
        }
    } -AdditionalData @{ EventName = $EventName }
}

function global:Get-EventHistory {
    <#
    .SYNOPSIS
    Gets the event history
    
    .PARAMETER EventName
    Optional event name to filter by
    
    .PARAMETER Last
    Number of recent events to return
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter()]
        [int]$Last = 0
    )
    Invoke-WithErrorHandling -Component "EventSystem.GetEventHistory" -Context "Getting event history for '$EventName'" -ScriptBlock {
        $history = $script:EventHistory
        
        if ($EventName) {
            $history = $history | Where-Object { $_.EventName -eq $EventName }
        }
        
        if ($Last -gt 0) {
            $history = $history | Select-Object -Last $Last
        }
        
        return $history
    } -AdditionalData @{ EventName = $EventName; LastCount = $Last }
}

function global:Remove-ComponentEventHandlers {
    <#
    .SYNOPSIS
    Removes all event handlers associated with a specific component
    
    .PARAMETER ComponentId
    The ID of the component whose handlers should be removed
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ComponentId
    )
    Invoke-WithErrorHandling -Component "EventSystem.RemoveComponentEventHandlers" -Context "Removing event handlers for component '$ComponentId'" -ScriptBlock {
        $removedCount = 0
        
        # Iterate through all events and remove handlers with matching component ID
        foreach ($eventName in @($script:EventHandlers.Keys)) {
            $handlers = $script:EventHandlers[$eventName]
            $newHandlers = @()
            
            foreach ($handler in $handlers) {
                # Check if handler has Source property matching ComponentId
                if ($handler.Source -ne $ComponentId) {
                    $newHandlers += $handler
                } else {
                    $removedCount++
                }
            }
            
            if ($newHandlers.Count -eq 0) {
                $script:EventHandlers.Remove($eventName)
            } else {
                $script:EventHandlers[$eventName] = $newHandlers
            }
        }
        
        Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
    } -AdditionalData @{ ComponentId = $ComponentId }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-EventSystem',
    'Publish-Event',
    'Subscribe-Event',
    'Unsubscribe-Event',
    'Get-EventHandlers',
    'Clear-EventHandlers',
    'Get-EventHistory',
    'Remove-ComponentEventHandlers'
)


####\modules\exceptions.psm1
#
# MODULE: exceptions.psm1
# PURPOSE: Provides custom exception types and a centralized error handling wrapper
# for the PMC Terminal application. This ensures all errors are consistently logged
# with rich contextual information.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

# A running history of the most recent errors encountered in the application.
$script:ErrorHistory = [System.Collections.Generic.List[object]]::new()
$script:MaxErrorHistory = 100 # Keep a reasonable number of recent errors.

# ------------------------------------------------------------------------------
# Custom Exception Type Definition
# ------------------------------------------------------------------------------

# Define custom exception types using C# via Add-Type. This provides strongly-typed
# exceptions that can be caught specifically throughout the application.
try {
    # Only add the type if it doesn't already exist to prevent errors on module re-import.
    if (-not ('Helios.HeliosException' -as [type])) {
        Add-Type -TypeDefinition @"
        using System;
        using System.Management.Automation;
        using System.Collections;

        namespace Helios {
            // Base exception for all custom application errors. Inherits from RuntimeException for better PowerShell integration.
            public class HeliosException : System.Management.Automation.RuntimeException {
                public Hashtable DetailedContext { get; set; }
                public string Component { get; set; }
                public DateTime Timestamp { get; set; }

                public HeliosException(string message, string component, Hashtable detailedContext, Exception innerException)
                    : base(message, innerException)
                {
                    this.Component = component ?? "Unknown";
                    this.DetailedContext = detailedContext ?? new Hashtable();
                    this.Timestamp = DateTime.Now;
                }
            }

            // Specific exception types for better categorization and targeted catch blocks.
            public class NavigationException : HeliosException { public NavigationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ServiceInitializationException : HeliosException { public ServiceInitializationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class ComponentRenderException : HeliosException { public ComponentRenderException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class StateMutationException : HeliosException { public StateMutationException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class InputHandlingException : HeliosException { public InputHandlingException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
            public class DataLoadException : HeliosException { public DataLoadException(string m, string c, Hashtable ctx, Exception i) : base(m, c, ctx, i) { } }
        }
"@ -ErrorAction Stop
        # This log message will only appear if the logger is already imported and the log level is appropriate.
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Custom Helios exception types compiled successfully."
        }
    }
} catch {
    # If Add-Type fails, this is a critical environment issue. Log it prominently.
    # The application will fall back to using standard RuntimeExceptions.
    Write-Warning "CRITICAL: Failed to compile custom Helios exception types: $($_.Exception.Message). The application will lack detailed error information."
}


# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

# Identifies the component/module where an error originated based on the call stack.
function _Identify-HeliosComponent {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord
    )
    try {
        $scriptName = $ErrorRecord.InvocationInfo.ScriptName
        if (-not $scriptName) {
            # Walk the call stack to find the first script file.
            $callStack = Get-PSCallStack
            foreach ($frame in $callStack) {
                if ($frame.ScriptName) {
                    $scriptName = $frame.ScriptName
                    break
                }
            }
        }

        if (-not $scriptName) { return "Interactive/Unknown" }

        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($scriptName)

        # Map filenames to logical application components according to the new file structure.
        $componentMap = @{
            'tui-engine'        = 'TUI Engine'
            'navigation'        = 'Navigation Service'
            'keybindings'       = 'Keybinding Service'
            'task-service'      = 'Task Service'
            'helios-components' = 'Helios UI Components'
            'helios-panels'     = 'Helios UI Panels'
            'dashboard-screen'  = 'Dashboard Screen'
            'task-screen'       = 'Task Screen'
            'exceptions'        = 'Exception Module'
            'logger'            = 'Logger Module'
            'Start-PMCTerminal' = 'Application Entry'
        }

        foreach ($pattern in $componentMap.Keys) {
            if ($fileName -like "*$pattern*") {
                return $componentMap[$pattern]
            }
        }

        return "Unknown ($fileName)"

    } catch {
        return "Component Identification Failed"
    }
}

# Gathers extensive details about an error for logging and debugging.
function _Get-DetailedError {
    param(
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        [hashtable]$AdditionalContext = @{}
    )
    try {
        $errorInfo = [PSCustomObject]@{
            Timestamp         = Get-Date -Format "o"
            Summary           = $ErrorRecord.Exception.Message
            Type              = $ErrorRecord.Exception.GetType().FullName
            Category          = $ErrorRecord.CategoryInfo.Category.ToString()
            TargetObject      = $ErrorRecord.TargetObject
            ScriptName        = $ErrorRecord.InvocationInfo.ScriptName
            LineNumber        = $ErrorRecord.InvocationInfo.ScriptLineNumber
            Line              = $ErrorRecord.InvocationInfo.Line
            PositionMessage   = $ErrorRecord.InvocationInfo.PositionMessage
            StackTrace        = $ErrorRecord.Exception.StackTrace
            InnerExceptions   = @()
            AdditionalContext = $AdditionalContext
            SystemContext     = @{
                ProcessId         = $PID
                ThreadId          = [System.Threading.Thread]::CurrentThread.ManagedThreadId
                PowerShellVersion = $PSVersionTable.PSVersion.ToString()
                OS                = $PSVersionTable.OS
            }
        }

        $innerEx = $ErrorRecord.Exception.InnerException
        while ($innerEx) {
            $errorInfo.InnerExceptions += [PSCustomObject]@{
                Message    = $innerEx.Message
                Type       = $innerEx.GetType().FullName
                StackTrace = $innerEx.StackTrace
            }
            $innerEx = $innerEx.InnerException
        }

        return $errorInfo

    } catch {
        # Fallback if the error analysis itself fails.
        return [PSCustomObject]@{
            Timestamp     = Get-Date -Format "o"
            Summary       = "CRITICAL: Error analysis failed."
            OriginalError = $ErrorRecord.Exception.Message
            AnalysisError = $_.Exception.Message
            Type          = "ErrorAnalysisFailure"
        }
    }
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [scriptblock]$ScriptBlock,
        [Parameter(Mandatory)]
        [string]$Component,
        [Parameter(Mandatory)]
        [string]$Context, # A simple string describing the operation, e.g., "Loading tasks from disk".
        [hashtable]$AdditionalData = @{}
    )

    # Defensive checks
    if ($null -eq $ScriptBlock) {
        # This is a programming error, so we throw directly.
        throw "Invoke-WithErrorHandling: ScriptBlock parameter cannot be null."
    }
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown Component"
    }
    if ([string]::IsNullOrWhiteSpace($Context)) {
        $Context = "Unknown Operation"
    }

    try {
        # Execute the provided scriptblock.
        return (& $ScriptBlock)
    }
    catch {
        # This block catches any terminating error from the ScriptBlock.
        $originalErrorRecord = $_

        # 1. Identify the component where the error occurred.
        $identifiedComponent = _Identify-HeliosComponent -ErrorRecord $originalErrorRecord
        $finalComponent = if ($Component -ne "Unknown Component") { $Component } else { $identifiedComponent }

        # 2. Gather all possible details about the error.
        $errorContext = @{
            Operation = $Context
        }
        # Merge additional data provided by the caller.
        $AdditionalData.GetEnumerator() | ForEach-Object { $errorContext[$_.Name] = $_.Value }
        $detailedError = _Get-DetailedError -ErrorRecord $originalErrorRecord -AdditionalContext $errorContext

        # 3. Log the error using the logger module.
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$finalComponent' during '$Context': $($originalErrorRecord.Exception.Message)" -Data $detailedError
        }

        # 4. Add the detailed error to the in-memory history for debugging.
        [void]$script:ErrorHistory.Add($detailedError)
        if ($script:ErrorHistory.Count -gt $script:MaxErrorHistory) {
            $script:ErrorHistory.RemoveAt(0)
        }

        # 5. Create a new, rich, strongly-typed exception and throw it.
        # This allows upstream code to catch '[Helios.HeliosException]' specifically.
        # AI: Create a simplified context hashtable to avoid serialization issues
        $contextHashtable = @{
            Operation = $Context
            Timestamp = $detailedError.Timestamp
            LineNumber = $detailedError.LineNumber
            ScriptName = if ($detailedError.ScriptName) { [string]$detailedError.ScriptName } else { "Unknown" }
        }
        
        # AI: Add simple additional data only
        foreach ($key in $AdditionalData.Keys) {
            $value = $AdditionalData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) {
                $contextHashtable[$key] = $value
            }
        }
        
        $heliosException = New-Object Helios.HeliosException(
            $originalErrorRecord.Exception.Message,
            $finalComponent,
            $contextHashtable,
            $originalErrorRecord.Exception
        )
        
        # Re-throw the rich exception to allow for top-level handling.
        throw $heliosException
    }
}

function Get-ErrorHistory {
    [CmdletBinding()]
    param(
        [int]$Count = 25
    )
    
    $total = $script:ErrorHistory.Count
    if ($Count -ge $total) {
        return $script:ErrorHistory
    }

    $start = $total - $Count
    return $script:ErrorHistory.GetRange($start, $Count)
}


Export-ModuleMember -Function @(
    'Invoke-WithErrorHandling',
    'Get-ErrorHistory'
)

# NOTE: Custom types defined with Add-Type are automatically available to the session
# after the module is imported. They do not need to be explicitly exported.



####\modules\logger.psm1
#
# MODULE: logger.psm1
# PURPOSE: Provides a robust, granular logging system for the PMC Terminal application.
# This module is self-contained and manages its own state for logging configuration and in-memory log queues.
#

# ------------------------------------------------------------------------------
# Module-Scoped State Variables
# ------------------------------------------------------------------------------

# NOTE: The use of '$script:' scope is intentional and correct for managing state
# internal to this module. It does not violate the project's scope purity rules,
# which are designed to prevent state sharing *between* modules.

$script:LogPath = $null
$script:LogLevel = "Info" # Default log level.
$script:LogQueue = [System.Collections.Generic.List[object]]::new() # Use a generic list for better performance over @()
$script:MaxLogSize = 5MB
$script:LogInitialized = $false
$script:CallDepth = 0
$script:TraceAllCalls = $false

# ------------------------------------------------------------------------------
# Private Helper Functions
# ------------------------------------------------------------------------------

# Internal helper to safely serialize objects for logging, preventing circular references or errors.
function ConvertTo-SerializableObject {
    param([object]$Object)

    if ($null -eq $Object) { return $null }

    # Use a set to track visited objects to prevent infinite recursion
    $visited = New-Object 'System.Collections.Generic.HashSet[object]'

    function Convert-Internal {
        param([object]$InputObject, [int]$Depth)

        if ($null -eq $InputObject -or $Depth -gt 5) { return $null }
        if ($InputObject -is [System.Management.Automation.ScriptBlock]) { return '<ScriptBlock>' }
        if ($visited.Contains($InputObject)) { return '<CircularReference>' }
        
        # For non-collection reference types, add to visited set
        if (-not $InputObject.GetType().IsValueType -and -not ($InputObject -is [string])) {
            [void]$visited.Add($InputObject)
        }

        switch ($InputObject.GetType().Name) {
            'Hashtable' {
                $result = @{}
                foreach ($key in $InputObject.Keys) {
                    try {
                        $result[$key] = Convert-Internal -InputObject $InputObject[$key] -Depth ($Depth + 1)
                    } catch {
                        $result[$key] = "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                return $result
            }
            'PSCustomObject' {
                $result = @{}
                foreach ($prop in $InputObject.PSObject.Properties) {
                    try {
                        # Avoid serializing script methods
                        if ($prop.MemberType -ne 'ScriptMethod') {
                           $result[$prop.Name] = Convert-Internal -InputObject $prop.Value -Depth ($Depth + 1)
                        }
                    } catch {
                        $result[$prop.Name] = "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                return $result
            }
            'Object[]' {
                $result = @()
                # Limit array size for performance
                for ($i = 0; $i -lt [Math]::Min($InputObject.Count, 10); $i++) {
                    try {
                        $result += Convert-Internal -InputObject $InputObject[$i] -Depth ($Depth + 1)
                    } catch {
                        $result += "<SerializationError: $($_.Exception.Message)>"
                    }
                }
                if ($InputObject.Count -gt 10) {
                    $result += "<... $($InputObject.Count - 10) more items>"
                }
                return $result
            }
            default {
                try {
                    # For simple types, return as-is or convert to string
                    if ($InputObject -is [string] -or $InputObject -is [int] -or $InputObject -is [bool] -or $InputObject -is [double] -or $InputObject -is [datetime] -or $InputObject -is [decimal]) {
                        return $InputObject
                    } else {
                        return $InputObject.ToString()
                    }
                } catch {
                    return "<ToString failed: $($_.Exception.Message)>"
                }
            }
        }
    }

    return Convert-Internal -InputObject $Object -Depth 0
}

# ------------------------------------------------------------------------------
# Public Functions
# ------------------------------------------------------------------------------

function Initialize-Logger {
    [CmdletBinding()]
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Debug"
    )

    # Defensive checks
    if ([string]::IsNullOrWhiteSpace($LogDirectory)) {
        Write-Warning "Initialize-Logger: LogDirectory parameter cannot be null or empty."
        return
    }
    if ([string]::IsNullOrWhiteSpace($LogFileName)) {
        Write-Warning "Initialize-Logger: LogFileName parameter cannot be null or empty."
        return
    }

    try {
        if (-not (Test-Path $LogDirectory)) {
            New-Item -ItemType Directory -Path $LogDirectory -Force -ErrorAction Stop | Out-Null
        }

        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true

        Write-Log -Level Info -Message "Logger initialized" -Data @{
            LogPath           = $script:LogPath
            PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            OS                = $PSVersionTable.OS
            ProcessId         = $PID
            InitializedAt     = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        } -Force # Force this initial message to be written

    } catch {
        Write-Warning "Failed to initialize logger: $_"
        $script:LogInitialized = $false
    }
}

function Write-Log {
    [CmdletBinding()]
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level = "Info",
        [Parameter(Mandatory)]
        [string]$Message,
        [object]$Data,
        [switch]$Force # Force logging even if level is below threshold
    )

    if (-not $script:LogInitialized -and -not $Force) { return }

    $levelPriority = @{
        Debug   = 0
        Trace   = 0
        Verbose = 1
        Info    = 2
        Warning = 3
        Error   = 4
        Fatal   = 5
    }

    if (-not $Force -and $levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }

    try {
        $callStack = Get-PSCallStack
        $caller = if ($callStack.Count -gt 1) { $callStack[1] } else { $callStack[0] }

        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId

        $logContext = @{
            Timestamp     = $timestamp
            Level         = $Level
            ThreadId      = $threadId
            CallDepth     = $script:CallDepth
            Message       = $Message
            Caller        = @{
                Command      = $caller.Command
                Location     = $caller.Location
                ScriptName   = $caller.ScriptName
                LineNumber   = $caller.ScriptLineNumber
            }
        }

        if ($PSBoundParameters.ContainsKey('Data')) {
            $logContext.UserData = if ($Data -is [Exception]) {
                @{
                    Type           = "Exception"
                    Message        = $Data.Message
                    StackTrace     = $Data.StackTrace
                    InnerException = if ($Data.InnerException) { $Data.InnerException.Message } else { $null }
                }
            } else {
                ConvertTo-SerializableObject -Object $Data
            }
        }

        $indent = "  " * $script:CallDepth
        $callerInfo = if ($caller.ScriptName) {
            "$([System.IO.Path]::GetFileName($caller.ScriptName)):$($caller.ScriptLineNumber)"
        } else {
            $caller.Command
        }

        $logEntry = "$timestamp [$($Level.PadRight(7))] $indent [$callerInfo] $Message"

        if ($PSBoundParameters.ContainsKey('Data')) {
            $dataStr = if ($Data -is [Exception]) {
                "`n${indent}  Exception: $($Data.Message)`n${indent}  StackTrace: $($Data.StackTrace)"
            } else {
                try {
                    $json = ConvertTo-SerializableObject -Object $Data | ConvertTo-Json -Compress -Depth 4 -WarningAction SilentlyContinue
                    "`n${indent}  Data: $json"
                } catch {
                    "`n${indent}  Data: $($Data.ToString())"
                }
            }
            $logEntry += $dataStr
        }

        $script:LogQueue.Add($logContext)
        if ($script:LogQueue.Count -gt 2000) {
            $script:LogQueue.RemoveRange(0, $script:LogQueue.Count - 2000)
        }

        if ($script:LogPath) {
            try {
                if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) {
                    $archivePath = $script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                    Move-Item $script:LogPath $archivePath -Force
                }
                Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8 -Force
            } catch {
                Write-Host "LOG WRITE FAILED: $logEntry" -ForegroundColor Yellow
                Write-Host "Error: $_" -ForegroundColor Red
            }
        }

        if ($Level -in @('Error', 'Fatal', 'Warning')) {
            $color = if ($Level -in @('Error', 'Fatal')) { 'Red' } else { 'Yellow' }
            Write-Host $logEntry -ForegroundColor $color
        }

    } catch {
        try {
            $errorEntry = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff') [LOGGER ERROR] Failed to log message '$Message': $_"
            if ($script:LogPath) {
                Add-Content -Path $script:LogPath -Value $errorEntry -Encoding UTF8
            }
            Write-Host $errorEntry -ForegroundColor Red
        } catch {
            Write-Host "CRITICAL: Logger completely failed: $_" -ForegroundColor Red
        }
    }
}

function Trace-FunctionEntry {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FunctionName,
        [object]$Parameters
    )
    if (-not $script:TraceAllCalls) { return }
    $script:CallDepth++
    Write-Log -Level Trace -Message "ENTER: $FunctionName" -Data @{
        Parameters = $Parameters
        Action     = "FunctionEntry"
    }
}

function Trace-FunctionExit {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$FunctionName,
        [object]$ReturnValue,
        [switch]$WithError
    )
    if (-not $script:TraceAllCalls) { return }
    Write-Log -Level Trace -Message "EXIT: $FunctionName" -Data @{
        ReturnValue = $ReturnValue
        Action      = if ($WithError) { "FunctionExitWithError" } else { "FunctionExit" }
        HasError    = $WithError.IsPresent
    }
    $script:CallDepth--
    if ($script:CallDepth -lt 0) { $script:CallDepth = 0 }
}

function Trace-Step {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$StepName,
        [object]$StepData,
        [string]$Module
    )
    $caller = (Get-PSCallStack)[1]
    $moduleInfo = if ($Module) { $Module } elseif ($caller.ScriptName) { [System.IO.Path]::GetFileNameWithoutExtension($caller.ScriptName) } else { "Unknown" }

    Write-Log -Level Debug -Message "STEP: $StepName" -Data @{
        StepData = $StepData
        Module   = $moduleInfo
        Action   = "Step"
    }
}

function Trace-StateChange {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$StateType,
        [object]$OldValue,
        [object]$NewValue,
        [string]$PropertyPath
    )
    Write-Log -Level Debug -Message "STATE: $StateType changed" -Data @{
        StateType    = $StateType
        PropertyPath = $PropertyPath
        OldValue     = $OldValue
        NewValue     = $NewValue
        Action       = "StateChange"
    }
}

function Trace-ComponentLifecycle {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ComponentType,
        [Parameter(Mandatory)]
        [string]$ComponentId,
        [Parameter(Mandatory)]
        [ValidateSet('Create', 'Initialize', 'Render', 'Update', 'Destroy')]
        [string]$Phase,
        [object]$ComponentData
    )
    Write-Log -Level Debug -Message "COMPONENT: $ComponentType [$ComponentId] $Phase" -Data @{
        ComponentType = $ComponentType
        ComponentId   = $ComponentId
        Phase         = $Phase
        ComponentData = $ComponentData
        Action        = "ComponentLifecycle"
    }
}

function Trace-ServiceCall {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ServiceName,
        [Parameter(Mandatory)]
        [string]$MethodName,
        [object]$Parameters,
        [object]$Result,
        [switch]$IsError
    )
    $action = if ($IsError) { "ServiceCallError" } else { "ServiceCall" }
    Write-Log -Level Debug -Message "SERVICE: $ServiceName.$MethodName" -Data @{
        ServiceName = $ServiceName
        MethodName  = $MethodName
        Parameters  = $Parameters
        Result      = $Result
        Action      = $action
        IsError     = $IsError.IsPresent
    }
}

function Get-LogEntries {
    [CmdletBinding()]
    param(
        [int]$Count = 100,
        [string]$Level,
        [string]$Module,
        [string]$Action
    )
    try {
        $entries = $script:LogQueue.ToArray() # Work on a copy

        if ($Level) {
            $entries = $entries | Where-Object { $_.Level -eq $Level }
        }
        if ($Module) {
            $entries = $entries | Where-Object { $_.Caller.ScriptName -and ([System.IO.Path]::GetFileNameWithoutExtension($_.Caller.ScriptName) -like "*$Module*") }
        }
        if ($Action) {
            $entries = $entries | Where-Object { $_.UserData.Action -eq $Action }
        }

        return $entries | Select-Object -Last $Count
    } catch {
        Write-Warning "Error getting log entries: $_"
        return @()
    }
}

function Get-CallTrace {
    [CmdletBinding()]
    param([int]$Depth = 10)

    try {
        $callStack = Get-PSCallStack
        $trace = @()

        for ($i = 1; $i -lt [Math]::Min($callStack.Count, $Depth + 1); $i++) { # Skip self
            $call = $callStack[$i]
            $trace += @{
                Level      = $i - 1
                Command    = $call.Command
                Location   = $call.Location
                ScriptName = $call.ScriptName
                LineNumber = $call.ScriptLineNumber
            }
        }
        return $trace
    } catch {
        Write-Warning "Error getting call trace: $_"
        return @()
    }
}

function Clear-LogQueue {
    param()
    try {
        $script:LogQueue.Clear()
        Write-Log -Level Info -Message "In-memory log queue cleared"
    } catch {
        Write-Warning "Error clearing log queue: $_"
    }
}

function Set-LogLevel {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error", "Fatal", "Trace")]
        [string]$Level
    )
    try {
        $oldLevel = $script:LogLevel
        $script:LogLevel = $Level
        Write-Log -Level Info -Message "Log level changed from '$oldLevel' to '$Level'" -Force
    } catch {
        Write-Warning "Error setting log level to '$Level': $_"
    }
}

function Enable-CallTracing {
    param()
    $script:TraceAllCalls = $true
    Write-Log -Level Info -Message "Call tracing enabled" -Force
}

function Disable-CallTracing {
    param()
    $script:TraceAllCalls = $false
    Write-Log -Level Info -Message "Call tracing disabled" -Force
}

function Get-LogPath {
    param()
    return $script:LogPath
}

function Get-LogStatistics {
    param()
    try {
        $stats = [PSCustomObject]@{
            TotalEntries       = $script:LogQueue.Count
            LogPath            = $script:LogPath
            LogLevel           = $script:LogLevel
            CallTracingEnabled = $script:TraceAllCalls
            LogFileSize        = if ($script:LogPath -and (Test-Path $script:LogPath)) { (Get-Item $script:LogPath).Length } else { 0 }
            EntriesByLevel     = @{}
            EntriesByModule    = @{}
            EntriesByAction    = @{}
        }

        foreach ($entry in $script:LogQueue) {
            $level = $entry.Level
            if (-not $stats.EntriesByLevel.ContainsKey($level)) { $stats.EntriesByLevel[$level] = 0 }
            $stats.EntriesByLevel[$level]++

            if ($entry.Caller.ScriptName) {
                $module = [System.IO.Path]::GetFileNameWithoutExtension($entry.Caller.ScriptName)
                if (-not $stats.EntriesByModule.ContainsKey($module)) { $stats.EntriesByModule[$module] = 0 }
                $stats.EntriesByModule[$module]++
            }

            if ($entry.UserData -and $entry.UserData.Action) {
                $action = $entry.UserData.Action
                if (-not $stats.EntriesByAction.ContainsKey($action)) { $stats.EntriesByAction[$action] = 0 }
                $stats.EntriesByAction[$action]++
            }
        }

        return $stats
    } catch {
        Write-Warning "Error getting log statistics: $_"
        return [PSCustomObject]@{}
    }
}

Export-ModuleMember -Function @(
    'Initialize-Logger',
    'Write-Log',
    'Trace-FunctionEntry',
    'Trace-FunctionExit',
    'Trace-Step',
    'Trace-StateChange',
    'Trace-ComponentLifecycle',
    'Trace-ServiceCall',
    'Get-LogEntries',
    'Get-CallTrace',
    'Clear-LogQueue',
    'Set-LogLevel',
    'Enable-CallTracing',
    'Disable-CallTracing',
    'Get-LogPath',
    'Get-LogStatistics'
)


####\modules\models.psm1
# ==============================================================================
# PMC Terminal v5 - Core Data Models
# Defines all core business entity classes with built-in validation.
# ==============================================================================

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Enums

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

enum BillingType {
    Billable
    NonBillable
}

#endregion

#region Base Validation Class
class ValidationBase {
    static [void] ValidateNotEmpty([string]$value, [string]$parameterName) {
        if ([string]::IsNullOrWhiteSpace($value)) {
            throw [System.ArgumentException]::new("Parameter '$($parameterName)' cannot be null or empty.")
        }
    }
}
#endregion

#region Core Model Classes

class PmcTask : ValidationBase {
    # --- Properties ---
    [string]$Id
    [string]$Title
    [string]$Description
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [string]$ProjectKey = "General"
    [string]$Category  # For backward compatibility with older data formats
    [datetime]$CreatedAt
    [datetime]$UpdatedAt
    [Nullable[datetime]]$DueDate
    [string[]]$Tags = @()
    [int]$Progress = 0
    [bool]$Completed = $false

    # --- Constructors ---
    PmcTask() {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
    }

    PmcTask([string]$title) : base() {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title
    }

    PmcTask([string]$title, [string]$description, [TaskPriority]$priority, [string]$projectKey) : base() {
        [ValidationBase]::ValidateNotEmpty($title, "Title")
        $this.Title = $title
        $this.Description = $description
        $this.Priority = $priority
        $this.ProjectKey = $projectKey
        $this.Category = $projectKey # Set for backward compatibility
    }

    # --- Methods ---
    [void] Complete() {
        $this.Status = [TaskStatus]::Completed
        $this.Completed = $true
        $this.Progress = 100
        $this.UpdatedAt = [datetime]::Now
    }

    [void] UpdateProgress([int]$newProgress) {
        if ($newProgress -lt 0 -or $newProgress -gt 100) {
            throw "Progress must be between 0 and 100."
        }
        $this.Progress = $newProgress
        $this.Status = if ($newProgress -eq 100) { [TaskStatus]::Completed }
                      elseif ($newProgress -gt 0) { [TaskStatus]::InProgress }
                      else { [TaskStatus]::Pending }
        $this.Completed = ($this.Status -eq [TaskStatus]::Completed)
        $this.UpdatedAt = [datetime]::Now
    }
    
    [string] GetDueDateString() {
        return if ($this.DueDate) { $this.DueDate.ToString("yyyy-MM-dd") } else { "N/A" }
    }

    # --- Serialization & Deserialization ---
    
    # Converts the object to a simple hashtable for JSON serialization
    [hashtable] ToLegacyFormat() {
        return @{
            id = $this.Id
            title = $this.Title
            description = $this.Description
            completed = $this.Completed
            priority = $this.Priority.ToString().ToLower()
            project = $this.ProjectKey
            due_date = if ($this.DueDate) { $this.GetDueDateString() } else { $null }
            created_at = $this.CreatedAt.ToString("o")
            updated_at = $this.UpdatedAt.ToString("o")
        }
    }

    # AI: Creates a PmcTask instance from an older, unstructured hashtable format.
    # This logic is now part of the class, centralizing all Task-related knowledge.
    static [PmcTask] FromLegacyFormat([hashtable]$legacyData) {
        $task = [PmcTask]::new()
        
        if ($legacyData.id) { $task.Id = $legacyData.id }
        if ($legacyData.title) { $task.Title = $legacyData.title }
        if ($legacyData.description) { $task.Description = $legacyData.description }
        
        if ($legacyData.priority) {
            $task.Priority = try { [TaskPriority]::$($legacyData.priority) } catch { [TaskPriority]::Medium }
        }
        
        # AI: PowerShell 5.1 compatible null-coalescing - fixed multi-line assignment
        if ($legacyData.project) {
            $task.ProjectKey = $legacyData.project
        } elseif ($legacyData.Category) {
            $task.ProjectKey = $legacyData.Category
        } else {
            $task.ProjectKey = "General"
        }
        $task.Category = $task.ProjectKey
        
        if ($legacyData.created_at) { $task.CreatedAt = try { [datetime]::Parse($legacyData.created_at) } catch { [datetime]::Now } }
        if ($legacyData.updated_at) { $task.UpdatedAt = try { [datetime]::Parse($legacyData.updated_at) } catch { [datetime]::Now } }
        if ($legacyData.due_date -and $legacyData.due_date -ne "N/A") { $task.DueDate = try { [datetime]::Parse($legacyData.due_date) } catch { $null } }
        
        if ($legacyData.completed -is [bool] -and $legacyData.completed) {
            $task.Complete()
        }
        
        return $task
    }
}

class PmcProject : ValidationBase {
    # --- Properties ---
    [string]$Key
    [string]$Name
    [string]$Client
    [BillingType]$BillingType = [BillingType]::NonBillable
    [double]$Rate = 0.0
    [double]$Budget = 0.0
    [bool]$Active = $true
    [datetime]$CreatedAt
    [datetime]$UpdatedAt

    # --- Constructors ---
    PmcProject() {
        $this.Key = ([Guid]::NewGuid().ToString().Split('-')[0]).ToUpper()
        $this.CreatedAt = [datetime]::Now
        $this.UpdatedAt = [datetime]::Now
    }

    PmcProject([string]$key, [string]$name) : base() {
        [ValidationBase]::ValidateNotEmpty($key, "Key")
        [ValidationBase]::ValidateNotEmpty($name, "Name")
        $this.Key = $key
        $this.Name = $name
    }
    
    # --- Serialization & Deserialization ---

    # Converts the object to a simple hashtable for JSON serialization
    [hashtable] ToLegacyFormat() {
        return @{
            Key = $this.Key
            Name = $this.Name
            Client = $this.Client
            BillingType = $this.BillingType.ToString()
            Rate = $this.Rate
            Budget = $this.Budget
            Active = $this.Active
            CreatedAt = $this.CreatedAt.ToString("o")
        }
    }

    # AI: Creates a PmcProject instance from an older, unstructured hashtable format.
    static [PmcProject] FromLegacyFormat([hashtable]$legacyData) {
        $project = [PmcProject]::new()
        
        if ($legacyData.Key) { $project.Key = $legacyData.Key }
        if ($legacyData.Name) { $project.Name = $legacyData.Name }
        if ($legacyData.Client) { $project.Client = $legacyData.Client }
        if ($legacyData.Rate) { $project.Rate = [double]$legacyData.Rate }
        if ($legacyData.Budget) { $project.Budget = [double]$legacyData.Budget }
        if ($legacyData.Active -is [bool]) { $project.Active = $legacyData.Active }
        
        if ($legacyData.BillingType) {
            $project.BillingType = try { [BillingType]::$($legacyData.BillingType) } catch { [BillingType]::NonBillable }
        }
        
        if ($legacyData.CreatedAt) { $project.CreatedAt = try { [datetime]::Parse($legacyData.CreatedAt) } catch { [datetime]::Now } }
        
        $project.UpdatedAt = $project.CreatedAt
        
        return $project
    }
}

#endregion

# --- Export Section ---
# AI: Classes and enums are automatically exported in PowerShell modules
# We only need to export any helper functions if they exist
Export-ModuleMember -Function * -Variable *


####\modules\theme-manager.psm1
#
# FILE: modules/theme-manager.psm1
# PURPOSE: Provides theming and color management for the TUI.
# AI: This module has been refactored to wrap all public functions in Invoke-WithErrorHandling
#     for consistent, robust error logging and handling, adhering to the project's core principles.
#

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{
        Name = "Modern"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::White
            Primary = [ConsoleColor]::White; Secondary = [ConsoleColor]::Gray
            Accent = [ConsoleColor]::Cyan; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue; Header = [ConsoleColor]::Cyan
            Border = [ConsoleColor]::DarkGray; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan; Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::Blue; String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta; Comment = [ConsoleColor]::DarkGray
        }
    }
    Dark = @{
        Name = "Dark"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::Gray
            Primary = [ConsoleColor]::Gray; Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::DarkCyan; Success = [ConsoleColor]::DarkGreen
            Warning = [ConsoleColor]::DarkYellow; Error = [ConsoleColor]::DarkRed
            Info = [ConsoleColor]::DarkBlue; Header = [ConsoleColor]::DarkCyan
            Border = [ConsoleColor]::DarkGray; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan; Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::DarkBlue; String = [ConsoleColor]::DarkGreen
            Number = [ConsoleColor]::DarkMagenta; Comment = [ConsoleColor]::DarkGray
        }
    }
    Light = @{
        Name = "Light"
        Colors = @{
            Background = [ConsoleColor]::White; Foreground = [ConsoleColor]::Black
            Primary = [ConsoleColor]::Black; Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::Blue; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::DarkYellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue; Header = [ConsoleColor]::Blue
            Border = [ConsoleColor]::Gray; Selection = [ConsoleColor]::Cyan
            Highlight = [ConsoleColor]::Yellow; Subtle = [ConsoleColor]::Gray
            Keyword = [ConsoleColor]::Blue; String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta; Comment = [ConsoleColor]::Gray
        }
    }
    Retro = @{
        Name = "Retro"
        Colors = @{
            Background = [ConsoleColor]::Black; Foreground = [ConsoleColor]::Green
            Primary = [ConsoleColor]::Green; Secondary = [ConsoleColor]::DarkGreen
            Accent = [ConsoleColor]::Yellow; Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow; Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Cyan; Header = [ConsoleColor]::Yellow
            Border = [ConsoleColor]::DarkGreen; Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::White; Subtle = [ConsoleColor]::DarkGreen
            Keyword = [ConsoleColor]::Yellow; String = [ConsoleColor]::Cyan
            Number = [ConsoleColor]::White; Comment = [ConsoleColor]::DarkGreen
        }
    }
}

function global:Initialize-ThemeManager {
    <#
    .SYNOPSIS
    Initializes the theme manager.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.Initialize" -Context "Initializing the theme service" -ScriptBlock {
        Set-TuiTheme -ThemeName "Modern"
        Write-Log -Level Info -Message "Theme manager initialized."
    }
}

function global:Set-TuiTheme {
    <#
    .SYNOPSIS
    Sets the current theme for the application.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName
    )
    Invoke-WithErrorHandling -Component "ThemeManager.SetTheme" -Context "Setting active TUI theme" -AdditionalData @{ ThemeName = $ThemeName } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $script:CurrentTheme = $script:Themes[$ThemeName]
            
            # Defensively check if RawUI exists. In some environments (like the VS Code
            # Integrated Console), it can be $null and cause a crash.
            if ($Host.UI.RawUI) {
                $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
                $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
            }
            
            Write-Log -Level Debug -Message "Theme set to: $ThemeName"
            
            # Publish theme change event if the event system is available.
            if (Get-Command -Name Publish-Event -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Theme.Changed" -Data @{ ThemeName = $ThemeName; Theme = $script:CurrentTheme }
            }
        } else {
            Write-Log -Level Warning -Message "Theme not found: $ThemeName"
        }
    }
}

function global:Get-ThemeColor {
    <#
    .SYNOPSIS
    Gets a color from the current theme.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ColorName,
        [Parameter()]
        [ConsoleColor]$Default = [ConsoleColor]::Gray
    )
    # AI: This function is called frequently during render. The wrapper adds negligible overhead
    #     but ensures any unexpected state corruption is handled gracefully.
    try {
        if ($script:CurrentTheme -and $script:CurrentTheme.Colors.ContainsKey($ColorName)) {
            return $script:CurrentTheme.Colors[$ColorName]
        }
        return $Default
    } catch {
        # Failsafe for render-critical function.
        Write-Log -Level Warning -Message "Error in Get-ThemeColor for '$ColorName'. Returning default. Error: $_"
        return $Default
    }
}

function global:Get-TuiTheme {
    <#
    .SYNOPSIS
    Gets the current theme object.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.GetTheme" -Context "Retrieving the current theme object" -ScriptBlock {
        return $script:CurrentTheme
    }
}

function global:Get-AvailableThemes {
    <#
    .SYNOPSIS
    Gets a list of all available theme names.
    #>
    Invoke-WithErrorHandling -Component "ThemeManager.GetAvailableThemes" -Context "Retrieving all available theme names" -ScriptBlock {
        return $script:Themes.Keys | Sort-Object
    }
}

function global:New-TuiTheme {
    <#
    .SYNOPSIS
    Creates a new theme in memory.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        [string]$BaseTheme = "Modern",
        [hashtable]$Colors = @{}
    )
    Invoke-WithErrorHandling -Component "ThemeManager.NewTheme" -Context "Creating a new theme" -AdditionalData @{ ThemeName = $Name } -ScriptBlock {
        $newTheme = @{ Name = $Name; Colors = @{} }
        
        if ($script:Themes.ContainsKey($BaseTheme)) {
            $newTheme.Colors = $script:Themes[$BaseTheme].Colors.Clone()
        }
        
        foreach ($colorKey in $Colors.Keys) {
            $newTheme.Colors[$colorKey] = $Colors[$colorKey]
        }
        
        $script:Themes[$Name] = $newTheme
        Write-Log -Level Info -Message "Created new theme: $Name"
        return $newTheme
    }
}

function global:Export-TuiTheme {
    <#
    .SYNOPSIS
    Exports a theme to a JSON file.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName,
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "ThemeManager.ExportTheme" -Context "Exporting a theme to JSON" -AdditionalData @{ ThemeName = $ThemeName; FilePath = $Path } -ScriptBlock {
        if ($script:Themes.ContainsKey($ThemeName)) {
            $theme = $script:Themes[$ThemeName]
            $exportTheme = @{ Name = $theme.Name; Colors = @{} }
            
            foreach ($colorKey in $theme.Colors.Keys) {
                $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString()
            }
            
            $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
            Write-Log -Level Info -Message "Exported theme '$ThemeName' to: $Path"
        } else {
            Write-Log -Level Warning -Message "Cannot export theme. Theme not found: $ThemeName"
        }
    }
}

function global:Import-TuiTheme {
    <#
    .SYNOPSIS
    Imports a theme from a JSON file.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    Invoke-WithErrorHandling -Component "ThemeManager.ImportTheme" -Context "Importing a theme from JSON" -AdditionalData @{ FilePath = $Path } -ScriptBlock {
        if (Test-Path $Path) {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json -AsHashtable
            $theme = @{ Name = $importedTheme.Name; Colors = @{} }
            
            foreach ($colorKey in $importedTheme.Colors.Keys) {
                $theme.Colors[$colorKey] = [System.Enum]::Parse([System.ConsoleColor], $importedTheme.Colors[$colorKey], $true)
            }
            
            $script:Themes[$theme.Name] = $theme
            Write-Log -Level Info -Message "Imported theme: $($theme.Name)"
            return $theme
        } else {
            Write-Log -Level Warning -Message "Cannot import theme. File not found: $Path"
            return $null
        }
    }
}

Export-ModuleMember -Function @(
    'Initialize-ThemeManager',
    'Set-TuiTheme',
    'Get-ThemeColor',
    'Get-TuiTheme',
    'Get-AvailableThemes',
    'New-TuiTheme',
    'Export-TuiTheme',
    'Import-TuiTheme'
)


####\modules\tui-engine-v2.psm1
# Rock-Solid TUI Engine v4.0 - Performance & Reliability Edition
# Implements all critical fixes from code review



#region Core TUI State
$script:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    ScreenStack     = New-Object System.Collections.Stack
    CurrentScreen   = $null
    IsDirty         = $true
    LastActivity    = [DateTime]::Now
    LastRenderTime  = [DateTime]::MinValue
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TotalTime = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    DebugOverlayEnabled = $false
    FocusedComponent = $null
    
    # Thread-safe input queue and runspace management
    InputQueue = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    
    # The correct, thread-safe object for signalling shutdown.
    CancellationTokenSource = $null
    
    # Event cleanup tracking
    EventHandlers = @{}
}

# Debug messages removed to prevent screen bleed-through
# Note: Width and Height params are only available inside Initialize-TuiEngine function



# Cell pool to avoid thousands of hashtable allocations
$script:CellPool = @{
    Pool = New-Object System.Collections.Queue
    MaxSize = 1000
}
#endregion

#region Cell Management & Object Pooling

function Get-PooledCell {
    param(
        [char]$Char = ' ',
        [ConsoleColor]$FG = [ConsoleColor]::White,
        [ConsoleColor]$BG = [ConsoleColor]::Black
    )
    
    if ($script:CellPool.Pool.Count -gt 0) {
        $cell = $script:CellPool.Pool.Dequeue()
        $cell.Char = $Char
        $cell.FG = $FG
        $cell.BG = $BG
        return $cell
    }
    
    # Create new cell if pool is empty
    return @{
        Char = $Char
        FG = $FG
        BG = $BG
    }
}

function Return-CellToPool {
    param($Cell)
    if ($script:CellPool.Pool.Count -lt $script:CellPool.MaxSize) {
        $script:CellPool.Pool.Enqueue($Cell)
    }
}

#endregion

#region Engine Lifecycle & Main Loop

function global:Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )

    # Patch: Always set defaults if not passed in
    if (-not $Width) { $Width = [Console]::WindowWidth }
    if (-not $Height) { $Height = [Console]::WindowHeight - 1 }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"
    }

   

    
    
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $script:TuiState.BufferWidth = $Width
        $script:TuiState.BufferHeight = $Height
        
        # Create 2D arrays for buffers
        $script:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $script:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        
        # Initialize buffers with empty cells
        $emptyCell = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $script:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $script:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear() # Clear console to remove initialization messages
        
        # Initialize subsystems with error handling
        try { 
            Initialize-LayoutEngines 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Layout engines initialized"
            }
        } catch { 
            Write-Warning "Layout engines init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Layout engines init failed" -Data $_
            }
        }
        try { 
            Initialize-ComponentSystem 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Component system initialized"
            }
        } catch { 
            Write-Warning "Component system init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Component system init failed" -Data $_
            }
        }
        
        # Track event handlers for cleanup (event system should already be initialized)
        $script:TuiState.EventHandlers = @{}
        
        # --- THE FIX: HOOK CTRL+C *BEFORE* STARTING THE INPUT THREAD ---
        # Temporarily disabled due to compatibility issues
        # TODO: Re-enable with proper PowerShell event handling
        try {
            [Console]::TreatControlCAsInput = $false
            # Ctrl+C handler temporarily disabled - will terminate process normally
        } catch {
            Write-Warning "Could not set console input mode: $_"
        }
        
        # Now it is safe to start the input thread.
        Initialize-InputThread
        
        # Publish initialization event
        Safe-PublishEvent -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        
        # Export TuiState for global access
        $global:TuiState = $script:TuiState
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "TUI Engine initialized successfully"
        }
    }
    catch {
        # --- ENHANCED DIAGNOSTIC BLOCK ---
        # This will now clearly print the root cause of any initialization failure.
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        Write-Host "IMMEDIATE, ORIGINAL ERROR DETECTED DURING INITIALIZATION" -ForegroundColor Red
        Write-Host "THE *REAL* PROBLEM IS LIKELY THIS:" -ForegroundColor Yellow
        
        if ($_) {
            Write-Host "MESSAGE: $($_.Exception.Message)" -ForegroundColor White
            
            Write-Host "FULL ERROR:" -ForegroundColor Yellow
            if ($_.Exception) {
                $_.Exception | Format-List * -Force
            } else {
                Write-Host "Error details: $_" -ForegroundColor White
            }
        } else {
            Write-Host "Unknown error occurred" -ForegroundColor White
        }
        
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        
        # Re-throw the exception so the main script's finally block is triggered for cleanup.
        throw "FATAL: TUI Engine initialization failed. See original error details above."
    }
}

function Initialize-InputThread {
    try {
        # Create thread-safe input handling
        $queueType = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]
        $script:TuiState.InputQueue = New-Object $queueType
    } catch {
        Write-Warning "Failed to create ConcurrentQueue, falling back to ArrayList"
        $script:TuiState.InputQueue = [System.Collections.ArrayList]::Synchronized([System.Collections.ArrayList]::new())
    }
    
    # Create the cancellation token source for thread-safe shutdown.
    $script:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $script:TuiState.CancellationTokenSource.Token

    # Create runspace for input handling (fully-qualified .NET types)
    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $script:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    # Create a PowerShell instance in that runspace
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    # This script block will run in the background.
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    $keyInfo = [Console]::ReadKey($true)
                    
                    # Handle different queue types
                    if ($InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Enqueue($keyInfo)
                        }
                    } elseif ($InputQueue -is [System.Collections.ArrayList]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Add($keyInfo) | Out-Null
                        }
                    }
                }
                else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] {
            return
        }
        catch {
            Write-Warning "Input thread error: $_"
        }
    }) | Out-Null
    
    # Store for cleanup
    $script:TuiState.InputRunspace   = $runspace
    $script:TuiState.InputPowerShell = $ps
    $script:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    # Process all queued input events
    $processedAny = $false
    # Check if the queue exists before trying to use it.
    if (-not $script:TuiState.InputQueue) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Verbose -Message "Processing input queue"
    }

    $keyInfo = $null
    
    # Handle different queue types
    if ($script:TuiState.InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
        $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
        while ($script:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
            $processedAny = $true
            $script:TuiState.LastActivity = [DateTime]::Now
            try {
                Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key input" -ScriptBlock {
                    Process-SingleKeyInput -keyInfo $keyInfo
                } -AdditionalData @{ KeyInfo = $keyInfo }
            } catch {
                Write-Log -Level Error -Message "Error processing single key input: $($_.Exception.Message)" -Data $_
                Request-TuiRefresh
            }
        }
    } elseif ($script:TuiState.InputQueue -is [System.Collections.ArrayList]) {
        while ($script:TuiState.InputQueue.Count -gt 0) {
            try {
                $keyInfo = $script:TuiState.InputQueue[0]
                $script:TuiState.InputQueue.RemoveAt(0)
                $processedAny = $true
                $script:TuiState.LastActivity = [DateTime]::Now
                try {
                    Invoke-WithErrorHandling -Component "Engine.ProcessInput" -Context "Processing single key input" -ScriptBlock {
                        Process-SingleKeyInput -keyInfo $keyInfo
                    } -AdditionalData @{ KeyInfo = $keyInfo }
                } catch {
                    Write-Log -Level Error -Message "Error processing single key input: $($_.Exception.Message)" -Data $_
                    Request-TuiRefresh
                }
            } catch {
                break
            }
        }
    }
    
    return $processedAny
}

###```focus adddition 
function global:Set-ComponentFocus {
    param(
        [hashtable]$Component
    )
    
    $oldFocusedComponent = $script:TuiState.FocusedComponent
    
    if ($null -ne $oldFocusedComponent -and $oldFocusedComponent -ne $Component) {
        $oldFocusedComponent.IsFocused = $false
        if ($oldFocusedComponent.OnBlur) {
            try { & $oldFocusedComponent.OnBlur -self $oldFocusedComponent }
            catch { Write-Log -Level Warning -Message "OnBlur error: $_" }
        }
    }

    if ($null -eq $Component) {
        $script:TuiState.FocusedComponent = $null
        Request-TuiRefresh
        return
    }

    if ($Component.IsFocusable -ne $true -or $Component.Visible -ne $true) {
        return
    }

    $script:TuiState.FocusedComponent = $Component
    $Component.IsFocused = $true
    
    if ($Component.OnFocus) {
        try { & $Component.OnFocus -self $Component }
        catch { Write-Log -Level Warning -Message "OnFocus error: $_" }
    }
    
    Request-TuiRefresh
}

function global:Handle-TabNavigation {
    param(
        [bool]$Reverse = $false
    )
    
    $currentScreen = $script:TuiState.CurrentScreen
    if (-not $currentScreen) { return }

    $focusable = @()
    $FindFocusableIn = {
        param($component)
        if ($component -and $component.IsFocusable -eq $true -and $component.Visible -eq $true) {
            $script:focusable += $component
        }
        if ($component -and $component.Children) {
            foreach ($child in $component.Children) {
                & $script:FindFocusableIn -component $child
            }
        }
    }
    
    foreach ($compName in $currentScreen.Components.Keys) {
        & $FindFocusableIn -component $currentScreen.Components[$compName]
    }

    if ($focusable.Count -eq 0) { return }

    $sortedFocusable = $focusable | Sort-Object { $_.Y }, { $_.X }

    $currentIndex = [array]::IndexOf($sortedFocusable, $script:TuiState.FocusedComponent)
    
    $nextIndex = 0
    if ($currentIndex -ne -1) {
        $direction = if ($Reverse) { -1 } else { 1 }
        $nextIndex = ($currentIndex + $direction + $sortedFocusable.Count) % $sortedFocusable.Count
    }

    Set-ComponentFocus -Component $sortedFocusable[$nextIndex]
}

function global:Clear-ComponentFocus {
    Set-ComponentFocus -Component $null
}
###```

function Process-SingleKeyInput {
    param($keyInfo)
    
    try {
        # Tab navigation handled by focus manager if available
        if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
            if (Get-Command -Name "Move-Focus" -ErrorAction SilentlyContinue) {
                Move-Focus -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            } else {
                # Fallback to old tab navigation
                Handle-TabNavigation -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            }
            return
        }
        
        # Dialog system gets first chance at input
        if ((Get-Command -Name "Handle-DialogInput" -ErrorAction SilentlyContinue) -and (Handle-DialogInput -Key $keyInfo)) {
            return
        }
        
        # Get focused component from focus manager if available
        $focusedComponent = if (Get-Command -Name "Get-FocusedComponent" -ErrorAction SilentlyContinue) {
            Get-FocusedComponent
        } else {
            $script:TuiState.FocusedComponent
        }
        
        # Focused component gets the next chance
        if ($focusedComponent -and $focusedComponent.HandleInput) {
            try {
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) {
                    return
                }
            } catch {
                Write-Warning "Component input handler error: $_"
            }
        }
        
        # Finally, the screen itself gets the key
        $currentScreen = $script:TuiState.CurrentScreen
        if ($currentScreen -and $currentScreen.HandleInput) {
            try {
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { 
                        $script:TuiState.Running = $false
                        if ($script:TuiState.CancellationTokenSource) {
                            $script:TuiState.CancellationTokenSource.Cancel()
                        }
                    }
                }
            } catch {
                Write-Warning "Screen input handler error: $_"
            }
        }
    } catch {
        Write-Warning "Input processing error: $_"
    }
}

function global:Start-TuiLoop {
    param([hashtable]$InitialScreen = $null)

    try {
        # Only initialize if not already initialized
        if (-not $script:TuiState.BufferWidth -or $script:TuiState.BufferWidth -eq 0) {
            Initialize-TuiEngine
        }
        
        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }
        
        # If no screen is active and no initial screen provided, we can't start
        if (-not $script:TuiState.CurrentScreen -and $script:TuiState.ScreenStack.Count -eq 0) {
            throw "No screen available to display. Push a screen before calling Start-TuiLoop or provide an InitialScreen parameter."
        }

        $script:TuiState.Running = $true
        $frameTime = New-Object System.Diagnostics.Stopwatch
        $targetFrameTime = 1000.0 / $script:TuiState.RenderStats.TargetFPS
        
        while ($script:TuiState.Running) {
            # ==========================================================
            # === BEGIN CENTRAL EXCEPTION HANDLING BLOCK ===
            # ==========================================================
            try {
                $frameTime.Restart()

                # Process input
                $hadInput = Process-TuiInput
                
                # Update dialog system
                if (Get-Command -Name "Update-DialogSystem" -ErrorAction SilentlyContinue) { 
                    try { Update-DialogSystem } catch { Write-Log -Level Warning -Message "Dialog update error: $_" }
                }

                # Render if dirty or had input
                if ($script:TuiState.IsDirty -or $hadInput) {
                    Render-Frame
                    $script:TuiState.IsDirty = $false
                }
                
                # Adaptive frame timing
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) {
                    $sleepTime = [Math]::Max(1, $targetFrameTime - $elapsed)
                    Start-Sleep -Milliseconds $sleepTime
                }
            }
            catch [Helios.HeliosException] {
                # --- This block handles our custom, "recoverable" errors ---
                $exception = $_.Exception
                
                # 1. Log the rich, detailed error for developers
                Write-Log -Level Error -Message "A TUI Exception occurred: $($exception.Message)" -Data $exception.Context
                
                # 2. Show a simple, clean dialog to the user
                Show-AlertDialog -Title "Application Error" -Message "An operation failed: $($exception.Message)"
                
                # 3. Force a full re-render to clean up any UI artifacts from the failed operation
                $script:TuiState.IsDirty = $true
            }
            catch {
                # --- This block handles unexpected, potentially fatal errors ---
                $exception = $_.Exception
                
                # 1. Log the catastrophic failure
                Write-Log -Level Error -Message "A FATAL, unhandled exception occurred: $($exception.Message)" -Data $_
                
                # 2. Inform the user and prepare for shutdown
                Show-AlertDialog -Title "Fatal Error" -Message "A critical error occurred. The application will now close."
                
                # 3. Stop the main loop to exit gracefully
                $script:TuiState.Running = $false
            }
            # ==========================================================
            # === END CENTRAL EXCEPTION HANDLING BLOCK ===
            # ==========================================================
        }
    }
    finally {
        Cleanup-TuiEngine
    }
}

# ==============================================================================
# === CRITICAL FIX: NEW RENDER-FRAME IMPLEMENTATION ============================
# ==============================================================================
function Render-Frame {
    try {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Verbose -Message "Starting Z-Index frame render"
        }
        
        $bgColor = if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
            Get-ThemeColor "Background"
        } else {
            [ConsoleColor]::Black
        }
        
        # Always clear the back buffer completely
        Clear-BackBuffer -BackgroundColor $bgColor
        
        # 1. RENDER SCREEN CHROME (Header, Footer, etc.)
        # This is for elements NOT in the component tree. The screen's Render method
        # should ONLY draw these non-component elements.
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Render) {
            try {
            Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).Render" -Context "Rendering screen chrome" -ScriptBlock {
            & $script:TuiState.CurrentScreen.Render -self $script:TuiState.CurrentScreen
            } -AdditionalData @{ ScreenName = $script:TuiState.CurrentScreen.Name }
            } catch {
                Write-Log -Level Error -Message "Screen-level render error: $($_.Exception.Message)" -Data $_
            }
        }

        # 2. COLLECT all visible components from the screen's Children and any active dialogs.
        $renderQueue = [System.Collections.Generic.List[hashtable]]::new()
        
        # Debug: Log screen state
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Render-Frame: CurrentScreen=$($script:TuiState.CurrentScreen.Name), Children count=$($script:TuiState.CurrentScreen.Children.Count)"
        }
        
        # Define collectComponents as a scriptblock variable that can reference itself
        $script:collectComponents = {
            param($component)
            if (-not $component -or $component.Visible -eq $false) { return }
            
            # Add the component itself to the queue
            $renderQueue.Add($component)
            
            # Debug logging
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Collected component: Type=$($component.Type), Name=$($component.Name), Pos=($($component.X),$($component.Y)), ZIndex=$($component.ZIndex), Children=$($component.Children.Count)"
            }
            
            # Process children if any
            if ($component.Children -and $component.Children.Count -gt 0) {
                # A panel must calculate its children's layout before they are collected
                if ($component.CalculateLayout) {
    		  try { 
        		[void](& $component.CalculateLayout -self $component) # FIX: Suppress output
   		  }
    		  catch { 
        		Write-Log -Level Error -Message "Layout failed for '$($component.Name)'" -Data $_ 
    		  }
	    }
                
                # Recursively collect each child
                foreach ($child in $component.Children) {
                    & $script:collectComponents $child
                }
            }
        }

        # Start collection from the screen's children
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Children) {
            foreach ($child in $script:TuiState.CurrentScreen.Children) {
                & $script:collectComponents -component $child
            }
        }

        # Collect from the current dialog (which is a self-contained component tree)
        if ((Get-Command -Name "Get-CurrentDialog" -ErrorAction SilentlyContinue)) {
            $currentDialog = Get-CurrentDialog
            if ($currentDialog) {
                & $script:collectComponents -component $currentDialog
            }
        }
        
        # 3. SORT the render queue by ZIndex
        $sortedQueue = $renderQueue | Sort-Object -Property ZIndex
        
        # 4. DRAW the sorted components
        foreach ($componentToRender in $sortedQueue) {
            if ($componentToRender.Render) {
                try {
                    Invoke-WithErrorHandling -Component "$($componentToRender.Name ?? $componentToRender.Type).Render" -Context "Rendering component" -ScriptBlock {
                        & $componentToRender.Render -self $componentToRender
                    } -AdditionalData @{ ComponentType = $componentToRender.Type; ComponentName = $componentToRender.Name }
                } catch {
                    Write-Log -Level Error -Message "Failed to render component '$($componentToRender.Name ?? $componentToRender.Type)': $($_.Exception.Message)" -Data $_
                    # Continue rendering other components
                }
            }
        }
        
        # 5. FINALIZE the frame
        Render-BufferOptimized
        
        # Force cursor to bottom-right to avoid interference
        [Console]::SetCursorPosition($script:TuiState.BufferWidth - 1, $script:TuiState.BufferHeight - 1)
        
    } catch {
        Write-Warning "Fatal Frame render error: $_"
    }
}

function global:Request-TuiRefresh {
    $script:TuiState.IsDirty = $true
}

function Cleanup-TuiEngine {
    try {
        # --- ROBUST CLEANUP ROUTINE ---
        # This sequence is defensive and will not fail even if initialization was partial.
        if ($script:TuiState.CancellationTokenSource) {
            try {
                if (-not $script:TuiState.CancellationTokenSource.IsCancellationRequested) {
                    $script:TuiState.CancellationTokenSource.Cancel()
                }
            } catch { 
                # Ignore errors if CancellationTokenSource is in an invalid state
            }
        }

        if ($script:TuiState.InputPowerShell) {
            if ($script:TuiState.InputAsyncResult) {
                try { $script:TuiState.InputPowerShell.EndInvoke($script:TuiState.InputAsyncResult) } catch { }
            }
            try { $script:TuiState.InputPowerShell.Dispose() } catch { }
        }
        
        if ($script:TuiState.InputRunspace) {
            try { $script:TuiState.InputRunspace.Dispose() } catch { }
        }
        
        if ($script:TuiState.CancellationTokenSource) {
            try { $script:TuiState.CancellationTokenSource.Dispose() } catch { }
        }

        # Clean up background jobs
        if (Get-Command -Name "Stop-AllTuiAsyncJobs" -ErrorAction SilentlyContinue) {
            try { Stop-AllTuiAsyncJobs } catch { }
        }

        Cleanup-EventHandlers
        
        # Only try to reset the console if we are in an interactive session
        if (-not $env:CI -and -not $PSScriptRoot) {
            try {
                if ([System.Environment]::UserInteractive) {
                    [Console]::Write("$([char]27)[0m")
                    [Console]::CursorVisible = $true
                    [Console]::Clear()
                    [Console]::ResetColor()
                }
            } catch {
                # This can fail in non-interactive environments, ignore the error.
            }
        }
    } catch {
        Write-Warning "A secondary error occurred during TUI cleanup: $_"
    }
}

function Cleanup-EventHandlers {
    if (-not (Get-Command -Name "Unsubscribe-Event" -ErrorAction SilentlyContinue)) { return }
    if (-not $script:TuiState.EventHandlers) { return }

    foreach ($handlerId in $script:TuiState.EventHandlers.Values) {
        try { Unsubscribe-Event -HandlerId $handlerId } catch { }
    }
    $script:TuiState.EventHandlers.Clear()
    
    # Clean up any orphaned Ctrl+C event handler if it exists
    try {
        Get-EventSubscriber -SourceIdentifier "TuiCtrlC" -ErrorAction SilentlyContinue | Unregister-Event
    } catch { }
}

function Safe-PublishEvent {
    param($EventName, $Data)
    if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
        try { Publish-Event -EventName $EventName -Data $Data } catch { }
    }
}

#endregion

#region Screen Management

function global:Push-Screen {
    param([hashtable]$Screen)
    if (-not $Screen) { return }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                # This is less critical, so a log is acceptable, but we can be more specific.
                Write-Log -Level Warning -Message "Error in OnBlur for component '$($script:TuiState.FocusedComponent.Name)'" -Data $_
            }
        }
        
        if ($script:TuiState.CurrentScreen) {
            if ($script:TuiState.CurrentScreen.OnExit) { 
                try {
                    Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).OnExit" -Context "Screen exit" -ScriptBlock {
                        & $script:TuiState.CurrentScreen.OnExit -self $script:TuiState.CurrentScreen
                    } -AdditionalData @{ ScreenName = $script:TuiState.CurrentScreen.Name }
                } catch {
                    Write-Warning "Screen exit error: $($_.Exception.Message)"
                }
            }
            $script:TuiState.ScreenStack.Push($script:TuiState.CurrentScreen)
        }
        
        $script:TuiState.CurrentScreen = $Screen
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        if ($Screen.Init) { 
            try {
                Invoke-WithErrorHandling -Component "$($Screen.Name).Init" -Context "Screen initialization" -ScriptBlock {
                    # AI: Ensure services are passed to screen init
                    # Check for services in multiple locations
                    $services = $null
                    if ($Screen._services) {
                        $services = $Screen._services
                    } elseif ($global:Services) {
                        $services = $global:Services
                    }
                    
                    if ($services) {
                        & $Screen.Init -self $Screen -services $services
                    } else {
                        & $Screen.Init -self $Screen
                    }
                } -AdditionalData @{ ScreenName = $Screen.Name }
            } catch {
                throw "Failed to initialize screen '$($Screen.Name)': $($_.Exception.Message)"
            }
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
        
    } catch {
        Write-Warning "Push screen error: $_"
    }
}

function global:Pop-Screen {
    if ($script:TuiState.ScreenStack.Count -eq 0) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Popping screen"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                Write-Warning "Component blur error: $_"
            }
        }
        
        # Store the screen to exit before changing CurrentScreen
        $screenToExit = $script:TuiState.CurrentScreen
        
        # Pop the new screen from the stack
        $script:TuiState.CurrentScreen = $script:TuiState.ScreenStack.Pop()
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        # Call lifecycle hooks in correct order
        if ($screenToExit -and $screenToExit.OnExit) { 
            try {
                Invoke-WithErrorHandling -Component "$($screenToExit.Name).OnExit" -Context "Screen exit" -ScriptBlock {
                    & $screenToExit.OnExit -self $screenToExit
                } -AdditionalData @{ ScreenName = $screenToExit.Name }
            } catch {
                Write-Warning "Screen exit error: $($_.Exception.Message)"
            }
        }
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.OnResume) { 
            try {
                Invoke-WithErrorHandling -Component "$($script:TuiState.CurrentScreen.Name).OnResume" -Context "Screen resume" -ScriptBlock {
                    & $script:TuiState.CurrentScreen.OnResume -self $script:TuiState.CurrentScreen
                } -AdditionalData @{ ScreenName = $script:TuiState.CurrentScreen.Name }
            } catch {
                Write-Warning "Screen resume error: $($_.Exception.Message)"
            }
        }
        
        # Restore focus if the screen tracks it
        if ($script:TuiState.CurrentScreen.LastFocusedComponent) {
            Set-ComponentFocus -Component $script:TuiState.CurrentScreen.LastFocusedComponent
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Popped" -Data @{ ScreenName = $script:TuiState.CurrentScreen.Name }
        
        return $true
        
    } catch {
        Write-Warning "Pop screen error: $_"
        return $false
    }
}

#endregion

#region Buffer and Rendering

# GetBufferIndex no longer needed - using 2D arrays directly

function global:Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    
    # Create a new cell for each position to ensure proper clearing
    for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
            $script:TuiState.BackBuffer[$y, $x] = @{ 
                Char = ' '
                FG = [ConsoleColor]::White
                BG = $BackgroundColor 
            }
        }
    }
}

function global:Write-BufferString {
    param(
        [int]$X, 
        [int]$Y, 
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    )
    if ($Y -lt 0 -or $Y -ge $script:TuiState.BufferHeight) { return }
    if ([string]::IsNullOrEmpty($Text)) { return }
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:TuiState.BufferWidth) { break }

        if ($currentX -ge 0) {
            $script:TuiState.BackBuffer[$Y, $currentX] = @{ 
                Char = $char
                FG = $ForegroundColor
                BG = $BackgroundColor 
            }
        }
        
        # Pragmatic check for CJK/wide characters. A full implementation is library-dependent.
        if ($char -match '[\u1100-\u11FF\u2E80-\uA4CF\uAC00-\uD7A3\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]') {
            $currentX += 2
            # Also fill the next cell with a space for wide characters to prevent overlap
            if ($currentX -lt $script:TuiState.BufferWidth -and $currentX -gt 0) {
                $script:TuiState.BackBuffer[$Y, $currentX - 1] = @{ 
                    Char = ' '
                    FG = $ForegroundColor
                    BG = $BackgroundColor 
                }
            }
        } else {
            $currentX++
        }
    }
}

function global:Write-BufferBox {
    param(
        [int]$X, 
        [int]$Y, 
        [int]$Width, 
        [int]$Height, 
        [string]$BorderStyle = "Single", 
        [ConsoleColor]$BorderColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, 
        [string]$Title = ""
    )
    $borders = Get-BorderChars -Style $BorderStyle
    
    # Top border
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title
    if ($Title) {
        $titleText = " $Title "
        if ($titleText.Length -gt ($Width - 2)) {
            # FIX: Ensure the length for Substring is never negative.
            $maxLength = [Math]::Max(0, $Width - 5)
            $titleText = " $($Title.Substring(0, $maxLength))... "
        }
        $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
       Write-BufferString -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Sides and Fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function global:Render-BufferOptimized {
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    $outputBuilder = New-Object System.Text.StringBuilder -ArgumentList 20000
    $lastFG = -1
    $lastBG = -1
    
    # Force full render on first frame or if requested
    $forceFullRender = $script:TuiState.RenderStats.FrameCount -eq 0
    
    try {
        # Build ANSI output with change detection
        for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
            # Position cursor at start of line
            $outputBuilder.Append("$([char]27)[$($y + 1);1H") | Out-Null
            
            for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
                $backCell = $script:TuiState.BackBuffer[$y, $x]
                $frontCell = $script:TuiState.FrontBuffer[$y, $x]
                
                # Skip if cell hasn't changed (unless forcing full render)
                if (-not $forceFullRender -and
                    $backCell.Char -eq $frontCell.Char -and 
                    $backCell.FG -eq $frontCell.FG -and 
                    $backCell.BG -eq $frontCell.BG) {
                    continue
                }
                
                # Position cursor if we skipped cells
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) {
                    $outputBuilder.Append("$([char]27)[$($y + 1);$($x + 1)H") | Out-Null
                }
                
                # Update colors if changed
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG
                    $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("$([char]27)[${fgCode};${bgCode}m") | Out-Null
                    $lastFG = $backCell.FG
                    $lastBG = $backCell.BG
                }
                
                # Append character
                $outputBuilder.Append($backCell.Char) | Out-Null
                
                # Update front buffer
                $script:TuiState.FrontBuffer[$y, $x] = @{
                    Char = $backCell.Char
                    FG = $backCell.FG
                    BG = $backCell.BG
                }
            }
        }
        
        # Reset ANSI formatting at the end
        $outputBuilder.Append("$([char]27)[0m") | Out-Null
        
        # Write to console
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Warning "Render error: $_"
    }
    
    # Update stats
    $stopwatch.Stop()
    $script:TuiState.RenderStats.LastFrameTime = $stopwatch.ElapsedMilliseconds
    $script:TuiState.RenderStats.FrameCount++
    $script:TuiState.RenderStats.TotalTime += $stopwatch.ElapsedMilliseconds
}

#endregion

#region Component System

function Initialize-ComponentSystem {
    $script:TuiState.Components = @()
    $script:TuiState.FocusedComponent = $null
}

function global:Register-Component {
    param([hashtable]$Component)
    
    # Add to component registry
    $script:TuiState.Components += $Component
    
    # Initialize component with error handling
    if ($Component.Init) {
        try {
            Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).Init" -Context "Component initialization" -ScriptBlock {
                & $Component.Init -self $Component
            } -AdditionalData @{ ComponentType = $Component.Type; ComponentName = $Component.Name }
        } catch {
            Write-Warning "Component init error: $($_.Exception.Message)"
        }
    }
    
    return $Component
}

function global:Set-ComponentFocus {
    param([hashtable]$Component)
    
    # Don't focus disabled components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) {
        return
    }
    
    # Blur previous component with error handling
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        try {
            Invoke-WithErrorHandling -Component "$($script:TuiState.FocusedComponent.Name ?? $script:TuiState.FocusedComponent.Type).OnBlur" -Context "Component blur" -ScriptBlock {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } -AdditionalData @{ ComponentType = $script:TuiState.FocusedComponent.Type; ComponentName = $script:TuiState.FocusedComponent.Name }
        } catch {
            Write-Warning "Component blur error: $($_.Exception.Message)"
        }
    }
    
    # Track focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $Component
    }
    
    # Focus new component with error handling
    $script:TuiState.FocusedComponent = $Component
    if ($Component -and $Component.OnFocus) {
        try {
            Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).OnFocus" -Context "Component focus" -ScriptBlock {
                & $Component.OnFocus -self $Component
            } -AdditionalData @{ ComponentType = $Component.Type; ComponentName = $Component.Name }
        } catch {
            Write-Warning "Component focus error: $($_.Exception.Message)"
        }
    }
    
    Request-TuiRefresh
}

function global:Clear-ComponentFocus {
    <#
    .SYNOPSIS
    Clears focus from the current component
    #>
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        try {
            Invoke-WithErrorHandling -Component "$($script:TuiState.FocusedComponent.Name ?? $script:TuiState.FocusedComponent.Type).OnBlur" -Context "Component blur" -ScriptBlock {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } -AdditionalData @{ ComponentType = $script:TuiState.FocusedComponent.Type; ComponentName = $script:TuiState.FocusedComponent.Name }
        } catch {
            Write-Warning "Component blur error: $($_.Exception.Message)"
        }
    }
    
    $script:TuiState.FocusedComponent = $null
    
    # Clear tracked focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $null
    }
    
    Request-TuiRefresh
}

function global:Get-NextFocusableComponent {
    <#
    .SYNOPSIS
    Gets the next focusable component in tab order
    #>
    param(
        [hashtable]$CurrentComponent,
        [bool]$Reverse = $false
    )
    
    if (-not $script:TuiState.CurrentScreen) { return $null }
    
    # Get all focusable components
    $focusableComponents = @()
    
    # Recursive function to find focusable components
    function Find-FocusableComponents {
        param($Component)
        
        # Check using the correct properties that our components actually have
        if ($Component.IsFocusable -eq $true -and 
            $Component.Visible -ne $false) {
            $focusableComponents += $Component
        }
        
        if ($Component.Children) {
            foreach ($child in $Component.Children) {
                Find-FocusableComponents -Component $child
            }
        }
    }
    
    # Start from screen components
    if ($script:TuiState.CurrentScreen.Components) {
        if ($script:TuiState.CurrentScreen.Components -is [hashtable]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components.Values) {
                Find-FocusableComponents -Component $comp
            }
        } elseif ($script:TuiState.CurrentScreen.Components -is [array]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components) {
                Find-FocusableComponents -Component $comp
            }
        }
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by TabIndex or position
    $sorted = $focusableComponents | Sort-Object {
        if ($null -ne $_.TabIndex) { $_.TabIndex }
        else { $_.Y * 1000 + $_.X }
    }
    
    if ($Reverse) {
        [Array]::Reverse($sorted)
    }
    
    # Find current index
    $currentIndex = -1
    for ($i = 0; $i -lt $sorted.Count; $i++) {
        if ($sorted[$i] -eq $CurrentComponent) {
            $currentIndex = $i
            break
        }
    }
    
    # Get next component
    if ($currentIndex -ge 0) {
        $nextIndex = ($currentIndex + 1) % $sorted.Count
        return $sorted[$nextIndex]
    } else {
        return $sorted[0]
    }
}

function global:Handle-TabNavigation {
    <#
    .SYNOPSIS
    Handles Tab key navigation between components  
    #>
    param([bool]$Reverse = $false)
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Handle-TabNavigation called, Reverse=$Reverse"
    }
    
    $next = Get-NextFocusableComponent -CurrentComponent $script:TuiState.FocusedComponent -Reverse $Reverse
    if ($next) {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Debug -Message "Setting focus to component: Type=$($next.Type), Name=$($next.Name)"
        }
        Set-ComponentFocus -Component $next
    }
}

function global:New-Component {
    param(
        [string]$Type = "Base",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 1,
        [hashtable]$Props = @{}
    )
    
    $component = @{
        Type = $Type
        X = $X
        Y = $Y
        Width = $Width
        Height = $Height
        Visible = $true
        Focused = $false
        Parent = $null
        Children = @()
        Props = $Props
        State = @{}
        
        # Lifecycle methods
        Init = { param($self) }
        Render = { param($self) }
        HandleInput = { param($self, $Key) return $false }
        OnFocus = { param($self) $self.Focused = $true }
        OnBlur = { param($self) $self.Focused = $false }
        Dispose = { param($self) }
    }
    
    # Merge with type-specific properties
    switch ($Type) {
        "TextInput" { $component = Merge-Hashtables $component (Get-TextInputComponent) }
        "Button" { $component = Merge-Hashtables $component (Get-ButtonComponent) }
        "List" { $component = Merge-Hashtables $component (Get-ListComponent) }
        "Table" { $component = Merge-Hashtables $component (Get-TableComponent) }
    }
    
    return $component
}

function Merge-Hashtables {
    param($Base, $Override)
    $result = $Base.Clone()
    foreach ($key in $Override.Keys) {
        $result[$key] = $Override[$key]
    }
    return $result
}

#endregion

#region Layout Management

function Initialize-LayoutEngines {
    $script:TuiState.Layouts = @{
        Grid = Get-GridLayout
        Stack = Get-StackLayout
        Dock = Get-DockLayout
    }
}

function global:Apply-Layout {
    param(
        [string]$LayoutType,
        [hashtable[]]$Components,
        [hashtable]$Options = @{}
    )
    
    if ($script:TuiState.Layouts.ContainsKey($LayoutType)) {
        $layout = $script:TuiState.Layouts[$LayoutType]
        try {
            Invoke-WithErrorHandling -Component "Layout.$LayoutType" -Context "Applying layout" -ScriptBlock {
                & $layout.Apply -Components $Components -Options $Options
            } -AdditionalData @{ LayoutType = $LayoutType; Options = $Options }
        } catch {
            Write-Warning "Layout error: $($_.Exception.Message)"
        }
    }
}

function Get-GridLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $cols = if ($Options.Columns) { $Options.Columns } else { 2 }
            $rows = [Math]::Ceiling($Components.Count / $cols)
            $cellWidth = [Math]::Floor($script:TuiState.BufferWidth / $cols)
            $cellHeight = [Math]::Floor($script:TuiState.BufferHeight / $rows)
            
            for ($i = 0; $i -lt $Components.Count; $i++) {
                $col = $i % $cols
                $row = [Math]::Floor($i / $cols)
                $Components[$i].X = $col * $cellWidth
                $Components[$i].Y = $row * $cellHeight
                $Components[$i].Width = $cellWidth - 1
                $Components[$i].Height = $cellHeight - 1
            }
        }
    }
}

function Get-StackLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $orientation = if ($Options.Orientation) { $Options.Orientation } else { "Vertical" }
            $spacing = if ($null -ne $Options.Spacing) { $Options.Spacing } else { 1 }
            $x = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $y = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            
            foreach ($component in $Components) {
                $component.X = $x
                $component.Y = $y
                
                if ($orientation -eq "Vertical") {
                    $y += $component.Height + $spacing
                } else {
                    $x += $component.Width + $spacing
                }
            }
        }
    }
}

function Get-DockLayout {
    return @{
        Apply = {
            param($Components, $Options)
            
            # Container bounds
            $containerX = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $containerY = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            $containerWidth = if ($Options.Width) { $Options.Width } else { $script:TuiState.BufferWidth }
            $containerHeight = if ($Options.Height) { $Options.Height } else { $script:TuiState.BufferHeight }
            
            # Current available area
            $availableX = $containerX
            $availableY = $containerY
            $availableWidth = $containerWidth
            $availableHeight = $containerHeight
            
            # Process components by dock position
            $topComponents = $Components | Where-Object { $_.Props.Dock -eq "Top" }
            $bottomComponents = $Components | Where-Object { $_.Props.Dock -eq "Bottom" }
            $leftComponents = $Components | Where-Object { $_.Props.Dock -eq "Left" }
            $rightComponents = $Components | Where-Object { $_.Props.Dock -eq "Right" }
            $fillComponents = $Components | Where-Object { $_.Props.Dock -eq "Fill" -or -not $_.Props.Dock }
            
            # Dock top components
            foreach ($comp in $topComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $availableY += $comp.Height
                $availableHeight -= $comp.Height
            }
            
            # Dock bottom components
            foreach ($comp in $bottomComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY + $availableHeight - $comp.Height
                $comp.Width = $availableWidth
                $availableHeight -= $comp.Height
            }
            
            # Dock left components
            foreach ($comp in $leftComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableX += $comp.Width
                $availableWidth -= $comp.Width
            }
            
            # Dock right components
            foreach ($comp in $rightComponents) {
                $comp.X = $availableX + $availableWidth - $comp.Width
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableWidth -= $comp.Width
            }
            
            # Fill remaining space
            foreach ($comp in $fillComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $comp.Height = $availableHeight
            }
        }
    }
}

#endregion

#region Utility Functions

function global:Get-BorderChars { 
    param([string]$Style) 
    $styles = @{ 
        Single = @{ 
            TopLeft='┌'; TopRight='┐'; BottomLeft='└'; BottomRight='┘'
            Horizontal='─'; Vertical='│' 
        }
        Double = @{ 
            TopLeft='╔'; TopRight='╗'; BottomLeft='╚'; BottomRight='╝'
            Horizontal='═'; Vertical='║' 
        }
        Rounded = @{ 
            TopLeft='╭'; TopRight='╮'; BottomLeft='╰'; BottomRight='╯'
            Horizontal='─'; Vertical='│' 
        } 
    }
    if ($styles.ContainsKey($Style)) { 
        return $styles[$Style] 
    } else { 
        return $styles.Single 
    }
}

function Get-AnsiColorCode { 
    param([ConsoleColor]$Color, [bool]$IsBackground) 
    $map = @{ 
        Black=30; DarkBlue=34; DarkGreen=32; DarkCyan=36
        DarkRed=31; DarkMagenta=35; DarkYellow=33; Gray=37
        DarkGray=90; Blue=94; Green=92; Cyan=96
        Red=91; Magenta=95; Yellow=93; White=97 
    }
    $code = $map[$Color.ToString()]
    if ($IsBackground) { 
        return $code + 10 
    } else { 
        return $code 
    } 
}

function Get-ThemeColorFallback {
    param($ColorName, $Default = [ConsoleColor]::White)
    # This is a fallback function for when theme manager isn't available
    # The theme manager will override this with its own global Get-ThemeColor
    return $Default
}

# Only define global Get-ThemeColor if it doesn't already exist
if (-not (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue)) {
    function global:Get-ThemeColor {
        param($ColorName, $Default = [ConsoleColor]::White)
        return Get-ThemeColorFallback -ColorName $ColorName -Default $Default
    }
}

function global:Write-StatusLine { 
    param(
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = 'White', 
        [ConsoleColor]$BackgroundColor = 'DarkBlue'
    ) 
    try { 
        $y = $script:TuiState.BufferHeight
        [Console]::SetCursorPosition(0, $y)
        [Console]::ForegroundColor = $ForegroundColor
        [Console]::BackgroundColor = $BackgroundColor
        [Console]::Write($Text.PadRight([Console]::WindowWidth))
        [Console]::ResetColor() 
    } catch {
        Write-Warning "Status line error: $_"
    } 
}

function global:Subscribe-TuiEvent {
    param($EventName, $Handler)
    if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
        $handlerId = Subscribe-Event -EventName $EventName -Handler $Handler
        # Track for cleanup
        $script:TuiState.EventHandlers[$EventName] = $handlerId
        return $handlerId
    }
}

#endregion

#region Component Definitions

function Get-TextInputComponent {
    return @{
        # State
        Value = ""
        CursorPosition = 0
        MaxLength = 50
        
        # Methods
        Render = {
            param($self)
            try {
                $borderColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Draw input box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    Write-BufferString -X ($self.X - 1) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    # Right bracket
                    Write-BufferString -X ($self.X + $self.Width) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                }
                
                # Draw text
                $displayText = $self.Value
                if ($displayText.Length > ($self.Width - 3)) {
                    $displayText = $displayText.Substring($displayText.Length - ($self.Width - 3))
                }
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text $displayText
                
                # Draw cursor if focused
                if ($self.Focused -and $self.CursorPosition -lt ($self.Width - 3)) {
                    Write-BufferString -X ($self.X + 1 + $self.CursorPosition) -Y ($self.Y + 1) `
                        -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
                }
            } catch {
                Write-Warning "TextInput render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) {
                        if ($self.Value.Length -gt 0 -and $self.CursorPosition -gt 0) {
                            $self.Value = $self.Value.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.Value = $self.Value.Remove($self.CursorPosition, 1)
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.CursorPosition++
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.Value.Length
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and 
                            $self.Value.Length -lt $self.MaxLength) {
                            $self.Value = $self.Value.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            return $true
                        }
                    }
                }
            } catch {
                Write-Warning "TextInput input error: $_"
            }
            return $false
        }
    }
}

function Get-ButtonComponent {
    return @{
        # State
        Text = "Button"
        
        # Methods
        Render = {
            param($self)
            try {
                $bgColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::DarkCyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::DarkGray)
                }
                
                $text = " $($self.Text) "
                if ($text.Length > $self.Width) {
                    $text = $text.Substring(0, $self.Width)
                }
                
                $x = $self.X + [Math]::Floor(($self.Width - $text.Length) / 2)
                Write-BufferString -X $x -Y $self.Y -Text $text `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor $bgColor
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    if ($x -gt 0) {
                        Write-BufferString -X ($x - 1) -Y $self.Y `
                            -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                    # Right bracket
                    if (($x + $text.Length) -lt $script:TuiState.BufferWidth) {
                        Write-BufferString -X ($x + $text.Length) -Y $self.Y `
                            -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                }
            } catch {
                Write-Warning "Button render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                    if ($self.OnClick) {
                        & $self.OnClick -self $self
                    }
                    return $true
                }
            } catch {
                Write-Warning "Button input error: $_"
            }
            return $false
        }
    }
}

function Get-TableComponent {
    return @{
        # State
        Data = @()
        Columns = @()
        SelectedRow = 0
        ScrollOffset = 0
        
        # Methods
        Render = {
            param($self)
            try {
                # Simplified table rendering
                $y = $self.Y
                
                # Header
                $headerText = ""
                foreach ($col in $self.Columns) {
                    $headerText += $col.Name.PadRight($col.Width)
                }
                Write-BufferString -X $self.X -Y $y -Text $headerText `
                    -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                $y++
                
                # Data rows
                $visibleRows = $self.Data | Select-Object -Skip $self.ScrollOffset -First ($self.Height - 1)
                $rowIndex = $self.ScrollOffset
                foreach ($row in $visibleRows) {
                    $rowText = ""
                    foreach ($col in $self.Columns) {
                        $value = if ($row.($col.Property)) { $row.($col.Property) } else { "" }
                        $rowText += $value.ToString().PadRight($col.Width)
                    }
                    
                    $fg = if ($rowIndex -eq $self.SelectedRow) {
                        Get-ThemeColor "Selection" -Default ([ConsoleColor]::Yellow)
                    } else {
                        Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                    }
                    
                    Write-BufferString -X $self.X -Y $y -Text $rowText -ForegroundColor $fg
                    $y++
                    $rowIndex++
                }
            } catch {
                Write-Warning "Table render error: $_"
            }
        }
    }
}

#endregion

#region Word Wrap Helper
function global:Get-WordWrappedLines {
    param(
        [string]$Text,
        [int]$MaxWidth
    )
    
    if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }
    
    $lines = @()
    $words = $Text -split '\s+'
    $sb = New-Object System.Text.StringBuilder
    
    foreach ($word in $words) {
        if ($sb.Length -eq 0) {
            [void]$sb.Append($word)
        } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) {
            [void]$sb.Append(' ')
            [void]$sb.Append($word)
        } else {
            $lines += $sb.ToString()
            [void]$sb.Clear()
            [void]$sb.Append($word)
        }
    }
    
    if ($sb.Length -gt 0) {
        $lines += $sb.ToString()
    }
    
    return $lines
}
#endregion

function global:Stop-TuiEngine {
    <#
    .SYNOPSIS
    Stops the TUI engine and exits the application gracefully
    #>
    param()
    
    Write-Log -Level Info -Message "Stop-TuiEngine called - shutting down application" -Data @{ Component = "TuiEngine" }
    
    # Set the running flag to false to exit the main loop
    $script:TuiState.Running = $false
    
    # Cancel the input thread if available
    if ($script:TuiState.CancellationTokenSource) {
        try {
            $script:TuiState.CancellationTokenSource.Cancel()
        }
        catch {
            Write-Warning "Failed to cancel input thread: $_"
        }
    }
    
    # Publish shutdown event
    Safe-PublishEvent -EventName "System.Shutdown" -Data @{ Reason = "User requested" }
}

# Build export list dynamically
$exportFunctions = @(
    'Start-TuiLoop', 'Request-TuiRefresh', 'Push-Screen', 'Pop-Screen',
    'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer',
    'Write-StatusLine', 'Get-BorderChars',
    'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 
    'Get-NextFocusableComponent', 'Handle-TabNavigation', 
    'New-Component', 'Apply-Layout',
    'Get-WordWrappedLines', 'Subscribe-TuiEvent',
    'Render-Frame', 'Initialize-TuiEngine', 'Stop-TuiEngine'
)

# Only export Get-ThemeColor if we defined it
if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue | Where-Object { $_.Source -eq "tui-engine-v2" }) {
    $exportFunctions += 'Get-ThemeColor'
}

Export-ModuleMember -Function $exportFunctions -Variable @('TuiState')


####\modules\tui-framework.psm1
# TUI Framework Integration Module - FIXED VERSION
# Contains fixed utility functions with resolved parameter binding issues.

$script:TuiAsyncJobs = @()

function global:Invoke-TuiMethod {
    <#
    .SYNOPSIS
    Safely invokes a method on a TUI component.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Component,

        [Parameter(Mandatory = $true)]
        [string]$MethodName,

        [Parameter()]
        [hashtable]$Arguments = @{}
    )

    # AI: Defensive check for null component to prevent errors.
    if ($null -eq $Component) { return }
    
    # AI: Check if the method key exists and is a scriptblock before attempting invocation.
    # This prevents "The term '...' is not recognized" errors for optional methods.
    if (-not $Component.ContainsKey($MethodName)) { return }
    $method = $Component[$MethodName]
    if ($null -eq $method -or $method -isnot [scriptblock]) {
        return
    }

    # Add the component itself as the 'self' parameter for convenience within the method.
    $Arguments['self'] = $Component

    Invoke-WithErrorHandling -Component "$($Component.Name ?? $Component.Type).$MethodName" -Context "Invoking component method" -ScriptBlock {
        # Use splatting with the @ operator for robust parameter passing.
        & $method @Arguments
    } -AdditionalData @{ Component = $Component.Name; Method = $MethodName } -ErrorHandler {
        param($Exception)
        # Log the error but do not re-throw, allowing the UI to remain responsive.
        Write-Log -Level Error -Message "Error invoking method '$($Exception.Context.Method)' on component '$($Exception.Context.Component)': $($Exception.Message)" -Data $Exception.Context
        Request-TuiRefresh
    }
}

function global:Initialize-TuiFramework {
    <#
    .SYNOPSIS
    Initializes the TUI framework.
    #>
    Invoke-WithErrorHandling -Component "TuiFramework.Initialize" -Context "Initializing framework" -ScriptBlock {
        # Ensure engine is initialized before the framework.
        if (-not $global:TuiState) {
            throw "TUI Engine must be initialized before the TUI Framework."
        }
        Write-Log -Level Info -Message "TUI Framework initialized." -Data @{ Component = "TuiFramework.Initialize" }
    }
}

function global:Invoke-TuiAsync {
    <#
    .SYNOPSIS
    Executes a script block asynchronously with proper job management.
    #>
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [string]$JobName = "TuiAsyncJob_$(Get-Random)",
        
        [Parameter()]
        [hashtable]$ArgumentList = @{}
    )
    
    Invoke-WithErrorHandling -Component "TuiFramework.Async" -Context "Starting async job: $JobName" -ScriptBlock {
        # Start the job
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList -Name $JobName
        
        # Track the job
        $script:TuiAsyncJobs += $job
        
        Write-Log -Level Debug -Message "Started async job: $JobName" -Data @{ 
            Component = "TuiFramework.Async"; 
            JobId = $job.Id; 
            JobName = $JobName 
        }
        
        return $job
    }
}

function global:Get-TuiAsyncResults {
    <#
    .SYNOPSIS
    Checks for completed async jobs and returns their results.
    #>
    param(
        [Parameter()]
        [switch]$RemoveCompleted = $true
    )
    
    Invoke-WithErrorHandling -Component "TuiFramework.AsyncResults" -Context "Checking async job results" -ScriptBlock {
        $results = @()
        $completedJobs = @()
        
        foreach ($job in $script:TuiAsyncJobs) {
            if ($job.State -in @('Completed', 'Failed', 'Stopped')) {
                $result = @{
                    JobId = $job.Id
                    JobName = $job.Name
                    State = $job.State
                    Output = if ($job.State -eq 'Completed') { Receive-Job -Job $job } else { $null }
                    Error = if ($job.State -eq 'Failed') { $job.ChildJobs[0].JobStateInfo.Reason } else { $null }
                }
                
                $results += $result
                $completedJobs += $job
                
                Write-Log -Level Debug -Message "Async job completed: $($job.Name)" -Data @{ 
                    Component = "TuiFramework.AsyncResults"; 
                    JobId = $job.Id; 
                    State = $job.State 
                }
            }
        }
        
        # Remove completed jobs if requested
        if ($RemoveCompleted -and $completedJobs.Count -gt 0) {
            foreach ($job in $completedJobs) {
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                $script:TuiAsyncJobs = $script:TuiAsyncJobs | Where-Object { $_.Id -ne $job.Id }
            }
        }
        
        return $results
    }
}

function global:Stop-AllTuiAsyncJobs {
    <#
    .SYNOPSIS
    Stops and removes all running TUI async jobs.
    #>
    Invoke-WithErrorHandling -Component "TuiFramework.StopAsync" -Context "Stopping all async jobs" -ScriptBlock {
        foreach ($job in $script:TuiAsyncJobs) {
            try {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
                Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
                Write-Log -Level Debug -Message "Stopped async job: $($job.Name)" -Data @{ 
                    Component = "TuiFramework.StopAsync"; 
                    JobId = $job.Id 
                }
            }
            catch {
                Write-Log -Level Warning -Message "Failed to stop job $($job.Name): $_" -Data @{ 
                    Component = "TuiFramework.StopAsync"; 
                    JobId = $job.Id; 
                    Error = $_.Exception.Message 
                }
            }
        }
        
        $script:TuiAsyncJobs = @()
        Write-Log -Level Info -Message "All TUI async jobs stopped" -Data @{ Component = "TuiFramework.StopAsync" }
    }
}

function global:Request-TuiRefresh {
    <#
    .SYNOPSIS
    Requests a UI refresh to update the display.
    #>
    if ($global:TuiState -and $global:TuiState.RequestRefresh) {
        & $global:TuiState.RequestRefresh
    }
    else {
        # Publish event as fallback
        Publish-Event -EventName "TUI.RefreshRequested" -Data @{ Timestamp = Get-Date }
    }
}

function global:Get-TuiState {
    <#
    .SYNOPSIS
    Gets the current TUI state object.
    #>
    return $global:TuiState
}

# AI: Helper function to safely validate TUI state
function global:Test-TuiState {
    <#
    .SYNOPSIS
    Validates that the TUI state is properly initialized.
    #>
    param(
        [Parameter()]
        [switch]$ThrowOnError
    )
    
    $isValid = $null -ne $global:TuiState -and 
               $null -ne $global:TuiState.IsRunning -and
               $null -ne $global:TuiState.CurrentScreen
    
    if (-not $isValid -and $ThrowOnError) {
        throw "TUI state is not properly initialized. Call Initialize-TuiEngine first."
    }
    
    return $isValid
}

# Export public functions
Export-ModuleMember -Function @(
    'Invoke-TuiMethod',
    'Initialize-TuiFramework', 
    'Invoke-TuiAsync',
    'Get-TuiAsyncResults',
    'Stop-AllTuiAsyncJobs',
    'Request-TuiRefresh',
    'Get-TuiState',
    'Test-TuiState'
)


####\screens\dashboard\dashboard-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Dashboard Screen
# Main entry screen for the application.
# ==============================================================================

# Import models for Task and enum types
using module '..\..\modules\models.psm1'

# Import base classes and components this screen uses
using module '..\..\components\ui-classes.psm1'
using module '..\..\components\panel-classes.psm1'
using module '..\..\components\table-class.psm1'

# AI: Import utilities - removed as these are loaded by main app in correct order
# Note: Invoke-WithErrorHandling is available globally from exceptions module

class DashboardScreen : Screen {
    # --- UI Components ---
    [BorderPanel] $MainPanel
    [ContentPanel] $SummaryPanel
    [Table] $MenuTable
    
    # --- State ---
    [object[]] $Tasks = @()

    DashboardScreen([hashtable]$services) : base("DashboardScreen", $services) {
        Write-Log -Level Info -Message "Creating DashboardScreen instance."
    }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "Initialize" -ScriptBlock {
            # --- Panel Setup ---
            $this.MainPanel = [BorderPanel]::new("DashboardMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "PMC Terminal v5 - Dashboard"
            $this.MainPanel.BorderStyle = "Double"
            $this.AddPanel($this.MainPanel)

            $this.SummaryPanel = [ContentPanel]::new("DashboardSummary", 2, 2, 40, 10)
            $this.MainPanel.AddChild($this.SummaryPanel)

            # --- Main Menu Table ---
            $this.MenuTable = [Table]::new("MainMenu")
            $this.MenuTable.SetColumns(@(
                [TableColumn]::new("Key", "Key", 5),
                [TableColumn]::new("Action", "Action", 40)
            ))
            $menuItems = @(
                [pscustomobject]@{ Key = '1'; Action = 'Task Management'; Screen = 'TaskListScreen' },
                [pscustomobject]@{ Key = '2'; Action = 'Project Management'; Screen = 'ProjectListScreen' },
                [pscustomobject]@{ Key = '3'; Action = 'Settings'; Screen = 'SettingsScreen' },
                [pscustomobject]@{ Key = 'Q'; Action = 'Quit Application'; Screen = 'EXIT' }
            )
            $this.MenuTable.SetData($menuItems)
            $this.MenuTable.ShowHeaders = $false
            
            # Add table to a containing panel for layout
            $menuPanel = [BorderPanel]::new("MenuContainer", 44, 2, 50, 10)
            $menuPanel.Title = "Main Menu"
            $menuPanel.AddChild($this.MenuTable)
            $this.MainPanel.AddChild($menuPanel)

            # --- Event Subscription & Data Refresh ---
            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData() # Initial data load
        }
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "RefreshData" -ScriptBlock {
            $this.Tasks = @($this.Services.DataManager.GetTasks())
            $this.UpdateSummary()
        }
    }

    hidden [void] UpdateSummary() {
        $total = $this.Tasks.Count
        $completed = ($this.Tasks | Where-Object { $_.Status -eq [TaskStatus]::Completed }).Count
        
        $summaryContent = @(
            "Task Summary",
            "------------",
            "Total Tasks: $total",
            "Completed:   $completed"
        )
        $this.SummaryPanel.SetContent($summaryContent)
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "DashboardScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { $this.MenuTable.SelectPrevious() }
                ([ConsoleKey]::DownArrow) { $this.MenuTable.SelectNext() }
                ([ConsoleKey]::Enter) {
                    $selectedItem = $this.MenuTable.GetSelectedItem()
                    if ($selectedItem) {
                        if ($selectedItem.Screen -eq 'EXIT') {
                            $this.Services.Navigation.RequestExit()
                        } else {
                            $this.Services.Navigation.PushScreen($selectedItem.Screen)
                        }
                    }
                }
                default {
                    # Handle hotkeys
                    $selectedItem = $this.MenuTable.Data | Where-Object { $_.Key -eq $key.KeyChar.ToString().ToUpper() } | Select-Object -First 1
                    if ($selectedItem) {
                         if ($selectedItem.Screen -eq 'EXIT') {
                            $this.Services.Navigation.RequestExit()
                        } else {
                            $this.Services.Navigation.PushScreen($selectedItem.Screen)
                        }
                    }
                }
            }
        }
    }
}


####\screens\task-list-screen.psm1
# ==============================================================================
# PMC Terminal v5 - Class-Based Task List Screen
# Displays and manages tasks.
# ==============================================================================

# Import models for Task and enum types
using module '..\modules\models.psm1'

# Import base classes and components
using module '..\components\ui-classes.psm1'
using module '..\components\panel-classes.psm1'
using module '..\components\table-class.psm1'

# AI: Removed utility imports - these are loaded globally by main application
# Note: error-handling and event-system functions are available globally

class TaskListScreen : Screen {
    # --- UI Components ---
    [BorderPanel] $MainPanel
    [Table] $TaskTable
    [ContentPanel] $NavPanel

    # --- State ---
    [string] $FilterStatus = "All"

    TaskListScreen([hashtable]$services) : base("TaskListScreen", $services) { }

    [void] Initialize() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "Initialize" -ScriptBlock {
            # --- Panel Setup ---
            $this.MainPanel = [BorderPanel]::new("TaskListMain", 0, 0, 120, 30)
            $this.MainPanel.Title = "Task List"
            $this.AddPanel($this.MainPanel)

            # --- Task Table ---
            $this.TaskTable = [Table]::new("TaskTable")
            $this.TaskTable.SetColumns(@(
                [TableColumn]::new("Title", "Task Title", 50),
                [TableColumn]::new("Status", "Status", 15),
                [TableColumn]::new("Priority", "Priority", 12),
                [TableColumn]::new("DueDate", "Due Date", 15)
            ))
            
            $tableContainer = [BorderPanel]::new("TableContainer", 1, 1, 118, 24)
            $tableContainer.ShowBorder = $false
            $tableContainer.AddChild($this.TaskTable)
            $this.MainPanel.AddChild($tableContainer)
            
            # --- Navigation Panel ---
            $this.NavPanel = [ContentPanel]::new("NavPanel", 1, 26, 118, 3)
            $this.MainPanel.AddChild($this.NavPanel)
            
            # --- Event Subscriptions & Data Load ---
            $this.SubscribeToEvent("Tasks.Changed", { $this.RefreshData() })
            $this.RefreshData()
        }
    }

    hidden [void] RefreshData() {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "RefreshData" -ScriptBlock {
            $allTasks = @($this.Services.DataManager.GetTasks())
            $filteredTasks = switch ($this.FilterStatus) {
                "Active" { $allTasks | Where-Object { $_.Status -ne 'Completed' } }
                "Completed" { $allTasks | Where-Object { $_.Status -eq 'Completed' } }
                default { $allTasks }
            }
            $this.TaskTable.SetData($filteredTasks)
            $this.UpdateNavText()
        }
    }

    hidden [void] UpdateNavText() {
        $navContent = @(
            "[N]ew | [E]dit | [D]elete | [Space]Toggle | [F]ilter: $($this.FilterStatus) | [Esc]Back"
        )
        $this.NavPanel.SetContent($navContent)
    }

    [void] HandleInput([ConsoleKeyInfo]$key) {
        Invoke-WithErrorHandling -Component "TaskListScreen" -Context "HandleInput" -ScriptBlock {
            switch ($key.Key) {
                ([ConsoleKey]::UpArrow) { $this.TaskTable.SelectPrevious() }
                ([ConsoleKey]::DownArrow) { $this.TaskTable.SelectNext() }
                ([ConsoleKey]::Spacebar) { $this.ToggleSelectedTask() }
                ([ConsoleKey]::Escape) { $this.Services.Navigation.PopScreen() }
                default {
                    switch ($key.KeyChar.ToString().ToUpper()) {
                        'N' { $this.Services.Navigation.PushScreen("NewTaskScreen") }
                        'E' { # Edit logic would go here }
                        'D' { # Delete logic would go here }
                        'F' { $this.CycleFilter() }
                    }
                }
            }
        }
    }
    
    hidden [void] ToggleSelectedTask() {
        $task = $this.TaskTable.GetSelectedItem()
        if ($task) {
            if ($task.Status -eq [TaskStatus]::Completed) {
                $task.Status = [TaskStatus]::Active
            } else {
                $task.Complete()
            }
            $this.Services.DataManager.UpdateTask($task)
        }
    }

    hidden [void] CycleFilter() {
        $this.FilterStatus = switch ($this.FilterStatus) {
            "All" { "Active" }
            "Active" { "Completed" }
            default { "All" }
        }
        $this.RefreshData()
    }
}


####\services\keybinding-service.psm1
# KeybindingService - Class-Based Implementation
# Manages application keybindings with proper error handling and validation
# AI: Updated with sophisticated keybinding features from R2 version

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import utilities
Import-Module -Name "$PSScriptRoot\..\utilities\error-handling.psm1" -Force

# KeybindingService Class - Manages application-wide key bindings
class KeybindingService {
    [hashtable] $KeyMap = @{}
    [hashtable] $GlobalHandlers = @{}
    [System.Collections.Generic.List[string]] $ContextStack
    [bool] $EnableChords = $false
    
    KeybindingService() {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized" -Component "KeybindingService"
    }
    
    KeybindingService([bool]$enableChords) {
        $this.ContextStack = [System.Collections.Generic.List[string]]::new()
        $this.EnableChords = $enableChords
        $this.InitializeDefaultBindings()
        
        Write-Log -Level Info -Message "KeybindingService initialized with chords: $enableChords" -Component "KeybindingService"
    }
    
    hidden [void] InitializeDefaultBindings() {
        # AI: Standard application keybindings
        $this.KeyMap = @{
            "app.exit" = @{ Key = "Q"; Modifiers = @("Ctrl") }
            "app.help" = @{ Key = [System.ConsoleKey]::F1; Modifiers = @() }
            "nav.back" = @{ Key = [System.ConsoleKey]::Escape; Modifiers = @() }
            "nav.up" = @{ Key = [System.ConsoleKey]::UpArrow; Modifiers = @() }
            "nav.down" = @{ Key = [System.ConsoleKey]::DownArrow; Modifiers = @() }
            "nav.left" = @{ Key = [System.ConsoleKey]::LeftArrow; Modifiers = @() }
            "nav.right" = @{ Key = [System.ConsoleKey]::RightArrow; Modifiers = @() }
            "nav.select" = @{ Key = [System.ConsoleKey]::Enter; Modifiers = @() }
            "nav.pageup" = @{ Key = [System.ConsoleKey]::PageUp; Modifiers = @() }
            "nav.pagedown" = @{ Key = [System.ConsoleKey]::PageDown; Modifiers = @() }
            "nav.home" = @{ Key = [System.ConsoleKey]::Home; Modifiers = @() }
            "nav.end" = @{ Key = [System.ConsoleKey]::End; Modifiers = @() }
            "nav.tab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @() }
            "nav.shifttab" = @{ Key = [System.ConsoleKey]::Tab; Modifiers = @("Shift") }
            "edit.delete" = @{ Key = [System.ConsoleKey]::Delete; Modifiers = @() }
            "edit.backspace" = @{ Key = [System.ConsoleKey]::Backspace; Modifiers = @() }
            "edit.new" = @{ Key = "n"; Modifiers = @() }
            "edit.save" = @{ Key = "s"; Modifiers = @("Ctrl") }
            "app.refresh" = @{ Key = [System.ConsoleKey]::F5; Modifiers = @() }
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKey]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key" -Component "KeybindingService"
        }
    }
    
    [void] SetBinding([string]$actionName, [char]$key, [string[]]$modifiers) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "SetBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            
            $this.KeyMap[$actionName.ToLower()] = @{
                Key = $key
                Modifiers = if ($modifiers) { @($modifiers) } else { @() }
            }
            
            Write-Log -Level Debug -Message "Set keybinding: $actionName -> $key" -Component "KeybindingService"
        }
    }
    
    [void] SetBinding([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
        }
        
        $modifiers = @()
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) { $modifiers += "Ctrl" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) { $modifiers += "Alt" }
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) { $modifiers += "Shift" }

        $this.KeyMap[$actionName.ToLower()] = @{
            Key = $keyInfo.Key
            KeyChar = $keyInfo.KeyChar
            Modifiers = $modifiers
        }
        Write-Log -Level Debug -Message "Set keybinding for '$actionName': $($this.GetBindingDescription($actionName))" -Component "KeybindingService"
    }
    
    [void] RemoveBinding([string]$actionName) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RemoveBinding:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return
            }
            
            $normalizedName = $actionName.ToLower()
            if ($this.KeyMap.ContainsKey($normalizedName)) {
                $this.KeyMap.Remove($normalizedName)
                Write-Log -Level Debug -Message "Removed keybinding: $actionName" -Component "KeybindingService"
            }
        }
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo) {
        return $this.IsAction($actionName, $keyInfo, $null)
    }
    
    [bool] IsAction([string]$actionName, [System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "IsAction:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                return $false
            }
            
            $normalizedName = $actionName.ToLower()
            if (-not $this.KeyMap.ContainsKey($normalizedName)) {
                return $false
            }
            
            $binding = $this.KeyMap[$normalizedName]
            
            # Check if the key matches
            $keyMatches = $false
            if ($binding.Key -is [System.ConsoleKey]) {
                $keyMatches = ($keyInfo.Key -eq $binding.Key)
            }
            elseif ($binding.Key -is [char]) {
                $keyMatches = ($keyInfo.KeyChar -eq $binding.Key)
            }
            elseif ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
                # Character-based binding (case-insensitive)
                $keyMatches = $keyInfo.KeyChar.ToString().Equals($binding.KeyChar.ToString(), [System.StringComparison]::OrdinalIgnoreCase)
            }
            else {
                # Try string comparison for backward compatibility
                $keyString = $binding.Key.ToString()
                if ($keyString.Length -eq 1) {
                    $keyMatches = ($keyInfo.KeyChar.ToString().ToUpper() -eq $keyString.ToUpper())
                }
                else {
                    # Try to match against ConsoleKey enum
                    try {
                        $consoleKey = [System.ConsoleKey]::Parse([System.ConsoleKey], $keyString, $true)
                        $keyMatches = ($keyInfo.Key -eq $consoleKey)
                    }
                    catch {
                        $keyMatches = $false
                    }
                }
            }
            
            if (-not $keyMatches) {
                return $false
            }
            
            # Check modifiers
            $hasCtrl = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) -ne 0
            $hasAlt = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Alt) -ne 0
            $hasShift = ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            $expectedCtrl = $binding.Modifiers -contains "Ctrl"
            $expectedAlt = $binding.Modifiers -contains "Alt"
            $expectedShift = $binding.Modifiers -contains "Shift"
            
            return ($hasCtrl -eq $expectedCtrl) -and ($hasAlt -eq $expectedAlt) -and ($hasShift -eq $expectedShift)
        }
    }
    
    [string] GetAction([System.ConsoleKeyInfo]$keyInfo) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "GetAction" -ScriptBlock {
            foreach ($actionName in $this.KeyMap.Keys) {
                if ($this.IsAction($actionName, $keyInfo)) {
                    return $actionName
                }
            }
            return $null
        }
    }
    
    [void] RegisterGlobalHandler([string]$actionName, [scriptblock]$handler) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "RegisterGlobalHandler:$actionName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($actionName)) {
                throw [System.ArgumentException]::new("Action name cannot be null or empty", "actionName")
            }
            if ($null -eq $handler) {
                throw [System.ArgumentNullException]::new("handler", "Handler cannot be null")
            }
            
            $this.GlobalHandlers[$actionName.ToLower()] = $handler
            Write-Log -Level Debug -Message "Registered global handler: $actionName" -Component "KeybindingService"
        }
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo) {
        return $this.HandleKey($keyInfo, $null)
    }
    
    [object] HandleKey([System.ConsoleKeyInfo]$keyInfo, [string]$context) {
        return Invoke-WithErrorHandling -Component "KeybindingService" -Context "HandleKey" -ScriptBlock {
            # Check all registered actions
            foreach ($action in $this.KeyMap.Keys) {
                if ($this.IsAction($action, $keyInfo, $context)) {
                    # Execute global handler if registered
                    if ($this.GlobalHandlers.ContainsKey($action)) {
                        Write-Log -Level Debug -Message "Executing global handler: $action" -Component "KeybindingService"
                        try {
                            return & $this.GlobalHandlers[$action] -KeyInfo $keyInfo -Context $context
                        }
                        catch {
                            Write-Log -Level Error -Message "Global handler failed for '$action': $_" -Component "KeybindingService"
                            return $null
                        }
                    }
                    
                    # Return the action name for the caller to handle
                    return $action
                }
            }
            
            return $null
        }
    }
    
    [void] PushContext([string]$context) {
        if (-not [string]::IsNullOrWhiteSpace($context)) {
            $this.ContextStack.Add($context)
            Write-Log -Level Debug -Message "Pushed keybinding context: $context (Stack depth: $($this.ContextStack.Count))" -Component "KeybindingService"
        }
    }
    
    [string] PopContext() {
        if ($this.ContextStack.Count -gt 0) {
            $context = $this.ContextStack[-1]
            $this.ContextStack.RemoveAt($this.ContextStack.Count - 1)
            Write-Log -Level Debug -Message "Popped keybinding context: $context (Stack depth: $($this.ContextStack.Count))" -Component "KeybindingService"
            return $context
        }
        return $null
    }
    
    [string] GetCurrentContext() {
        if ($this.ContextStack.Count -gt 0) {
            return $this.ContextStack[-1]
        }
        return "global"
    }
    
    [string] GetBindingDescription([string]$actionName) {
        if ([string]::IsNullOrWhiteSpace($actionName)) {
            return $null
        }
        
        $normalizedName = $actionName.ToLower()
        if (-not $this.KeyMap.ContainsKey($normalizedName)) {
            return "Unbound"
        }
        
        $binding = $this.KeyMap[$normalizedName]
        $keyStr = if ($binding.ContainsKey('KeyChar') -and $binding.KeyChar -ne [char]0) {
            $binding.KeyChar.ToString().ToUpper()
        } elseif ($binding.Key -is [System.ConsoleKey]) {
            $binding.Key.ToString()
        } else {
            $binding.Key.ToString().ToUpper()
        }
        
        if ($binding.Modifiers.Count -gt 0) {
            return "$($binding.Modifiers -join '+') + $keyStr"
        }
        
        return $keyStr
    }
    
    [hashtable] GetAllBindings() {
        return $this.GetAllBindings($false)
    }
    
    [hashtable] GetAllBindings([bool]$groupByCategory) {
        if (-not $groupByCategory) {
            return $this.KeyMap.Clone()
        }
        
        # Group by category (part before the dot)
        $grouped = @{}
        foreach ($action in $this.KeyMap.Keys) {
            $parts = $action.Split('.')
            $category = if ($parts.Count -gt 1) { $parts[0] } else { "General" }
            if (-not $grouped.ContainsKey($category)) {
                $grouped[$category] = @{}
            }
            $grouped[$category][$action] = $this.KeyMap[$action]
        }
        
        return $grouped
    }
    
    [void] ExportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ExportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            $this.KeyMap | ConvertTo-Json -Depth 3 | Out-File -FilePath $path -Encoding UTF8
            Write-Log -Level Info -Message "Exported keybindings to: $path" -Component "KeybindingService"
        }
    }
    
    [void] ImportBindings([string]$path) {
        Invoke-WithErrorHandling -Component "KeybindingService" -Context "ImportBindings" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Path cannot be null or empty", "path")
            }
            
            if (-not (Test-Path $path)) {
                Write-Log -Level Warning -Message "Keybindings file not found: $path" -Component "KeybindingService"
                return
            }
            
            try {
                $imported = Get-Content $path -Raw | ConvertFrom-Json
                foreach ($prop in $imported.PSObject.Properties) {
                    $this.KeyMap[$prop.Name] = @{
                        Key = $prop.Value.Key
                        Modifiers = $prop.Value.Modifiers
                    }
                    # Handle KeyChar if present
                    if ($prop.Value.PSObject.Properties.Name -contains 'KeyChar') {
                        $this.KeyMap[$prop.Name].KeyChar = $prop.Value.KeyChar
                    }
                }
                Write-Log -Level Info -Message "Imported keybindings from: $path" -Component "KeybindingService"
            }
            catch {
                Write-Log -Level Error -Message "Failed to import keybindings from '$path': $_" -Component "KeybindingService"
                throw
            }
        }
    }
}

# Initialize function for backward compatibility
function Initialize-KeybindingService {
    param(
        [bool]$EnableChords = $false,
        [hashtable]$CustomBindings = @{}
    )
    
    $service = [KeybindingService]::new($EnableChords)
    
    # Apply custom bindings if provided
    if ($CustomBindings.Count -gt 0) {
        foreach ($action in $CustomBindings.Keys) {
            $binding = $CustomBindings[$action]
            if ($binding.Key -and $binding.Modifiers) {
                $service.SetBinding($action, $binding.Key, $binding.Modifiers)
            }
        }
    }
    
    return $service
}

# Export the functions and classes
Export-ModuleMember -Function Initialize-KeybindingService


####\services\navigation-service-class.psm1
# Navigation Service - Class-Based Implementation
# Manages screen navigation with proper error handling and validation
# AI: Updated with sophisticated navigation features from R2 version

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

#region Screen Factory Class for creating screen instances

class ScreenFactory {
    [hashtable] $Services
    [hashtable] $ScreenTypes = @{}
    
    ScreenFactory([hashtable]$services) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        $this.Services = $services
        $this.RegisterDefaultScreens()
    }
    
    hidden [void] RegisterDefaultScreens() {
        # AI: Register factory functions for both class-based and hashtable-based screens
        $this.ScreenTypes = @{
            "DashboardScreen" = { param($services) $this.CreateClassBasedScreen("DashboardScreen", $services) }
            "TaskListScreen" = { param($services) $this.CreateClassBasedScreen("TaskListScreen", $services) }
            # AI: Removed NewTaskScreen until it's implemented
        }
        
        # AI: Also support function-based screens for backward compatibility
        if (Get-Command "Get-DashboardScreen" -ErrorAction SilentlyContinue) {
            $this.ScreenTypes["DashboardScreen"] = { param($services) Get-DashboardScreen -Services $services }
        }
        if (Get-Command "Get-TaskManagementScreen" -ErrorAction SilentlyContinue) {
            $this.ScreenTypes["TaskManagementScreen"] = { param($services) Get-TaskManagementScreen -Services $services }
        }
    }
    
    hidden [object] CreateClassBasedScreen([string]$screenName, [hashtable]$services) {
        # AI: Try to create class-based screen dynamically, fallback to function-based
        try {
            # Attempt to get the type dynamically without hardcoding class names
            $screenType = "$screenName" -as [type]
            if ($screenType) {
                # Check if the type has a constructor that takes services
                $constructor = $screenType.GetConstructor([type[]]@([hashtable]))
                if ($constructor) {
                    return $screenType::new($services)
                }
            }
        }
        catch {
            # Ignore type resolution errors and fall through to function-based approach
        }
        
        # Fallback: try to find and call a function-based screen creator
        $functionName = "Get-$screenName"
        if (Get-Command $functionName -ErrorAction SilentlyContinue) {
            return & $functionName -Services $services
        }
        
        throw [System.InvalidOperationException]::new("Unable to create screen: $screenName")
    }
    
    [void] RegisterScreen([string]$name, [scriptblock]$factory) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw [System.ArgumentException]::new("Screen name cannot be null or empty", "name")
        }
        if ($null -eq $factory) {
            throw [System.ArgumentNullException]::new("factory", "Screen factory cannot be null")
        }
        
        $this.ScreenTypes[$name] = $factory
        Write-Log -Level Debug -Message "Registered screen factory: $name"
    }
    
    [object] CreateScreen([string]$screenName) {
        return $this.CreateScreen($screenName, @{})
    }
    
    [object] CreateScreen([string]$screenName, [hashtable]$parameters) {
        if ([string]::IsNullOrWhiteSpace($screenName)) {
            throw [System.ArgumentException]::new("Screen name cannot be null or empty", "screenName")
        }
        
        if (-not $this.ScreenTypes.ContainsKey($screenName)) {
            $availableScreens = ($this.ScreenTypes.Keys | Sort-Object) -join ", "
            throw [System.InvalidOperationException]::new(
                "Unknown screen type: '$screenName'. Available screens: $availableScreens"
            )
        }
        
        try {
            $factory = $this.ScreenTypes[$screenName]
            $screen = & $factory -services $this.Services
            
            if ($null -eq $screen) {
                throw [System.InvalidOperationException]::new("Screen factory returned null for '$screenName'")
            }
            
            # Store services reference on screen for later use
            if ($screen -is [hashtable] -and -not $screen._services) {
                $screen._services = $this.Services
            }
            elseif ($screen.PSObject.Properties.Name -contains "Services" -and -not $screen.Services) {
                $screen.Services = $this.Services
            }
            
            # Apply parameters to screen state
            if ($parameters -and $parameters.Count -gt 0) {
                if ($screen -is [hashtable] -and $screen.ContainsKey("State")) {
                    foreach ($key in $parameters.Keys) {
                        $screen.State[$key] = $parameters[$key]
                    }
                }
                elseif ($screen.PSObject.Properties.Name -contains "State") {
                    foreach ($key in $parameters.Keys) {
                        $screen.State[$key] = $parameters[$key]
                    }
                }
            }
            
            Write-Log -Level Debug -Message "Created screen: $screenName"
            return $screen
        }
        catch {
            Write-Log -Level Error -Message "Failed to create screen '$screenName': $_"
            throw
        }
    }
}

#endregion

#region Navigation Service Class - Manages screen stack and navigation

class NavigationService {
    [System.Collections.Generic.Stack[object]] $ScreenStack
    [ScreenFactory] $ScreenFactory
    [object] $CurrentScreen
    [hashtable] $Services
    [int] $MaxStackDepth = 10
    [hashtable] $NavigationHistory = @{}
    [hashtable] $RouteMap = @{}
    
    NavigationService([hashtable]$services) {
        if ($null -eq $services) {
            throw [System.ArgumentNullException]::new("services", "Services cannot be null")
        }
        
        $this.Services = $services
        $this.ScreenStack = [System.Collections.Generic.Stack[object]]::new()
        $this.ScreenFactory = [ScreenFactory]::new($services)
        $this.InitializeRoutes()
        
        Write-Log -Level Info -Message "NavigationService initialized"
    }
    
    hidden [void] InitializeRoutes() {
        # AI: Map URL-like paths to screen names
        $this.RouteMap = @{
            "/" = "DashboardScreen"
            "/dashboard" = "DashboardScreen"
            "/tasks" = "TaskListScreen"
            # AI: Removed /new-task route until NewTaskScreen is implemented
        }
    }
    
    [void] RegisterRoute([string]$path, [string]$screenName) {
        if ([string]::IsNullOrWhiteSpace($path)) {
            throw [System.ArgumentException]::new("Route path cannot be null or empty", "path")
        }
        if ([string]::IsNullOrWhiteSpace($screenName)) {
            throw [System.ArgumentException]::new("Screen name cannot be null or empty", "screenName")
        }
        
        $this.RouteMap[$path] = $screenName
        Write-Log -Level Debug -Message "Registered route: $path -> $screenName"
    }
    
    [void] PushScreen([string]$screenName) {
        $this.PushScreen($screenName, @{})
    }
    
    [void] PushScreen([string]$screenName, [hashtable]$parameters) {
        Invoke-WithErrorHandling -Component "NavigationService" -Context "PushScreen:$screenName" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($screenName)) {
                throw [System.ArgumentException]::new("Screen name cannot be null or empty", "screenName")
            }
            
            # Check stack depth limit
            if ($this.ScreenStack.Count -ge $this.MaxStackDepth) {
                throw [System.InvalidOperationException]::new(
                    "Navigation stack depth limit reached ($($this.MaxStackDepth))"
                )
            }
            
            Write-Log -Level Info -Message "Pushing screen: $screenName"
            
            # Handle current screen exit
            if ($null -ne $this.CurrentScreen) {
                try {
                    $this.CallScreenMethod($this.CurrentScreen, "OnExit")
                    $this.ScreenStack.Push($this.CurrentScreen)
                }
                catch {
                    Write-Log -Level Warning -Message "Error during current screen cleanup: $_"
                }
            }
            
            # Create new screen
            $newScreen = $this.ScreenFactory.CreateScreen($screenName, $parameters)
            
            # Set as current screen
            $this.CurrentScreen = $newScreen
            
            # Initialize the new screen
            try {
                $this.CallScreenMethod($newScreen, "Initialize", $this.Services)
                $this.CallScreenMethod($newScreen, "OnEnter")
            }
            catch {
                Write-Log -Level Error -Message "Failed to initialize screen '$screenName': $_"
                throw
            }
            
            # Track navigation history
            $this.TrackNavigation($screenName, "Push")
            
            # Update TUI state if available
            if ($global:TuiState) {
                $global:TuiState.CurrentScreen = $newScreen
                if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                    Request-TuiRefresh
                }
            }
            
            # Publish navigation event
            if (Get-Command "Publish-Event" -ErrorAction SilentlyContinue) {
                # AI: Ensure event data is serializable
                $eventData = @{
                    Screen = $screenName
                    Action = "Push"
                    StackDepth = $this.ScreenStack.Count + 1
                }
                
                # AI: Only include parameters if they're simple types
                if ($parameters -and $parameters.Count -gt 0) {
                    $simpleParams = @{}
                    foreach ($key in $parameters.Keys) {
                        $value = $parameters[$key]
                        if ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) {
                            $simpleParams[$key] = $value
                        }
                    }
                    if ($simpleParams.Count -gt 0) {
                        $eventData.Parameters = $simpleParams
                    }
                }
                
                Publish-Event -EventName "Navigation.ScreenChanged" -Data $eventData
            }
            
            Write-Log -Level Debug -Message "Screen '$screenName' pushed successfully. Stack depth: $($this.ScreenStack.Count + 1)"
        }
    }
    
    [bool] PopScreen() {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "PopScreen" -ScriptBlock {
            if ($this.ScreenStack.Count -eq 0) {
                Write-Log -Level Warning -Message "Cannot pop screen: stack is empty"
                return $false
            }
            
            Write-Log -Level Info -Message "Popping screen"
            
            # Exit current screen
            if ($null -ne $this.CurrentScreen) {
                try {
                    $this.CallScreenMethod($this.CurrentScreen, "OnExit")
                }
                catch {
                    Write-Log -Level Warning -Message "Error during screen exit: $_"
                }
            }
            
            # Pop previous screen
            $this.CurrentScreen = $this.ScreenStack.Pop()
            
            # Resume previous screen
            if ($null -ne $this.CurrentScreen) {
                try {
                    $this.CallScreenMethod($this.CurrentScreen, "OnResume")
                }
                catch {
                    Write-Log -Level Warning -Message "Error during screen resume: $_"
                }
                
                # Update TUI state
                if ($global:TuiState) {
                    $global:TuiState.CurrentScreen = $this.CurrentScreen
                    if (Get-Command "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
                        Request-TuiRefresh
                    }
                }
            }
            
            # Publish event
            if (Get-Command "Publish-Event" -ErrorAction SilentlyContinue) {
                $screenName = if ($this.CurrentScreen -is [hashtable] -and $this.CurrentScreen.Name) {
                    $this.CurrentScreen.Name
                } elseif ($this.CurrentScreen.PSObject.Properties.Name -contains "Name") {
                    $this.CurrentScreen.Name
                } else {
                    $null
                }
                
                Publish-Event -EventName "Navigation.ScreenPopped" -Data @{
                    CurrentScreen = $screenName
                    StackDepth = $this.ScreenStack.Count
                }
            }
            
            return $true
        }
    }
    
    [bool] GoTo([string]$path) {
        return $this.GoTo($path, @{})
    }
    
    [bool] GoTo([string]$path, [hashtable]$parameters) {
        return Invoke-WithErrorHandling -Component "NavigationService" -Context "GoTo:$path" -ScriptBlock {
            if ([string]::IsNullOrWhiteSpace($path)) {
                throw [System.ArgumentException]::new("Navigation path cannot be null or empty", "path")
            }
            
            Write-Log -Level Info -Message "Navigating to path: $path"
            
            # Handle special cases
            if ($path -eq "/exit") {
                $this.RequestExit()
                return $true
            }
            
            # Map path to screen name
            if (-not $this.RouteMap.ContainsKey($path)) {
                $availableRoutes = ($this.RouteMap.Keys | Sort-Object) -join ", "
                Write-Log -Level Warning -Message "Unknown navigation path: $path. Available routes: $availableRoutes"
                return $false
            }
            
            $screenName = $this.RouteMap[$path]
            
            try {
                $this.PushScreen($screenName, $parameters)
                return $true
            }
            catch {
                Write-Log -Level Error -Message "Failed to navigate to '$screenName' via path '$path': $_"
                return $false
            }
        }
    }
    
    [void] RequestExit() {
        Write-Log -Level Info -Message "Exit requested"
        
        # Clean up all screens
        while ($this.ScreenStack.Count -gt 0) {
            try {
                $this.PopScreen()
            }
            catch {
                Write-Log -Level Warning -Message "Error during exit cleanup: $_"
            }
        }
        
        # Exit current screen
        if ($null -ne $this.CurrentScreen) {
            try {
                $this.CallScreenMethod($this.CurrentScreen, "OnExit")
            }
            catch {
                Write-Log -Level Warning -Message "Error during final screen cleanup: $_"
            }
        }
        
        # Stop TUI engine if available
        if (Get-Command "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            Stop-TuiEngine
        }
        
        # Publish exit event
        if (Get-Command "Publish-Event" -ErrorAction SilentlyContinue) {
            Publish-Event -EventName "Application.Exit" -Data @{}
        }
    }
    
    [object] GetCurrentScreen() {
        return $this.CurrentScreen
    }
    
    [int] GetStackDepth() {
        return $this.ScreenStack.Count
    }
    
    [string[]] GetAvailableRoutes() {
        return $this.RouteMap.Keys | Sort-Object
    }
    
    [bool] IsValidRoute([string]$path) {
        return $this.RouteMap.ContainsKey($path)
    }
    
    [hashtable] GetNavigationStats() {
        return $this.NavigationHistory.Clone()
    }
    
    hidden [void] CallScreenMethod([object]$screen, [string]$methodName) {
        $this.CallScreenMethod($screen, $methodName, $null)
    }
    
    hidden [void] CallScreenMethod([object]$screen, [string]$methodName, [object]$parameter) {
        if ($null -eq $screen) {
            return
        }
        
        try {
            # Handle both class-based and hashtable-based screens
            if ($screen -is [hashtable] -and $screen.ContainsKey($methodName)) {
                $method = $screen[$methodName]
                if ($method -is [scriptblock]) {
                    if ($null -ne $parameter) {
                        & $method -self $screen -parameter $parameter
                    } else {
                        & $method -self $screen
                    }
                }
            }
            elseif ($screen.PSObject.Methods.Name -contains $methodName) {
                # Class-based screen
                if ($null -ne $parameter) {
                    $screen.$methodName($parameter)
                } else {
                    $screen.$methodName()
                }
            }
        }
        catch {
            Write-Log -Level Warning -Message "Error calling screen method '$methodName': $_"
        }
    }
    
    hidden [void] TrackNavigation([string]$screenName, [string]$action) {
        $timestamp = [DateTime]::UtcNow
        
        if (-not $this.NavigationHistory.ContainsKey($screenName)) {
            $this.NavigationHistory[$screenName] = @{
                VisitCount = 0
                LastVisit = $null
                FirstVisit = $timestamp
            }
        }
        
        $this.NavigationHistory[$screenName].VisitCount++
        $this.NavigationHistory[$screenName].LastVisit = $timestamp
        
        Write-Log -Level Debug -Message "Tracked navigation: $screenName ($action)"
    }
}

#endregion

# Initialize function for backward compatibility
function Initialize-NavigationService {
    param([hashtable]$Services)
    
    if (-not $Services) {
        throw [System.ArgumentNullException]::new("Services", "Services parameter is required")
    }
    
    return [NavigationService]::new($Services)
}

# Export the functions and classes
Export-ModuleMember -Function Initialize-NavigationService


####\utilities\DO_NOT_USE\file_util.ps1
# --- CONFIGURATION ---
# The root folder of your existing structure where the files are located.
# This script will search recursively starting from here.
$sourceFolderStructureRoot = "C:\Users\jhnhe\Documents\GitHub\_HELIOS"

# The separate folder where files will be copied and renamed.
$destDir = "C:\Users\jhnhe\Documents\GitHub\_HELIOS\Copies"

# Path to the text file listing the filenames to process.
$fileListPath = "C:\Users\jhnhe\Documents\GitHub\_HELIOS\file_list.txt"


#
# === KEY RENAMING SETTINGS ===
#


# The NEW file extension for all processed files (e.g., ".log", ".txt"). Include the dot.
$newExtension = ".txt"

# A prefix to add to the renamed files (optional, can be "").
$newPrefix = "_"

# Set to $true to automatically delete all files in the destination
# folder before the script runs. This prevents "already exists" errors on re-runs.
$cleanDestinationBeforeRun = $true

# --- CONCATENATION SETTINGS ---
$doConcatenate = $true
$concatenatedFile = "all_processed_data.txt"

# --- SCRIPT (No need to edit below this line) ---

Write-Host "--- Starting File Processing ---" -ForegroundColor Green

# Resolve paths and perform initial checks
try {
    $sourceFolderStructureRoot = (Resolve-Path $sourceFolderStructureRoot -ErrorAction Stop).Path
    $destDir = (Resolve-Path $destDir -ErrorAction Stop).Path
    $fileListPath = (Resolve-Path $fileListPath -ErrorAction Stop).Path
} catch { Write-Error "Error resolving paths. Check your configuration."; Read-Host "Press Enter to exit"; Exit }

if (-not (Test-Path $fileListPath)) { Write-Error "File list not found: $fileListPath"; Read-Host "Press Enter to exit"; Exit }
$filesToProcess = Get-Content $fileListPath -ErrorAction Stop

# Ensure destination directory exists, create if not
if (-not (Test-Path $destDir -PathType Container)) {
    Write-Host "Destination directory '$destDir' not found. Creating it..." -ForegroundColor Yellow
    New-Item -Path $destDir -ItemType Directory | Out-Null
}

if ($cleanDestinationBeforeRun) {
    Write-Host "Cleaning destination directory: $destDir" -ForegroundColor Yellow
    Get-ChildItem -Path $destDir | Remove-Item -Recurse -Force
}

Write-Host "`n--- Step 1 & 2: Backing up (Copying) and Renaming Specified Files ---" -ForegroundColor Green
$renamedFiles = @()

# === CORE LOGIC CHANGE IS HERE ===
foreach ($filePathInList in $filesToProcess) {
    # Skip empty lines in the file list
    if ([string]::IsNullOrWhiteSpace($filePathInList)) { continue }

    # Construct the full path to the source file.
    # This handles both full paths (C:\...) and relative paths (subfolder\file.txt) in your list.
    $fullSourcePath = Join-Path -Path $sourceFolderStructureRoot -ChildPath $filePathInList
    if ([System.IO.Path]::IsPathRooted($filePathInList)) {
        $fullSourcePath = $filePathInList
    }

    Write-Host "Processing: '$fullSourcePath'" -ForegroundColor Cyan

    # Check if the specified file actually exists before trying to process it
    if (-not (Test-Path $fullSourcePath -PathType Leaf)) {
        Write-Warning "  SKIPPED: File not found at the specified path: '$fullSourcePath'"
        continue # Move to the next file in the list
    }

    # Get the file object for the validated path
    $sourceFile = Get-Item -Path $fullSourcePath

    # Construct a unique new name for the destination file
    $baseFileName = $sourceFile.BaseName
    $newFileName = "$newPrefix$baseFileName$newExtension"
    
    # In case of duplicate filenames from different subfolders, add parent folder to name
    if (($renamedFiles.Name).Contains($newFileName)) {
        $parentFolderName = $sourceFile.Directory.Name
        $newFileName = "$newPrefix${baseFileName}_$parentFolderName$newExtension"
    }

    try {
        # 1. BACKUP: Copy the exact file to the destination
        $copiedFile = Copy-Item -Path $sourceFile.FullName -Destination $destDir -PassThru -ErrorAction Stop
        
        # 2. RENAME: Rename the copy in the destination folder
        $renamedFile = Rename-Item -Path $copiedFile.FullName -NewName $newFileName -PassThru -ErrorAction Stop
        
        Write-Host "  OK: Copied and renamed to '$($renamedFile.Name)'"
        $renamedFiles += $renamedFile
    } catch {
        Write-Error "  FAILED: Error during copy or rename of '$($sourceFile.FullName)'"
        Write-Error "  $($_.Exception.Message)"
    }
}

# --- Step 3: (Optional) Concatenate the Files ---
if ($doConcatenate -and $renamedFiles.Count -gt 0) {
    Write-Host "`n--- Step 3: Concatenating Files ---" -ForegroundColor Green
    $concatenatedFilePath = Join-Path -Path $destDir -ChildPath $concatenatedFile
    if (Test-Path $concatenatedFilePath) { Remove-Item -Path $concatenatedFilePath -Force }
    Write-Host "Creating combined file '$concatenatedFile'..."
    Get-Content -Path $renamedFiles.FullName | Set-Content -Path $concatenatedFilePath
    Write-Host "All processed files have been concatenated into '$concatenatedFilePath'" -ForegroundColor Green
} elseif ($doConcatenate) {
    Write-Warning "`nConcatenation skipped: No files were successfully processed."
}

Write-Host "`n--- Process Complete! ---" -ForegroundColor Green
Read-Host "Press Enter to exit"


####\utilities\DO_NOT_USE\test-module-loading.ps1
# Test script to verify module loading works correctly
# This script mimics the loading sequence from _CLASSY-MAIN.ps1

# Import models module classes globally (must be at top of file)
using module .\modules\models.psm1

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

$BasePath = $PSScriptRoot

try {
    Write-Host "Testing module loading sequence..." -ForegroundColor Cyan
    
    # Step 1: Verify models were loaded
    Write-Host "1. Verifying models module loaded..." -ForegroundColor Yellow
    Write-Host "   ✓ Models module loaded via using statement" -ForegroundColor Green
    
    # Step 2: Test if classes are available
    Write-Host "2. Testing class availability..." -ForegroundColor Yellow
    $testTask = [PmcTask]::new("Test Task")
    $testProject = [PmcProject]::new("TEST", "Test Project")
    Write-Host "   ✓ Classes are available: PmcTask, PmcProject" -ForegroundColor Green
    
    # Step 3: Load core modules
    Write-Host "3. Loading core modules..." -ForegroundColor Yellow
    Import-Module "$BasePath\modules\exceptions.psm1" -Force
    Import-Module "$BasePath\modules\logger.psm1" -Force  
    Import-Module "$BasePath\modules\event-system.psm1" -Force
    Write-Host "   ✓ Core modules loaded" -ForegroundColor Green
    
    # Step 4: Load data-manager module
    Write-Host "4. Loading data-manager module..." -ForegroundColor Yellow
    Import-Module "$BasePath\modules\data-manager.psm1" -Force
    Write-Host "   ✓ Data-manager module loaded successfully!" -ForegroundColor Green
    
    # Step 5: Test DataManager class instantiation
    Write-Host "5. Testing DataManager class..." -ForegroundColor Yellow
    $dataManager = [DataManager]::new()
    Write-Host "   ✓ DataManager class instantiated successfully!" -ForegroundColor Green
    
    # Step 6: Load keybinding-service module (this was failing before)
    Write-Host "6. Loading keybinding-service module..." -ForegroundColor Yellow
    Import-Module "$BasePath\services\keybinding-service.psm1" -Force
    Write-Host "   ✓ Keybinding-service module loaded successfully!" -ForegroundColor Green
    
    # Step 7: Load navigation-service-class module
    Write-Host "7. Loading navigation-service-class module..." -ForegroundColor Yellow
    Import-Module "$BasePath\services\navigation-service-class.psm1" -Force
    Write-Host "   ✓ Navigation-service-class module loaded successfully!" -ForegroundColor Green
    
    # Step 8: Test service class instantiation
    Write-Host "8. Testing service class instantiation..." -ForegroundColor Yellow
    $keybindingService = [KeybindingService]::new()
    $testServices = @{ DataManager = $dataManager }
    $navigationService = [NavigationService]::new($testServices)
    Write-Host "   ✓ Service classes instantiated successfully!" -ForegroundColor Green
    
    Write-Host "`nAll tests passed! The module loading issues have been resolved." -ForegroundColor Green
    Write-Host "✓ Model classes load correctly" -ForegroundColor Green
    Write-Host "✓ Data-manager module loads without type errors" -ForegroundColor Green
    Write-Host "✓ Keybinding-service module loads without syntax errors" -ForegroundColor Green
    Write-Host "✓ Navigation-service-class module loads without syntax errors" -ForegroundColor Green
    Write-Host "✓ All classes can be instantiated successfully" -ForegroundColor Green
    
} catch {
    Write-Host "`nERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Gray
    exit 1
}



####\utilities\context-helpers.psm1
# Context capture helper for consistent handler creation
function New-ContextHandler {
    param(
        [hashtable]$CapturedContext,
        [scriptblock]$Handler
    )
    
    # Create a closure that captures the context
    $wrapper = {
        param($Event, $Args)
        $context = $CapturedContext
        & $Handler -Context $context -Event $Event -Args $Args
    }.GetNewClosure()
    
    # Store the captured context for debugging
    Add-Member -InputObject $wrapper -MemberType NoteProperty -Name "_CapturedContext" -Value $CapturedContext
    
    return $wrapper
}

# Screen context capture helper
function Get-ScreenContext {
    param([hashtable]$Screen)
    
    return @{
        Screen = $Screen
        Services = $Screen._services
        Store = $Screen._services.Store
        Navigation = $Screen._services.Navigation
        Components = $Screen.Components
    }
}

# Safe method invocation helper
function Invoke-SafeMethod {
    param(
        [hashtable]$Object,
        [string]$MethodName,
        [hashtable]$Parameters = @{}
    )
    
    if (-not $Object) {
        Write-Log -Level Warning -Message "Cannot invoke $MethodName on null object"
        return $null
    }
    
    if (-not $Object[$MethodName]) {
        Write-Log -Level Warning -Message "Method $MethodName not found on object"
        return $null
    }
    
    try {
        return & $Object[$MethodName] -self $Object @Parameters
    } catch {
        Write-Log -Level Error -Message "Error invoking $MethodName" -Data $_
        throw
    }
}

Export-ModuleMember -Function @(
    'New-ContextHandler',
    'Get-ScreenContext',
    'Invoke-SafeMethod'
)



####\utilities\error-handling-fix.psm1
# Fixed Error Handling Wrapper for PowerShell Classes
# Solves parameter binding issues with Context parameter

function global:Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Component,
        
        [Parameter(Mandatory = $true)]
        [string]$Context,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [hashtable]$AdditionalData = @{}
    )
    
    # Validate parameters
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown"
    }
    if ([string]::IsNullOrWhiteSpace($Context)) {
        $Context = "Unknown"
    }
    
    try {
        # Execute the script block
        & $ScriptBlock
    }
    catch {
        # Create enriched error data
        $errorData = @{
            Component = $Component
            Context = $Context
            Error = $_
            Exception = $_.Exception
            ScriptStackTrace = $_.ScriptStackTrace
            Timestamp = Get-Date
        }
        
        # Merge additional data
        foreach ($key in $AdditionalData.Keys) {
            $errorData[$key] = $AdditionalData[$key]
        }
        
        # Log the error if logging is available
        if (Get-Command -Name "Write-Log" -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "Error in '$Component' during '$Context': $($_.Exception.Message)" -Data $errorData
        }
        
        # Re-throw the original exception
        throw
    }
}

# Fixed version for use in classes
function global:Invoke-ClassMethod {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ClassName,
        
        [Parameter(Mandatory = $true)]
        [string]$MethodName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    
    # Ensure parameters are valid
    $component = if ([string]::IsNullOrWhiteSpace($ClassName)) { "UnknownClass" } else { $ClassName }
    $context = if ([string]::IsNullOrWhiteSpace($MethodName)) { "UnknownMethod" } else { $MethodName }
    
    try {
        & $ScriptBlock
    }
    catch {
        $errorInfo = @{
            ClassName = $component
            MethodName = $context
            ErrorMessage = $_.Exception.Message
            StackTrace = $_.ScriptStackTrace
            Timestamp = Get-Date
        }
        
        # Add any additional data
        foreach ($key in $Data.Keys) {
            if (-not $errorInfo.ContainsKey($key)) {
                $errorInfo[$key] = $Data[$key]
            }
        }
        
        if (Get-Command -Name "Write-Log" -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "[$component.$context] $($_.Exception.Message)" -Data $errorInfo
        }
        
        throw
    }
}

# Export the functions
Export-ModuleMember -Function @('Invoke-WithErrorHandling', 'Invoke-ClassMethod')


####\utilities\error-handling.psm1
# Fixed Error Handling Utilities Module for PMC Terminal v5
# Provides centralized error handling with consistent parameter patterns
# AI: Simplified and robust error handling to prevent parameter binding conflicts

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Initialize log file path
$script:LogFilePath = Join-Path -Path $env:TEMP -ChildPath "PMCTerminal_$(Get-Date -Format 'yyyy-MM-dd').log"
$script:MaxLogSizeMB = 10
$script:LogLevel = "Info"

# Log levels enumeration
enum LogLevel {
    Debug = 0
    Info = 1
    Warning = 2
    Error = 3
    Critical = 4
}

# AI: Simplified Invoke-WithErrorHandling with consistent parameter pattern
function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [string]$Component,
        
        [Parameter(Mandatory = $true, Position = 1)]
        [string]$Context,
        
        [Parameter(Mandatory = $true, Position = 2)]
        [scriptblock]$ScriptBlock,
        
        [Parameter(Mandatory = $false)]
        [hashtable]$AdditionalData = @{}
    )
    
    # Validate parameters
    if ([string]::IsNullOrWhiteSpace($Component)) {
        $Component = "Unknown"
    }
    if ([string]::IsNullOrWhiteSpace($Context)) {
        $Context = "Unknown"
    }
    
    $startTime = [DateTime]::Now
    
    try {
        Write-Log -Level Debug -Message "Starting operation" -Component $Component -Context $Context
        
        # Execute the script block
        $result = & $ScriptBlock
        
        Write-Log -Level Debug -Message "Operation completed successfully" -Component $Component -Context $Context
        return $result
    }
    catch {
        # Create enriched error data
        $errorData = @{
            Component = $Component
            Context = $Context
            Error = $_.Exception.Message
            Exception = $_.Exception
            ScriptStackTrace = $_.ScriptStackTrace
            Duration = ([DateTime]::Now - $startTime).TotalMilliseconds
            Timestamp = Get-Date
        }
        
        # Merge additional data
        foreach ($key in $AdditionalData.Keys) {
            $errorData[$key] = $AdditionalData[$key]
        }
        
        # Log the error
        Write-Log -Level Error -Message "Error in '$Component' during '$Context': $($_.Exception.Message)" -ErrorDetails $errorData
        
        # Publish error event for global handling
        if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
            Publish-Event -EventName "Application.Error" -Data $errorData
        }
        
        # Re-throw the original exception
        throw
    }
    finally {
        $duration = ([DateTime]::Now - $startTime).TotalMilliseconds
        Write-Log -Level Debug -Message "Operation duration: $duration ms" -Component $Component -Context $Context
    }
}

# AI: Simplified version for use in classes
function Invoke-ClassMethod {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ClassName,
        
        [Parameter(Mandatory = $true)]
        [string]$MethodName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    
    # Ensure parameters are valid
    $component = if ([string]::IsNullOrWhiteSpace($ClassName)) { "UnknownClass" } else { $ClassName }
    $context = if ([string]::IsNullOrWhiteSpace($MethodName)) { "UnknownMethod" } else { $MethodName }
    
    try {
        & $ScriptBlock
    }
    catch {
        $errorInfo = @{
            ClassName = $component
            MethodName = $context
            ErrorMessage = $_.Exception.Message
            StackTrace = $_.ScriptStackTrace
            Timestamp = Get-Date
        }
        
        # Add any additional data
        foreach ($key in $Data.Keys) {
            if (-not $errorInfo.ContainsKey($key)) {
                $errorInfo[$key] = $Data[$key]
            }
        }
        
        Write-Log -Level Error -Message "[$component.$context] $($_.Exception.Message)" -ErrorDetails $errorInfo
        throw
    }
}

# Write-Log - Centralized logging function
function Write-Log {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Debug", "Info", "Warning", "Error", "Critical")]
        [string]$Level,
        
        [Parameter(Mandatory = $true)]
        [string]$Message,
        
        [Parameter(Mandatory = $false)]
        [string]$Component = "Unknown",
        
        [Parameter(Mandatory = $false)]
        [string]$Context = "",
        
        [Parameter(Mandatory = $false)]
        [hashtable]$ErrorDetails = @{}
    )
    
    # Check if we should log based on current log level
    $currentLevel = [LogLevel]::$script:LogLevel
    $messageLevel = [LogLevel]::$Level
    
    if ($messageLevel -lt $currentLevel) {
        return
    }
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
    $threadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
    
    # Format log entry
    $logEntry = "$timestamp [$Level] [$Component"
    if (-not [string]::IsNullOrWhiteSpace($Context)) {
        $logEntry += "::$Context"
    }
    $logEntry += "] [Thread:$threadId] $Message"
    
    # Add error details if provided
    if ($ErrorDetails.Count -gt 0) {
        try {
            # AI: Safely serialize error details to avoid issues with non-string keys or complex objects
            $serializedDetails = $ErrorDetails | ConvertTo-Json -Compress -Depth 2 -ErrorAction Stop
            $logEntry += " | Details: " + $serializedDetails
        }
        catch {
            # AI: If serialization fails, create a simple string representation
            $simpleDetails = @()
            foreach ($key in $ErrorDetails.Keys) {
                $value = $ErrorDetails[$key]
                if ($null -eq $value) {
                    $simpleDetails += "$key=null"
                }
                elseif ($value -is [string] -or $value -is [int] -or $value -is [bool] -or $value -is [datetime]) {
                    $simpleDetails += "$key=$value"
                }
                else {
                    # AI: Fixed string interpolation issue
                    $typeName = try { $value.GetType().Name } catch { "Unknown" }
                    $simpleDetails += "$key=[$typeName]"
                }
            }
            $logEntry += " | Details: {" + ($simpleDetails -join "; ") + "}"
        }
    }
    
    # Write to console with color coding
    $consoleColor = switch ($Level) {
        "Debug" { "DarkGray" }
        "Info" { "White" }
        "Warning" { "Yellow" }
        "Error" { "Red" }
        "Critical" { "Magenta" }
    }
    
    if ($Level -in @("Error", "Critical")) {
        Write-Host $logEntry -ForegroundColor $consoleColor -ErrorAction SilentlyContinue
    }
    elseif ($Level -eq "Warning") {
        Write-Warning $logEntry -ErrorAction SilentlyContinue
    }
    else {
        Write-Verbose $logEntry -ErrorAction SilentlyContinue
    }
    
    # Write to log file
    try {
        # Check log file size and rotate if needed
        if (Test-Path $script:LogFilePath) {
            $logFile = Get-Item $script:LogFilePath
            if ($logFile.Length -gt ($script:MaxLogSizeMB * 1MB)) {
                $archivePath = $script:LogFilePath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                Move-Item -Path $script:LogFilePath -Destination $archivePath -Force
            }
        }
        
        # Append to log file
        Add-Content -Path $script:LogFilePath -Value $logEntry -ErrorAction SilentlyContinue
    }
    catch {
        # Silently fail if unable to write to log file
    }
}

# Set-LogLevel - Configure the minimum log level
function Set-LogLevel {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Debug", "Info", "Warning", "Error", "Critical")]
        [string]$Level
    )
    
    $script:LogLevel = $Level
    Write-Log -Level Info -Message "Log level set to: $Level" -Component "Logging"
}

# Get-LogLevel - Get the current log level
function Get-LogLevel {
    return $script:LogLevel
}

# Export all functions
Export-ModuleMember -Function @(
    'Invoke-WithErrorHandling',
    'Invoke-ClassMethod',
    'Write-Log',
    'Set-LogLevel',
    'Get-LogLevel'
)



####\utilities\event-system.psm1
# Event System Module for PMC Terminal v5
# Provides a centralized event publishing and subscription system
# AI: Implements the event-driven architecture for loose coupling between components

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Import error handling utilities
Import-Module -Name "$PSScriptRoot\error-handling.psm1" -Force

# Script-level variables for event management
$script:EventSubscriptions = @{}
$script:EventHistory = [System.Collections.Generic.List[PSCustomObject]]::new()
$script:MaxEventHistorySize = 1000
$script:EventQueueEnabled = $false
$script:EventQueue = [System.Collections.Generic.Queue[PSCustomObject]]::new()

# Publish-Event - Broadcast an event to all subscribers
function Publish-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $false)]
        [object]$Data = $null,
        
        [Parameter(Mandatory = $false)]
        [hashtable]$Metadata = @{}
    )
    
    Invoke-WithErrorHandling -Component "EventSystem" -Context "PublishEvent:$EventName" -ScriptBlock {
        $eventInfo = [PSCustomObject]@{
            EventName = $EventName
            Data = $Data
            Metadata = $Metadata
            Timestamp = [DateTime]::Now
            PublisherId = [System.Diagnostics.Process]::GetCurrentProcess().Id
            ThreadId = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        }
        
        Write-Log -Level Debug -Message "Publishing event: $EventName" -Component "EventSystem"
        
        # Add to event history
        $script:EventHistory.Add($eventInfo)
        
        # Trim history if needed
        if ($script:EventHistory.Count -gt $script:MaxEventHistorySize) {
            $script:EventHistory.RemoveAt(0)
        }
        
        # Queue event if queuing is enabled
        if ($script:EventQueueEnabled) {
            $script:EventQueue.Enqueue($eventInfo)
            Write-Log -Level Debug -Message "Event queued: $EventName (Queue size: $($script:EventQueue.Count))" -Component "EventSystem"
            return
        }
        
        # Trigger PowerShell engine event
        New-Event -SourceIdentifier $EventName -MessageData $Data
        
        # Call direct subscribers if any
        if ($script:EventSubscriptions.ContainsKey($EventName)) {
            $subscribers = @($script:EventSubscriptions[$EventName])
            Write-Log -Level Debug -Message "Found $($subscribers.Count) subscribers for event: $EventName" -Component "EventSystem"
            
            foreach ($subscriber in $subscribers) {
                try {
                    Write-Log -Level Debug -Message "Invoking subscriber: $($subscriber.Id)" -Component "EventSystem"
                    
                    # Create event args
                    $eventArgs = [PSCustomObject]@{
                        EventName = $EventName
                        Data = $Data
                        Metadata = $Metadata
                        Timestamp = $eventInfo.Timestamp
                    }
                    
                    # Invoke subscriber
                    & $subscriber.Action $eventArgs
                }
                catch {
                    Write-Log -Level Error -Message "Subscriber failed for event '$EventName': $_" -Component "EventSystem"
                    
                    # Optionally remove failed subscriber if configured
                    if ($subscriber.RemoveOnError) {
                        Unsubscribe-Event -EventName $EventName -SubscriberId $subscriber.Id
                    }
                }
            }
        }
    }
}

# Subscribe-Event - Register a handler for an event
function Subscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$Action,
        
        [Parameter(Mandatory = $false)]
        [string]$SubscriberId = [Guid]::NewGuid().ToString(),
        
        [Parameter(Mandatory = $false)]
        [bool]$RemoveOnError = $false,
        
        [Parameter(Mandatory = $false)]
        [int]$Priority = 0
    )
    
    Invoke-WithErrorHandling -Component "EventSystem" -Context "SubscribeEvent:$EventName" -ScriptBlock {
        Write-Log -Level Debug -Message "Subscribing to event: $EventName (ID: $SubscriberId)" -Component "EventSystem"
        
        # Initialize subscription list if needed
        if (-not $script:EventSubscriptions.ContainsKey($EventName)) {
            $script:EventSubscriptions[$EventName] = @()
        }
        
        # Check if subscriber already exists
        $existingSubscriber = $script:EventSubscriptions[$EventName] | 
            Where-Object { $_.Id -eq $SubscriberId } | 
            Select-Object -First 1
            
        if ($null -ne $existingSubscriber) {
            Write-Log -Level Warning -Message "Subscriber '$SubscriberId' already exists for event '$EventName'. Updating." -Component "EventSystem"
            Unsubscribe-Event -EventName $EventName -SubscriberId $SubscriberId
        }
        
        # Create subscriber object
        $subscriber = [PSCustomObject]@{
            Id = $SubscriberId
            Action = $Action
            Priority = $Priority
            RemoveOnError = $RemoveOnError
            SubscribedAt = [DateTime]::Now
            EventName = $EventName
        }
        
        # Add subscriber to list (sorted by priority)
        $script:EventSubscriptions[$EventName] = @($script:EventSubscriptions[$EventName] + $subscriber) | 
            Sort-Object -Property Priority -Descending
        
        Write-Log -Level Info -Message "Successfully subscribed to event: $EventName" -Component "EventSystem"
        
        return $SubscriberId
    }
}

# Unsubscribe-Event - Remove an event handler
function Unsubscribe-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [string]$SubscriberId
    )
    
    Invoke-WithErrorHandling -Component "EventSystem" -Context "UnsubscribeEvent:$EventName" -ScriptBlock {
        Write-Log -Level Debug -Message "Unsubscribing from event: $EventName (ID: $SubscriberId)" -Component "EventSystem"
        
        if (-not $script:EventSubscriptions.ContainsKey($EventName)) {
            Write-Log -Level Warning -Message "No subscriptions found for event: $EventName" -Component "EventSystem"
            return
        }
        
        $initialCount = $script:EventSubscriptions[$EventName].Count
        $script:EventSubscriptions[$EventName] = @($script:EventSubscriptions[$EventName] | 
            Where-Object { $_.Id -ne $SubscriberId })
        
        $removed = $initialCount - $script:EventSubscriptions[$EventName].Count
        
        if ($removed -gt 0) {
            Write-Log -Level Info -Message "Successfully unsubscribed from event: $EventName" -Component "EventSystem"
            
            # Clean up empty subscription lists
            if ($script:EventSubscriptions[$EventName].Count -eq 0) {
                $script:EventSubscriptions.Remove($EventName)
            }
        }
        else {
            Write-Log -Level Warning -Message "Subscriber '$SubscriberId' not found for event '$EventName'" -Component "EventSystem"
        }
    }
}

# Clear-EventSubscriptions - Remove all subscriptions for an event or all events
function Clear-EventSubscriptions {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$EventName = $null
    )
    
    if ([string]::IsNullOrWhiteSpace($EventName)) {
        Write-Log -Level Info -Message "Clearing all event subscriptions" -Component "EventSystem"
        $script:EventSubscriptions.Clear()
    }
    else {
        Write-Log -Level Info -Message "Clearing subscriptions for event: $EventName" -Component "EventSystem"
        if ($script:EventSubscriptions.ContainsKey($EventName)) {
            $script:EventSubscriptions.Remove($EventName)
        }
    }
}

# Get-EventSubscriptions - Get current subscriptions
function Get-EventSubscriptions {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$EventName = $null
    )
    
    if ([string]::IsNullOrWhiteSpace($EventName)) {
        return $script:EventSubscriptions
    }
    else {
        if ($script:EventSubscriptions.ContainsKey($EventName)) {
            return $script:EventSubscriptions[$EventName]
        }
        return @()
    }
}

# Get-EventHistory - Retrieve event history
function Get-EventHistory {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$EventName = $null,
        
        [Parameter(Mandatory = $false)]
        [int]$Last = 0,
        
        [Parameter(Mandatory = $false)]
        [DateTime]$Since = [DateTime]::MinValue
    )
    
    $history = $script:EventHistory
    
    # Filter by event name
    if (-not [string]::IsNullOrWhiteSpace($EventName)) {
        $history = $history | Where-Object { $_.EventName -eq $EventName }
    }
    
    # Filter by time
    if ($Since -ne [DateTime]::MinValue) {
        $history = $history | Where-Object { $_.Timestamp -ge $Since }
    }
    
    # Get last N events
    if ($Last -gt 0) {
        $history = $history | Select-Object -Last $Last
    }
    
    return $history
}

# Clear-EventHistory - Clear the event history
function Clear-EventHistory {
    [CmdletBinding()]
    param()
    
    Write-Log -Level Info -Message "Clearing event history" -Component "EventSystem"
    $script:EventHistory.Clear()
}

# Enable-EventQueue - Enable event queuing
function Enable-EventQueue {
    [CmdletBinding()]
    param()
    
    $script:EventQueueEnabled = $true
    Write-Log -Level Info -Message "Event queuing enabled" -Component "EventSystem"
}

# Disable-EventQueue - Disable event queuing and process queued events
function Disable-EventQueue {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [bool]$ProcessQueue = $true
    )
    
    $script:EventQueueEnabled = $false
    Write-Log -Level Info -Message "Event queuing disabled" -Component "EventSystem"
    
    if ($ProcessQueue) {
        Process-EventQueue
    }
    else {
        $script:EventQueue.Clear()
    }
}

# Process-EventQueue - Process all queued events
function Process-EventQueue {
    [CmdletBinding()]
    param()
    
    $queueSize = $script:EventQueue.Count
    Write-Log -Level Info -Message "Processing event queue (Size: $queueSize)" -Component "EventSystem"
    
    $processed = 0
    while ($script:EventQueue.Count -gt 0) {
        $eventInfo = $script:EventQueue.Dequeue()
        
        # Re-publish the event
        Publish-Event -EventName $eventInfo.EventName -Data $eventInfo.Data -Metadata $eventInfo.Metadata
        $processed++
    }
    
    Write-Log -Level Info -Message "Processed $processed queued events" -Component "EventSystem"
}

# Wait-Event - Wait for a specific event to occur
function Wait-Event {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $false)]
        [int]$TimeoutSeconds = 30,
        
        [Parameter(Mandatory = $false)]
        [scriptblock]$Condition = $null
    )
    
    $receivedEvent = $null
    $waitHandle = [System.Threading.ManualResetEvent]::new($false)
    
    # Subscribe to the event
    $subscriberId = Subscribe-Event -EventName $EventName -Action {
        param($eventArgs)
        
        # Check condition if provided
        if ($null -eq $Condition -or (& $Condition $eventArgs)) {
            $script:receivedEvent = $eventArgs
            [void]$waitHandle.Set()
        }
    }
    
    try {
        # Wait for event or timeout
        $signaled = $waitHandle.WaitOne([TimeSpan]::FromSeconds($TimeoutSeconds))
        
        if ($signaled) {
            return $script:receivedEvent
        }
        else {
            Write-Log -Level Warning -Message "Timeout waiting for event: $EventName" -Component "EventSystem"
            return $null
        }
    }
    finally {
        # Clean up
        Unsubscribe-Event -EventName $EventName -SubscriberId $subscriberId
        $waitHandle.Dispose()
    }
}

# Initialize-EventSystem - Set up the event system
function Initialize-EventSystem {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [int]$MaxHistorySize = 1000
    )
    
    $script:MaxEventHistorySize = $MaxHistorySize
    
    Write-Log -Level Info -Message "Event system initialized (Max history: $MaxHistorySize)" -Component "EventSystem"
}

# Export all functions
Export-ModuleMember -Function @(
    'Publish-Event',
    'Subscribe-Event',
    'Unsubscribe-Event',
    'Clear-EventSubscriptions',
    'Get-EventSubscriptions',
    'Get-EventHistory',
    'Clear-EventHistory',
    'Enable-EventQueue',
    'Disable-EventQueue',
    'Process-EventQueue',
    'Wait-Event',
    'Initialize-EventSystem'
)


####\utilities\focus-manager.psm1
# FILE: utilities/focus-manager.psm1
# PURPOSE: Provides the single source of truth for component focus management with scope support.

$script:Focus = @{
    FocusedComponent = $null 
    TabOrder = @()
    ActiveScope = $null
    History = @()  # Focus history for debugging
    ScopeStack = @()  # For nested focus scopes
}

function global:Request-Focus {
    param(
        [hashtable]$Component,
        [bool]$UpdateTabOrder = $false,
        [string]$Reason = "Direct"
    )
    Invoke-WithErrorHandling -Component "FocusManager.RequestFocus" -Context "Requesting focus for component" -AdditionalData @{ ComponentName = $Component.Name; Reason = $Reason } -ScriptBlock {
        # Validate component
        if ($Component -and -not $Component.IsFocusable) {
            Write-Log -Level Debug -Message "Cannot focus non-focusable component: $($Component.Name ?? $Component.Type)"
            return $false
        }
        
        if ($Component -and -not $Component.Visible) {
            Write-Log -Level Debug -Message "Cannot focus invisible component: $($Component.Name ?? $Component.Type)"
            return $false
        }
        
        # Handle losing focus on previous component
        $oldFocused = $script:Focus.FocusedComponent
        if ($oldFocused -and ($oldFocused -ne $Component)) {
            $oldFocused.IsFocused = $false
            
            if ($oldFocused.OnBlur) {
                try {
                    & $oldFocused.OnBlur -self $oldFocused
                } catch {
                    Write-Log -Level Error -Message "Error in OnBlur handler for '$($oldFocused.Name ?? $oldFocused.Type)': $_" -Data @{ Component = $oldFocused.Name; Exception = $_ }
                }
            }
            
            # Fire blur event
            if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Component.Blur" -Data @{ Component = $oldFocused }
            }
        }
        
        # Update focus scope if needed
        $newScope = if ($Component) { Get-FocusScope -Component $Component } else { $null }
        if ($newScope -ne $script:Focus.ActiveScope) {
            # Leave old scope
            if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.OnLeaveFocusScope) {
                try {
                    & $script:Focus.ActiveScope.OnLeaveFocusScope -self $script:Focus.ActiveScope
                } catch {
                    Write-Log -Level Error -Message "Error in OnLeaveFocusScope handler for '$($script:Focus.ActiveScope.Name ?? $script:Focus.ActiveScope.Type)': $_" -Data @{ Component = $script:Focus.ActiveScope.Name; Exception = $_ }
                }
            }
            
            $script:Focus.ActiveScope = $newScope
            
            # Enter new scope
            if ($newScope -and $newScope.OnEnterFocusScope) {
                try {
                    & $newScope.OnEnterFocusScope -self $newScope
                } catch {
                    Write-Log -Level Error -Message "Error in OnEnterFocusScope handler for '$($newScope.Name ?? $newScope.Type)': $_" -Data @{ Component = $newScope.Name; Exception = $_ }
                }
            }
        }
        
        # Set new focus
        $script:Focus.FocusedComponent = $Component
        
        # Update global state if available
        if ($global:TuiState) {
            $global:TuiState.FocusedComponent = $Component
        }
        
        # Update history
        $script:Focus.History += @{
            Component = $Component
            Timestamp = [DateTime]::UtcNow
            Reason = $Reason
        }
        if ($script:Focus.History.Count -gt 50) {
            $script:Focus.History = $script:Focus.History[-50..-1]
        }
        
        if ($Component) {
            $Component.IsFocused = $true
            
            # Call focus handler
            if ($Component.OnFocus) {
                try {
                    & $Component.OnFocus -self $Component
                } catch {
                    Write-Log -Level Error -Message "Error in OnFocus handler for '$($Component.Name ?? $Component.Type)': $_" -Data @{ Component = $Component.Name; Exception = $_ }
                }
            }
            
            # Fire focus event
            if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
                Publish-Event -EventName "Component.Focus" -Data @{ Component = $Component }
            }
            
            # Update tab order if requested
            if ($UpdateTabOrder) {
                Update-TabOrder -FocusedComponent $Component
            }
        }
        
        # Request screen refresh
        if (Get-Command -Name "Request-TuiRefresh" -ErrorAction SilentlyContinue) {
            Request-TuiRefresh
        }
        
        if ($Component) {
            Write-Log -Level Debug -Message "Focused: $($Component.Name ?? $Component.Type) (Reason: $Reason)"
        } else {
            Write-Log -Level Debug -Message "Cleared focus (Reason: $Reason)"
        }
        
        return $true
    }
}

function global:Clear-Focus {
    Invoke-WithErrorHandling -Component "FocusManager.ClearFocus" -Context "Clearing focus" -ScriptBlock {
        Request-Focus -Component $null -Reason "Clear"
    }
}

function global:Move-Focus {
    param(
        [bool]$Reverse = $false,
        [bool]$Wrap = $true
    )
    Invoke-WithErrorHandling -Component "FocusManager.MoveFocus" -Context "Moving focus" -AdditionalData @{ Reverse = $Reverse; Wrap = $Wrap; CurrentFocused = $script:Focus.FocusedComponent.Name } -ScriptBlock {
        # Check if active scope handles its own focus movement
        if ($script:Focus.ActiveScope -and $script:Focus.ActiveScope.HandleScopedFocus) {
            try {
                $handled = & $script:Focus.ActiveScope.HandleScopedFocus -self $script:Focus.ActiveScope -Reverse $Reverse
                if ($handled) {
                    return $true
                }
            } catch {
                Write-Log -Level Error -Message "Active focus scope HandleScopedFocus failed for '$($script:Focus.ActiveScope.Name ?? $script:Focus.ActiveScope.Type)': $_" -Data @{ Scope = $script:Focus.ActiveScope.Name; Reverse = $Reverse; Exception = $_ }
            }
        }
        
        # No focusable components
        if ($script:Focus.TabOrder.Count -eq 0) {
            Write-Log -Level Debug -Message "No focusable components in tab order"
            return $false
        }
        
        # Find current index
        $currentIndex = [array]::IndexOf($script:Focus.TabOrder, $script:Focus.FocusedComponent)
        
        # If no current focus, focus first/last based on direction
        if ($currentIndex -eq -1) {
            $targetIndex = if ($Reverse) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            Request-Focus -Component $script:Focus.TabOrder[$targetIndex] -Reason "TabNavigation"
            return $true
        }
        
        # Calculate next index
        if ($Reverse) {
            $nextIndex = $currentIndex - 1
            if ($nextIndex -lt 0) {
                $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
            }
        } else {
            $nextIndex = $currentIndex + 1
            if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
            }
        }
        
        # Skip invisible or disabled components
        $attempts = 0
        while ($attempts -lt $script:Focus.TabOrder.Count) {
            $candidate = $script:Focus.TabOrder[$nextIndex]
            
            if ($candidate.Visible -and $candidate.IsFocusable -and 
                (-not $candidate.PSObject.Properties['IsEnabled'] -or $candidate.IsEnabled)) {
                Request-Focus -Component $candidate -Reason "TabNavigation"
                return $true
            }
            
            # Move to next candidate
            if ($Reverse) {
                $nextIndex--
                if ($nextIndex -lt 0) {
                    $nextIndex = if ($Wrap) { $script:Focus.TabOrder.Count - 1 } else { 0 }
                }
            } else {
                $nextIndex++
                if ($nextIndex -ge $script:Focus.TabOrder.Count) {
                    $nextIndex = if ($Wrap) { 0 } else { $script:Focus.TabOrder.Count - 1 }
                }
            }
            
            $attempts++
        }
        
        Write-Log -Level Debug -Message "No valid focus target found"
        return $false
    }
}

function global:Get-FocusedComponent {
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusedComponent" -Context "Getting focused component" -ScriptBlock {
        return $script:Focus.FocusedComponent
    }
}

function global:Get-FocusHistory {
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusHistory" -Context "Getting focus history" -ScriptBlock {
        return $script:Focus.History
    }
}

# --- FIX: REMOVED 'private:' ---
function Get-FocusScope {
    param($Component)
    Invoke-WithErrorHandling -Component "FocusManager.GetFocusScope" -Context "Getting focus scope" -AdditionalData @{ ComponentName = $Component.Name } -ScriptBlock {
        $current = $Component
        while ($current) {
            if ($current.IsFocusScope) {
                return $current
            }
            $current = $current.Parent
        }
        
        return $null
    }
}

function global:Push-FocusScope {
    param([hashtable]$Scope)
    Invoke-WithErrorHandling -Component "FocusManager.PushFocusScope" -Context "Pushing focus scope" -AdditionalData @{ ScopeName = $Scope.Name } -ScriptBlock {
        if (-not $Scope.IsFocusScope) {
            $Scope.IsFocusScope = $true
        }
        
        $script:Focus.ScopeStack += $Scope
        $script:Focus.ActiveScope = $Scope
        
        Write-Log -Level Debug -Message "Pushed focus scope: $($Scope.Name ?? $Scope.Type)"
    }
}

function global:Pop-FocusScope {
    Invoke-WithErrorHandling -Component "FocusManager.PopFocusScope" -Context "Popping focus scope" -ScriptBlock {
        if ($script:Focus.ScopeStack.Count -eq 0) {
            return $null
        }
        
        $poppedScope = $script:Focus.ScopeStack[-1]
        $script:Focus.ScopeStack = $script:Focus.ScopeStack[0..($script:Focus.ScopeStack.Count - 2)]
        
        # Restore previous scope
        if ($script:Focus.ScopeStack.Count -gt 0) {
            $script:Focus.ActiveScope = $script:Focus.ScopeStack[-1]
        } else {
            $script:Focus.ActiveScope = $null
        }
        
        Write-Log -Level Debug -Message "Popped focus scope: $($poppedScope.Name ?? $poppedScope.Type)"
        
        return $poppedScope
    }
}

# --- FIX: REMOVED 'private:' ---
function Update-TabOrder {
    param($FocusedComponent)
    Invoke-WithErrorHandling -Component "FocusManager.UpdateTabOrder" -Context "Updating tab order" -AdditionalData @{ FocusedComponentName = $FocusedComponent.Name } -ScriptBlock {
        # If component is already in tab order, no need to update
        if ($FocusedComponent -in $script:Focus.TabOrder) {
            return
        }
        
        # Rebuild tab order
        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
    }
}

# --- FIX: REMOVED 'private:' ---
function Register-ScreenForFocus {
    param($Screen)
    Invoke-WithErrorHandling -Component "FocusManager.RegisterScreenForFocus" -Context "Registering screen for focus" -AdditionalData @{ ScreenName = $Screen.Name } -ScriptBlock {
        $script:Focus.TabOrder = @()
        $script:Focus.ActiveScope = $null
        
        if (-not $Screen) {
            Request-Focus -Component $null -Reason "NoScreen"
            return
        }
        
        # Find all focusable components
        $focusableComponents = @()
        
        $FindFocusable = $null
        $FindFocusable = {
            param($component, $depth = 0)
            
            if (-not $component) { return }
            
            # Add focusable components
            if ($component.IsFocusable -and $component.Visible) {
                $focusableComponents += @{
                    Component = $component
                    Depth = $depth
                    TabIndex = $component.TabIndex ?? 0
                    Position = @{
                        Y = $component.Y ?? 0
                        X = $component.X ?? 0
                    }
                }
            }
            
            # Process panel children
            if ($component.Children) {
                foreach ($child in $component.Children) {
                    & $FindFocusable -component $child -depth ($depth + 1)
                }
            }
            
            # Process named children (for backward compatibility)
            if ($component.Components) {
                foreach ($child in $component.Components.Values) {
                    & $FindFocusable -component $child -depth ($depth + 1)
                }
            }
        }.GetNewClosure()
        
        # Start from screen components and children
        if ($Screen.Children) {
            foreach ($comp in $Screen.Children) {
                & $FindFocusable -component $comp
            }
        }
        
        # Also check legacy Components collection
        if ($Screen.Components) {
            foreach ($comp in $Screen.Components.Values) {
                & $FindFocusable -component $comp
            }
        }
        
        # Sort by TabIndex, then by position (top to bottom, left to right)
        $script:Focus.TabOrder = $focusableComponents | 
            Sort-Object { $_.TabIndex }, { $_.Position.Y }, { $_.Position.X } |
            ForEach-Object { $_.Component }
        
        Write-Log -Level Debug -Message "Registered $($script:Focus.TabOrder.Count) focusable components"
        
        # Focus first component if none focused
        if ($script:Focus.TabOrder.Count -gt 0 -and -not ($script:Focus.FocusedComponent -in $script:Focus.TabOrder)) {
            Request-Focus -Component $script:Focus.TabOrder[0] -Reason "InitialFocus"
        } elseif ($script:Focus.TabOrder.Count -eq 0) {
            Request-Focus -Component $null -Reason "NoFocusableComponents"
        }
    }
}

function global:Initialize-FocusManager {
    Invoke-WithErrorHandling -Component "FocusManager.Initialize" -Context "Initializing focus manager" -ScriptBlock {
        # Subscribe to screen events
        if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
            Subscribe-Event -EventName "Screen.Pushed" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ScreenPushedHandler" -Context "Handling screen pushed event" -AdditionalData @{ EventData = $Event.Data } -ScriptBlock {
                    Register-ScreenForFocus -Screen $Event.Data.Screen
                }
            }
            
            Subscribe-Event -EventName "Screen.Popped" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ScreenPoppedHandler" -Context "Handling screen popped event" -AdditionalData @{ EventData = $Event.Data } -ScriptBlock {
                    # Clear focus scopes
                    $script:Focus.ScopeStack = @()
                    $script:Focus.ActiveScope = $null
                    
                    # Re-register for new top screen
                    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
                    }
                }
            }
            
            Subscribe-Event -EventName "Component.VisibilityChanged" -Handler {
                param($Event)
                Invoke-WithErrorHandling -Component "FocusManager.ComponentVisibilityChangedHandler" -Context "Handling component visibility changed event" -AdditionalData @{ EventData = $Event.Data } -ScriptBlock {
                    $component = $Event.Data.Component
                    
                    # If hiding focused component, move focus
                    if (-not $component.Visible -and $component -eq $script:Focus.FocusedComponent) {
                        Move-Focus
                    }
                    
                    # Update tab order if visibility changed
                    if ($global:TuiState -and $global:TuiState.CurrentScreen) {
                        Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
                    }
                }
            }
        }
        
        Write-Log -Level Info -Message "Focus Manager initialized"
    }
}

# Utility functions for components
function global:Set-ComponentFocusable {
    param(
        [hashtable]$Component,
        [bool]$IsFocusable
    )
    Invoke-WithErrorHandling -Component "FocusManager.SetComponentFocusable" -Context "Setting component focusable" -AdditionalData @{ ComponentName = $Component.Name; IsFocusable = $IsFocusable } -ScriptBlock {
        $wasFocusable = $Component.IsFocusable
        $Component.IsFocusable = $IsFocusable
        
        # If making unfocusable and it's currently focused, clear focus
        if ($wasFocusable -and -not $IsFocusable -and $Component -eq $script:Focus.FocusedComponent) {
            Move-Focus
        }
        
        # Update tab order
        if ($global:TuiState -and $global:TuiState.CurrentScreen) {
            Register-ScreenForFocus -Screen $global:TuiState.CurrentScreen
        }
    }
}

function global:Focus-NextInScope {
    param([hashtable]$Scope)
    Invoke-WithErrorHandling -Component "FocusManager.FocusNextInScope" -Context "Focusing next in scope" -AdditionalData @{ ScopeName = $Scope.Name } -ScriptBlock {
        if (-not $Scope -or -not $Scope.IsFocusScope) {
            return $false
        }
        
        # Find focusable children within scope
        $scopeFocusable = @()
        
        $FindScopeFocusable = {
            param($component)
            
            if ($component.IsFocusable -and $component.Visible) {
                $scopeFocusable += $component
            }
            
            if ($component.Children -and $component -ne $Scope) {
                foreach ($child in $component.Children) {
                    & $FindScopeFocusable -component $child
                }
            }
        }
        
        & $FindScopeFocusable -component $Scope
        
        if ($scopeFocusable.Count -eq 0) {
            return $false
        }
        
        # Find current index
        $currentIndex = [array]::IndexOf($scopeFocusable, $script:Focus.FocusedComponent)
        $nextIndex = ($currentIndex + 1) % $scopeFocusable.Count
        
        Request-Focus -Component $scopeFocusable[$nextIndex] -Reason "ScopeNavigation"
        return $true
    }
}

Export-ModuleMember -Function @(
    "Initialize-FocusManager",
    "Request-Focus", 
    "Clear-Focus",
    "Move-Focus",
    "Get-FocusedComponent",
    "Get-FocusHistory",
    "Push-FocusScope",
    "Pop-FocusScope",
    "Set-ComponentFocusable",
    "Focus-NextInScope"
)


####\utilities\layout-manager.psm1
# Layout Manager Utility Module
# Provides helper functions for component positioning and layout management

function global:New-TuiLayoutManager {
    <#
    .SYNOPSIS
    Creates a layout manager for organizing components within a container
    
    .DESCRIPTION
    The layout manager helps with automatic positioning, spacing, and alignment of components.
    It provides various layout modes: Stack, Grid, Dock, and Manual.
    
    .PARAMETER Container
    A hashtable with X, Y, Width, Height properties defining the container bounds
    
    .PARAMETER Mode
    Layout mode: 'Stack', 'Grid', 'Dock', or 'Manual'
    
    .EXAMPLE
    $layout = New-TuiLayoutManager -Container @{X=0; Y=0; Width=80; Height=25} -Mode 'Stack'
    $layout.Add($component1)
    $layout.Add($component2)
    $layout.Apply()
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [string]$Mode = 'Manual',
        [hashtable]$Options = @{}
    )
    
    $manager = @{
        Container = $Container
        Mode = $Mode
        Components = @()
        Options = @{
            # Stack options
            Direction = $Options.Direction ?? 'Vertical'  # 'Vertical' or 'Horizontal'
            Spacing = $Options.Spacing ?? 1
            Padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
            Alignment = $Options.Alignment ?? 'Left'  # 'Left', 'Center', 'Right'
            
            # Grid options
            Columns = $Options.Columns ?? 2
            RowHeight = $Options.RowHeight ?? 5
            ColumnWidth = $Options.ColumnWidth ?? 20
            
            # Dock options
            FillLast = $Options.FillLast ?? $true
        }
        
        # Methods
        Add = {
            param($Component, [hashtable]$LayoutProps = @{})
            $this = $args[-1]
            $this.Components += @{
                Component = $Component
                LayoutProps = $LayoutProps
            }
        }.GetNewClosure()
        
        Clear = {
            $this = $args[-1]
            $this.Components = @()
        }.GetNewClosure()
        
        Apply = {
            $this = $args[-1]
            switch ($this.Mode) {
                'Stack' { & $this.ApplyStackLayout }
                'Grid' { & $this.ApplyGridLayout }
                'Dock' { & $this.ApplyDockLayout }
                'Manual' { # Do nothing - components use their existing positions }
            }
        }.GetNewClosure()
        
        ApplyStackLayout = {
            $this = $args[-1]
            $x = $this.Container.X + $this.Options.Padding.Left
            $y = $this.Container.Y + $this.Options.Padding.Top
            $maxWidth = $this.Container.Width - $this.Options.Padding.Left - $this.Options.Padding.Right
            $maxHeight = $this.Container.Height - $this.Options.Padding.Top - $this.Options.Padding.Bottom
            
            foreach ($item in $this.Components) {
                $comp = $item.Component
                
                # Apply alignment
                switch ($this.Options.Alignment) {
                    'Center' { $comp.X = $x + [Math]::Floor(($maxWidth - $comp.Width) / 2) }
                    'Right' { $comp.X = $x + $maxWidth - $comp.Width }
                    default { $comp.X = $x }
                }
                
                if ($this.Options.Direction -eq 'Vertical') {
                    $comp.Y = $y
                    $y += $comp.Height + $this.Options.Spacing
                } else {
                    $comp.Y = $y
                    $x += $comp.Width + $this.Options.Spacing
                }
            }
        }.GetNewClosure()
        
        ApplyGridLayout = {
            $this = $args[-1]
            $startX = $this.Container.X + $this.Options.Padding.Left
            $startY = $this.Container.Y + $this.Options.Padding.Top
            $cols = $this.Options.Columns
            
            for ($i = 0; $i -lt $this.Components.Count; $i++) {
                $comp = $this.Components[$i].Component
                $row = [Math]::Floor($i / $cols)
                $col = $i % $cols
                
                $comp.X = $startX + ($col * ($this.Options.ColumnWidth + $this.Options.Spacing))
                $comp.Y = $startY + ($row * ($this.Options.RowHeight + $this.Options.Spacing))
                
                # Optionally constrain size to grid cell
                if ($this.Components[$i].LayoutProps.ConstrainToCell) {
                    $comp.Width = [Math]::Min($comp.Width, $this.Options.ColumnWidth)
                    $comp.Height = [Math]::Min($comp.Height, $this.Options.RowHeight)
                }
            }
        }.GetNewClosure()
        
        ApplyDockLayout = {
            $this = $args[-1]
            $remainingX = $this.Container.X
            $remainingY = $this.Container.Y
            $remainingWidth = $this.Container.Width
            $remainingHeight = $this.Container.Height
            
            # Process in order: Top, Bottom, Left, Right, Fill
            $dockOrder = @('Top', 'Bottom', 'Left', 'Right', 'Fill')
            
            foreach ($dock in $dockOrder) {
                $items = $this.Components | Where-Object { $_.LayoutProps.Dock -eq $dock }
                
                foreach ($item in $items) {
                    $comp = $item.Component
                    
                    switch ($dock) {
                        'Top' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $remainingY += $comp.Height
                            $remainingHeight -= $comp.Height
                        }
                        'Bottom' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY + $remainingHeight - $comp.Height
                            $comp.Width = $remainingWidth
                            $remainingHeight -= $comp.Height
                        }
                        'Left' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingX += $comp.Width
                            $remainingWidth -= $comp.Width
                        }
                        'Right' {
                            $comp.X = $remainingX + $remainingWidth - $comp.Width
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingWidth -= $comp.Width
                        }
                        'Fill' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $comp.Height = $remainingHeight
                        }
                    }
                }
            }
        }.GetNewClosure()
        
        # Helper to calculate required size
        GetRequiredSize = {
            $this = $args[-1]
            $width = 0
            $height = 0
            
            switch ($this.Mode) {
                'Stack' {
                    if ($this.Options.Direction -eq 'Vertical') {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Maximum).Maximum
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Sum).Sum
                        $height += ($this.Components.Count - 1) * $this.Options.Spacing
                    } else {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Sum).Sum
                        $width += ($this.Components.Count - 1) * $this.Options.Spacing
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Maximum).Maximum
                    }
                }
                'Grid' {
                    $cols = $this.Options.Columns
                    $rows = [Math]::Ceiling($this.Components.Count / $cols)
                    $width = $cols * $this.Options.ColumnWidth + ($cols - 1) * $this.Options.Spacing
                    $height = $rows * $this.Options.RowHeight + ($rows - 1) * $this.Options.Spacing
                }
            }
            
            $width += $this.Options.Padding.Left + $this.Options.Padding.Right
            $height += $this.Options.Padding.Top + $this.Options.Padding.Bottom
            
            return @{ Width = $width; Height = $height }
        }.GetNewClosure()
    }
    
    # Bind methods to the manager instance
    $manager.Add = $manager.Add.Invoke(@($manager))
    $manager.Clear = $manager.Clear.Invoke(@($manager))
    $manager.Apply = $manager.Apply.Invoke(@($manager))
    $manager.ApplyStackLayout = $manager.ApplyStackLayout.Invoke(@($manager))
    $manager.ApplyGridLayout = $manager.ApplyGridLayout.Invoke(@($manager))
    $manager.ApplyDockLayout = $manager.ApplyDockLayout.Invoke(@($manager))
    $manager.GetRequiredSize = $manager.GetRequiredSize.Invoke(@($manager))
    
    return $manager
}

function global:Center-Component {
    <#
    .SYNOPSIS
    Centers a component within a container
    #>
    param(
        [hashtable]$Component,
        [hashtable]$Container = @{ X = 0; Y = 0; Width = $global:TuiState.BufferWidth; Height = $global:TuiState.BufferHeight }
    )
    
    $Component.X = $Container.X + [Math]::Floor(($Container.Width - $Component.Width) / 2)
    $Component.Y = $Container.Y + [Math]::Floor(($Container.Height - $Component.Height) / 2)
}

function global:Align-Components {
    <#
    .SYNOPSIS
    Aligns multiple components horizontally or vertically
    #>
    param(
        [hashtable[]]$Components,
        [string]$Direction = 'Horizontal',  # 'Horizontal' or 'Vertical'
        [string]$Alignment = 'Center',      # 'Top', 'Middle', 'Bottom' for horizontal; 'Left', 'Center', 'Right' for vertical
        [int]$Spacing = 2
    )
    
    if ($Components.Count -eq 0) { return }
    
    if ($Direction -eq 'Horizontal') {
        # Calculate total width needed
        $totalWidth = ($Components | ForEach-Object { $_.Width } | Measure-Object -Sum).Sum
        $totalWidth += ($Components.Count - 1) * $Spacing
        
        # Starting X position
        $currentX = switch ($Alignment) {
            'Left' { 0 }
            'Right' { $global:TuiState.BufferWidth - $totalWidth }
            default { [Math]::Floor(($global:TuiState.BufferWidth - $totalWidth) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.X = $currentX
            $currentX += $comp.Width + $Spacing
        }
    } else {
        # Calculate total height needed
        $totalHeight = ($Components | ForEach-Object { $_.Height } | Measure-Object -Sum).Sum
        $totalHeight += ($Components.Count - 1) * $Spacing
        
        # Starting Y position
        $currentY = switch ($Alignment) {
            'Top' { 0 }
            'Bottom' { $global:TuiState.BufferHeight - $totalHeight }
            default { [Math]::Floor(($global:TuiState.BufferHeight - $totalHeight) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.Y = $currentY
            $currentY += $comp.Height + $Spacing
        }
    }
}

function global:Create-ComponentGrid {
    <#
    .SYNOPSIS
    Arranges components in a grid layout
    #>
    param(
        [hashtable[]]$Components,
        [int]$Columns = 2,
        [int]$StartX = 0,
        [int]$StartY = 0,
        [int]$CellWidth = 20,
        [int]$CellHeight = 5,
        [int]$HorizontalSpacing = 2,
        [int]$VerticalSpacing = 1
    )
    
    for ($i = 0; $i -lt $Components.Count; $i++) {
        $row = [Math]::Floor($i / $Columns)
        $col = $i % $Columns
        
        $Components[$i].X = $StartX + ($col * ($CellWidth + $HorizontalSpacing))
        $Components[$i].Y = $StartY + ($row * ($CellHeight + $VerticalSpacing))
    }
}

Export-ModuleMember -Function @(
    'New-TuiLayoutManager',
    'Center-Component',
    'Align-Components',
    'Create-ComponentGrid'
)


####\utilities\positioning-helper.psm1
# Component Positioning Helper Module
# Provides utilities for easier component placement and relative positioning

function global:New-TuiPositioner {
    <#
    .SYNOPSIS
    Creates a positioning helper for managing component placement
    
    .DESCRIPTION
    The positioner helps calculate positions for components relative to each other
    and handles common layout patterns like rows, columns, and grids.
    
    .PARAMETER Container
    Defines the bounding container for positioning
    
    .EXAMPLE
    $pos = New-TuiPositioner -Container @{X=0; Y=0; Width=80; Height=25}
    $button1Pos = $pos.NextInRow(10, 3)  # Width=10, Height=3
    $button2Pos = $pos.NextInRow(10, 3)  # Automatically positioned after button1
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $positioner = @{
        Container = $Container
        CurrentX = $Container.X + ($Options.PaddingLeft ?? 0)
        CurrentY = $Container.Y + ($Options.PaddingTop ?? 0)
        RowHeight = 0
        Options = @{
            Spacing = $Options.Spacing ?? 1
            PaddingTop = $Options.PaddingTop ?? 0
            PaddingRight = $Options.PaddingRight ?? 0
            PaddingBottom = $Options.PaddingBottom ?? 0
            PaddingLeft = $Options.PaddingLeft ?? 0
        }
        
        # Reset to start of container
        Reset = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
            $this.RowHeight = 0
        }
        
        # Move to next row
        NewRow = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY += $this.RowHeight + $this.Options.Spacing
            $this.RowHeight = 0
        }
        
        # Get next position in current row
        NextInRow = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current row
            $maxX = $this.Container.X + $this.Container.Width - $this.Options.PaddingRight
            if (($this.CurrentX + $Width) -gt $maxX) {
                & $this.NewRow
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentX += $Width + $this.Options.Spacing
            $this.RowHeight = [Math]::Max($this.RowHeight, $Height)
            
            return $position
        }
        
        # Get next position in current column
        NextInColumn = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current column
            $maxY = $this.Container.Y + $this.Container.Height - $this.Options.PaddingBottom
            if (($this.CurrentY + $Height) -gt $maxY) {
                # Move to next column
                $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
                $this.CurrentX += $Width + $this.Options.Spacing
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentY += $Height + $this.Options.Spacing
            
            return $position
        }
        
        # Position at specific coordinates
        At = {
            param([int]$X, [int]$Y, [int]$Width, [int]$Height)
            
            $this.CurrentX = $X + $Width + $this.Options.Spacing
            $this.CurrentY = $Y
            $this.RowHeight = $Height
            
            return @{
                X = $X
                Y = $Y
                Width = $Width
                Height = $Height
            }
        }
        
        # Position relative to another position
        RelativeTo = {
            param(
                [hashtable]$Reference,
                [string]$Direction = "Right",  # Right, Left, Above, Below
                [int]$Width,
                [int]$Height,
                [int]$Offset = $null
            )
            
            if ($null -eq $Offset) { $Offset = $this.Options.Spacing }
            
            $position = switch ($Direction) {
                "Right" {
                    @{
                        X = $Reference.X + $Reference.Width + $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Left" {
                    @{
                        X = $Reference.X - $Width - $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Below" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y + $Reference.Height + $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
                "Above" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y - $Height - $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
            }
            
            return $position
        }
        
        # Center component in container
        Center = {
            param([int]$Width, [int]$Height)
            
            return @{
                X = $this.Container.X + [Math]::Floor(($this.Container.Width - $Width) / 2)
                Y = $this.Container.Y + [Math]::Floor(($this.Container.Height - $Height) / 2)
                Width = $Width
                Height = $Height
            }
        }
        
        # Align to edges
        AlignTopLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignTopRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
    }
    
    return $positioner
}

function global:Position-Components {
    <#
    .SYNOPSIS
    Positions multiple components using a layout pattern
    
    .PARAMETER Components
    Array of component hashtables to position
    
    .PARAMETER Pattern
    Layout pattern: 'Row', 'Column', 'Grid', 'Flow'
    
    .PARAMETER Container
    Container bounds
    
    .PARAMETER Options
    Layout options (spacing, columns for grid, etc.)
    #>
    param(
        [hashtable[]]$Components,
        [string]$Pattern = 'Row',
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $spacing = $Options.Spacing ?? 1
    $padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
    
    switch ($Pattern) {
        'Row' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
            }
        }
        
        'Column' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $y += $comp.Height + $spacing
            }
        }
        
        'Grid' {
            $columns = $Options.Columns ?? 2
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $col = 0
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                if ($col -ge $columns) {
                    $col = 0
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
                $col++
            }
        }
        
        'Flow' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $maxX = $Container.X + $Container.Width - $padding.Right
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                # Check if component fits in current row
                if (($x + $comp.Width) -gt $maxX -and $x -ne ($Container.X + $padding.Left)) {
                    # Move to next row
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
            }
        }
    }
}

function global:Get-RelativePosition {
    <#
    .SYNOPSIS
    Calculate position relative to another component
    #>
    param(
        [hashtable]$Reference,
        [string]$Direction = "Right",
        [int]$Offset = 1
    )
    
    switch ($Direction) {
        "Right" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "Left" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "Above" { return @{ X = $Reference.X; Y = $Reference.Y - $Offset } }
        "Below" { return @{ X = $Reference.X; Y = $Reference.Y + $Reference.Height + $Offset } }
        "TopRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "TopLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "BottomRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y + $Reference.Height } }
        "BottomLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y + $Reference.Height } }
    }
}

Export-ModuleMember -Function @(
    'New-TuiPositioner',
    'Position-Components',
    'Get-RelativePosition'
)


####\_CLASSY-MAIN.ps1
#
# FILE: _CLASSY-MAIN.ps1
# PURPOSE: PMC Terminal v5 "Helios" - Class-Based Main Entry Point
# AI: This file has been refactored to incorporate the sophisticated module loading and
#     service initialization patterns from the R2 version, adapted for class-based architecture.
#

# Set strict mode for better error handling and PowerShell best practices.
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the directory where this script is located to build absolute paths for modules.
$script:BasePath = Split-Path -Parent $MyInvocation.MyCommand.Path

# AI: Corrected module load order to include missing components and updated dependency order
# This incorporates improvements from R2 while maintaining class-based architecture.
$script:ModulesToLoad = @(
    # Core infrastructure (no dependencies)
    @{ Name = "exceptions"; Path = "modules\exceptions.psm1"; Required = $true },
    @{ Name = "logger"; Path = "modules\logger.psm1"; Required = $true },
    @{ Name = "event-system"; Path = "modules\event-system.psm1"; Required = $true },
    @{ Name = "models"; Path = "modules\models.psm1"; Required = $true },

    # Data and theme (depend on event system and models)
    @{ Name = "data-manager"; Path = "modules\data-manager.psm1"; Required = $true },
    @{ Name = "theme-manager"; Path = "modules\theme-manager.psm1"; Required = $true },

    # Framework (depends on event system)
    @{ Name = "tui-framework"; Path = "modules\tui-framework.psm1"; Required = $true },

    # Engine (depends on theme and framework)
    @{ Name = "tui-engine-v2"; Path = "modules\tui-engine-v2.psm1"; Required = $true },

    # Dialog system (depends on engine)
    @{ Name = "dialog-system"; Path = "modules\dialog-system.psm1"; Required = $true },

    # Services (class-based)
    @{ Name = "keybinding-service"; Path = "services\keybinding-service.psm1"; Required = $true },
    @{ Name = "navigation-service"; Path = "services\navigation-service-class.psm1"; Required = $true },

    # Layout system
    @{ Name = "panels-class"; Path = "layout\panels-class.psm1"; Required = $true },

    # Focus management (depends on event system)
    @{ Name = "focus-manager"; Path = "utilities\focus-manager.psm1"; Required = $true },

    # Components (depend on engine and panels)
    @{ Name = "advanced-input-components"; Path = "components\advanced-input-components.psm1"; Required = $true },
    @{ Name = "advanced-data-components"; Path = "components\advanced-data-components.psm1"; Required = $true },
    @{ Name = "tui-components"; Path = "components\tui-components.psm1"; Required = $false },

    # UI Classes (depend on engine and models) - MUST be loaded in dependency order
    @{ Name = "ui-classes"; Path = "components\ui-classes.psm1"; Required = $true },
    @{ Name = "panel-classes"; Path = "components\panel-classes.psm1"; Required = $true },
    @{ Name = "table-class"; Path = "components\table-class.psm1"; Required = $true },
    @{ Name = "navigation-class"; Path = "components\navigation-class.psm1"; Required = $true }
)

# Screen modules will be loaded dynamically by the framework.
# AI: Updated to match existing screens in CLASSY - only load screens that exist
$script:ScreenModules = @(
    "dashboard\dashboard-screen",  # AI: Corrected path for dashboard screen
    "task-list-screen"              # AI: Keep existing class-based screen
)

function Initialize-PMCModules {
    param([bool]$Silent = $false)
    
    return Invoke-WithErrorHandling -Component "ModuleLoader" -ScriptBlock {
        if (-not $Silent) {
            Write-Host "Verifying console environment..." -ForegroundColor Gray
        }
        $minWidth = 80
        $minHeight = 24
        if ($Host.UI.RawUI) {
            if ($Host.UI.RawUI.WindowSize.Width -lt $minWidth -or $Host.UI.RawUI.WindowSize.Height -lt $minHeight) {
                Write-Host "Console window too small. Please resize to at least $minWidth x $minHeight and restart." -ForegroundColor Yellow
                Read-Host "Press Enter to exit."
                throw "Console window too small."
            }
        }

        $loadedModules = @()
        $totalModules = $script:ModulesToLoad.Count
        $currentModule = 0

        foreach ($module in $script:ModulesToLoad) {
            $currentModule++
            $modulePath = Join-Path $script:BasePath $module.Path
            
            if (-not $Silent) {
                $percent = [Math]::Round(($currentModule / $totalModules) * 100)
                Write-Host "`rLoading modules... [$percent%] $($module.Name)" -NoNewline -ForegroundColor Cyan
            }
            
            if (Test-Path $modulePath) {
                try {
                    Import-Module $modulePath -Force -Global
                    $loadedModules += $module.Name
                } catch {
                    if ($module.Required) {
                        Write-Host "`nFATAL: Failed to load required module: $($module.Name)" -ForegroundColor Red
                        throw "Failed to load required module: $($module.Name). Error: $($_.Exception.Message)"
                    } else {
                        if (-not $Silent) { Write-Host "`nSkipping optional module: $($module.Name)" -ForegroundColor Yellow }
                    }
                }
            } else {
                if ($module.Required) {
                    throw "Required module file not found: $($module.Name) at $modulePath"
                }
            }
        }
        
        if (-not $Silent) { Write-Host "`rModules loaded successfully.                                    " -ForegroundColor Green }
        return $loadedModules
    } -Context "Initializing core and utility modules"
}

function Initialize-PMCScreens {
    param([bool]$Silent = $false)
    
    return Invoke-WithErrorHandling -Component "ScreenLoader" -ScriptBlock {
        if (-not $Silent) { Write-Host "Loading screens..." -ForegroundColor Cyan }
        
        $loadedScreens = @()
        foreach ($screenName in $script:ScreenModules) {
            $screenPath = Join-Path $script:BasePath "screens\$screenName.psm1"
            if (Test-Path $screenPath) {
                try {
                    Import-Module $screenPath -Force -Global
                    $loadedScreens += $screenName
                } catch {
                    Write-Warning "Failed to load screen module '$screenName': $_"
                }
            }
        }
        
        if (-not $Silent) { Write-Host "Screens loaded: $($loadedScreens.Count) of $($script:ScreenModules.Count)" -ForegroundColor Green }
        return $loadedScreens
    } -Context "Initializing screen modules"
}

function Start-PMCTerminal {
    param([bool]$Silent = $false)
    
    Invoke-WithErrorHandling -Component "Main" -ScriptBlock {
        Write-Log -Level Info -Message "PMC Terminal v5 'Helios' Class-Based startup initiated."
        
        # --- 1. Load Core Modules ---
        $loadedModules = Initialize-PMCModules -Silent:$Silent
        Write-Log -Level Info -Message "Core modules loaded: $($loadedModules -join ', ')"
        
        # --- 2. Load UI Screens (before services that depend on them) ---
        # AI: Moved screen loading before service initialization so screen functions are available
        $loadedScreens = Initialize-PMCScreens -Silent:$Silent
        Write-Log -Level Info -Message "Screen modules loaded: $($loadedScreens -join ', ')"
        
        # --- 3. Initialize Core Systems (in dependency order) ---
        # AI: The service initialization sequence is now explicit and ordered by dependency.
        Initialize-EventSystem
        Initialize-ThemeManager
        $dataManagerService = Initialize-DataManager
        Initialize-TuiFramework
        if (Get-Command Initialize-FocusManager -ErrorAction SilentlyContinue) {
            Initialize-FocusManager
        }
        Initialize-DialogSystem
        
        # --- 4. Initialize and Assemble Class-Based Services ---
        $services = @{
            DataManager = $dataManagerService
        }
        
        # AI: Create class-based services
        if (Get-Command Initialize-KeybindingService -ErrorAction SilentlyContinue) {
            $services.Keybindings = Initialize-KeybindingService -EnableChords $false
        } else {
            # Fallback to class-based keybinding service
            $services.Keybindings = [KeybindingService]::new()
        }
        
        # AI: Initialize class-based navigation service
        if ([NavigationService]) {
            $services.Navigation = [NavigationService]::new($services)
        } else {
            Write-Log -Level Warning -Message "NavigationService class not available, using fallback initialization"
            if (Get-Command Initialize-NavigationService -ErrorAction SilentlyContinue) {
                $services.Navigation = Initialize-NavigationService $services
            }
        }
        
        $global:Services = $services
        Write-Log -Level Info -Message "All services initialized and assembled."
        
        # --- 5. Register Navigation Routes ---
        # AI: Routes are now registered automatically in the class constructor
        Write-Log -Level Info -Message "Navigation routes registered automatically."
        
        # --- 6. Initialize TUI Engine and Navigate ---
        if (-not $Silent) { Write-Host "`nStarting TUI..." -ForegroundColor Green }
        Clear-Host
        
        Initialize-TuiEngine
        
        $startPath = if ($args -contains "-start" -and ($args.IndexOf("-start") + 1) -lt $args.Count) {
            $args[$args.IndexOf("-start") + 1]
        } else {
            "/dashboard"
        }
        
        # AI: Use clean navigation abstraction - no direct access to internals
        if ($services.Navigation) {
            # Check if route is valid before navigating
            if ((Get-Member -InputObject $services.Navigation -Name "IsValidRoute" -ErrorAction SilentlyContinue) -and 
                -not $services.Navigation.IsValidRoute($startPath)) {
                Write-Log -Level Warning -Message "Startup path '$startPath' is not valid. Defaulting to /dashboard."
                $startPath = "/dashboard"
            }
            
            # Navigate using the GoTo method - returns boolean indicating success
            $navigationResult = $services.Navigation.GoTo($startPath)
            if (-not $navigationResult) {
                throw "Failed to navigate to initial screen at path: $startPath"
            }
        } else {
            throw "Navigation service is not available"
        }
        
        # --- 7. Start the Main Loop ---
        Start-TuiLoop
        
        Write-Log -Level Info -Message "PMC Terminal exited gracefully."
    } -Context "Main startup sequence"
}

# ===================================================================
# MAIN EXECUTION BLOCK
# ===================================================================
try {
    # CRITICAL: Pre-load logger and exceptions BEFORE anything else to ensure
    # error handling and logging are available throughout the entire startup sequence.
    $loggerModulePath = Join-Path $script:BasePath "modules\logger.psm1"
    $exceptionsModulePath = Join-Path $script:BasePath "modules\exceptions.psm1"
    
    if (-not (Test-Path $exceptionsModulePath)) { throw "CRITICAL: The core exceptions module is missing at '$exceptionsModulePath'." }
    if (-not (Test-Path $loggerModulePath)) { throw "CRITICAL: The core logger module is missing at '$loggerModulePath'." }
    
    Import-Module $exceptionsModulePath -Force -Global
    Import-Module $loggerModulePath -Force -Global

    # Now that logger is available, initialize it.
    Initialize-Logger
    
    # Start the main application logic, wrapped in top-level error handling.
    Start-PMCTerminal -Silent:$false
    
} catch {
    # This is our absolute last resort error handler.
    $errorMessage = "A fatal, unhandled exception occurred during application startup: $($_.Exception.Message)"
    Write-Host "`n$errorMessage" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Gray
    
    # Try to log if possible.
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Fatal -Message $errorMessage -Data @{
            Exception = $_.Exception
            ScriptStackTrace = $_.ScriptStackTrace
        } -Force
    }
    
    # Exit with a non-zero code to indicate failure.
    exit 1
}
finally {
    # Final cleanup actions
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Application shutting down."
    }
    
    # AI: Check if $global:Services exists before trying to access it
    if (Test-Path Variable:global:Services) {
        if ($global:Services -and $global:Services.DataManager) {
            try {
                if (Get-Member -InputObject $global:Services.DataManager -Name "SaveData" -ErrorAction SilentlyContinue) {
                    $global:Services.DataManager.SaveData()
                    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                        Write-Log -Level Info -Message "Data saved successfully."
                    }
                }
            }
            catch {
                Write-Warning "Failed to save data on exit: $_"
            }
        }
    }
}


####\Clear-ModuleCache.ps1
# Clear PowerShell Module Cache for PMC Terminal
Write-Host "Clearing PowerShell module cache..." -ForegroundColor Yellow

# Get all loaded modules from our application
$modulesToRemove = Get-Module | Where-Object { 
    $_.Path -like "*\_CLASSY*" -or 
    $_.Name -in @('models', 'logger', 'exceptions', 'event-system', 'data-manager', 
                   'theme-manager', 'tui-framework', 'tui-engine-v2', 'dialog-system',
                   'keybinding-service', 'navigation-service-class', 'panels-class',
                   'focus-manager', 'advanced-input-components', 'advanced-data-components',
                   'ui-classes', 'panel-classes', 'table-class', 'navigation-class')
}

foreach ($module in $modulesToRemove) {
    Write-Host "Removing module: $($module.Name)" -ForegroundColor Cyan
    Remove-Module $module -Force -ErrorAction SilentlyContinue
}

# Clear any compiled assemblies (for our custom exceptions)
if ('Helios.HeliosException' -as [type]) {
    Write-Host "Note: Custom exception types are loaded and cannot be unloaded in this session." -ForegroundColor Yellow
    Write-Host "For a complete refresh, please start a new PowerShell session." -ForegroundColor Yellow
}

Write-Host "`nModule cache cleared. You can now run the application again." -ForegroundColor Green
Write-Host "Run: pwsh -file _CLASSY-MAIN.ps1" -ForegroundColor White



####\filecopy.ps1
# This script finds all .ps1 and .psm1 files in the current directory and its subdirectories.
# For each found file, it creates a copy with a .txt extension in the same location.
# Finally, it concatenates the content of all original .ps1 and .psm1 files into a single file named 'all.txt'
# in the current directory. Each appended file is preceded by a header indicating its relative path.

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the current working directory, ensuring no trailing backslash for consistent path manipulation
$currentDirectory = (Get-Location).Path.TrimEnd('\')

# Define the name of the output concatenated file
$outputFileName = "all.txt"

Write-Host "Starting script operations in: $currentDirectory"

# --- Step 1: Clear the existing output file if it exists ---
try {
    if (Test-Path $outputFileName) {
        Remove-Item $outputFileName -Force -ErrorAction Stop
        Write-Host "Cleared existing '$outputFileName'."
    }
} catch {
    Write-Warning "Failed to clear '$outputFileName': $($_.Exception.Message)"
    # Continue, as this might not be a fatal error for the rest of the script
}

# --- Step 2: Find all .ps1 and .psm1 files recursively ---
try {
    $scriptFiles = Get-ChildItem -Path $currentDirectory -Recurse -Include *.ps1, *.psm1 -File -ErrorAction Stop
    Write-Host "Found $($scriptFiles.Count) PowerShell script files."
} catch {
    Write-Error "Failed to enumerate script files: $($_.Exception.Message)"
    exit 1 # Exit if we can't even find the files
}

# --- Step 3: Process each file (copy and concatenate) ---
if ($scriptFiles.Count -eq 0) {
    Write-Warning "No .ps1 or .psm1 files found to process."
} else {
    foreach ($file in $scriptFiles) {
        # Create a copy with .txt ending in the same folder
        $txtCopyPath = Join-Path -Path $file.DirectoryName -ChildPath ($file.BaseName + ".txt")
        try {
            Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force -ErrorAction Stop
            Write-Host "  Copied: $($file.Name) to $($txtCopyPath)"
        } catch {
            Write-Warning "  Failed to copy $($file.FullName) to $($txtCopyPath): $($_.Exception.Message)"
        }

        # Prepare header for all.txt using relative path
        # Remove the base directory part from the full path to get the relative path
        $relativePath = $file.FullName.Substring($currentDirectory.Length)
        # Ensure the relative path starts with a single backslash
        if (-not $relativePath.StartsWith('\')) {
            $relativePath = '\' + $relativePath
        }

        $header = "####$relativePath"
        
        # Append the header and file content to all.txt
        try {
            Add-Content -Path $outputFileName -Value $header -Encoding UTF8 -ErrorAction Stop
            # Read the entire file content as a single string
            $fileContent = Get-Content -Path $file.FullName -Raw -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value $fileContent -Encoding UTF8 -ErrorAction Stop
            Add-Content -Path $outputFileName -Value "`n" -Encoding UTF8 -ErrorAction Stop # Add an extra newline for separation
            Write-Host "  Appended: $($file.Name) to $($outputFileName)"
        } catch {
            Write-Warning "  Failed to append $($file.FullName) to $($outputFileName): $($_.Exception.Message)"
        }
    }
}

Write-Host "All operations complete. Concatenated content saved to '$outputFileName'."


